<!DOCTYPE html>
<!-- htmlhint-disable -->
<!-- eslint-disable -->
<!-- prettier-ignore -->
<html lang="th" class="scroll-smooth" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <title>‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤</title>

  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png" />
  <link rel="shortcut icon" href="/favicon/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="/favicon/android-chrome-192x192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="/favicon/android-chrome-512x512.png" />

  <script src="../../js/activity-tracker.js"></script>
  <script src="/js/branch-navigation.js"></script>
  <script src="/views/pattani/sidebar/sidebar.js"></script>
  
  <!-- Security Headers -->
  <meta name="csrf-token" content="">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="X-XSS-Protection" content="1; mode=block">
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          fontFamily: {
            sans: ['Prompt', 'sans-serif'],
          },
        },
      },
    };
  </script>

  <!-- DaisyUI -->
  <link href="https://cdn.jsdelivr.net/npm/daisyui@2.51.5/dist/full.css" rel="stylesheet" type="text/css" />

  <!-- Socket.IO with fallback -->
  <script>
    // Socket.IO availability check
    window.socketIOAvailable = false;
  </script>
  <script src="/socket.io/socket.io.js" 
          onload="window.socketIOAvailable = true;" 
          onerror="console.warn('Socket.IO script failed to load, continuing without real-time features');"></script>





          

  <!-- Bootstrap Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" />

  <!-- Google Fonts: Prompt -->

  <!-- Animate.css -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />

  <!-- Lottie Animation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Prompt:wght@400;500;600&display=swap" rel="stylesheet" />
  
  <!-- Sidebar CSS -->
  <link rel="stylesheet" href="/views/pattani/sidebar/sidebar.css" />

  <!-- Modular Notification System -->
  <link rel="stylesheet" href="/css/notification-modules.css">
  <script src="/js/notification-modules.js"></script>

  <!-- Sidebar Management -->
  <script>
  </script>

  <style>
    /* Minimal Design System */
    :root {
      /* Colors - Simplified palette */
      --primary: #2563eb;
      --primary-hover: #1d4ed8;
      --success: #10b981;
      --danger: #ef4444;
      --warning: #f59e0b;
      
      /* Neutrals */
      --gray-50: #f9fafb;
      --gray-100: #f3f4f6;
      --gray-200: #e5e7eb;
      --gray-300: #d1d5db;
      --gray-500: #6b7280;
      --gray-700: #374151;
      --gray-900: #111827;
      
      /* Spacing */
      --space-1: 0.25rem;
      --space-2: 0.5rem;
      --space-3: 0.75rem;
      --space-4: 1rem;
      --space-6: 1.5rem;
      --space-8: 2rem;
      
      /* Border radius */
      --radius: 0.5rem;
      --radius-sm: 0.375rem;
      
      /* Shadows */
      --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    }

    /* Dark mode */
    [data-theme="dark"] {
      --gray-50: #18181b;
      --gray-100: #27272a;
      --gray-200: #3f3f46;
      --gray-300: #52525b;
      --gray-500: #a1a1aa;
      --gray-700: #e4e4e7;
      --gray-900: #fafafa;
    }

    /* Base Reset */
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Prompt', sans-serif;
      color: var(--gray-900);
      background: var(--gray-50);
      margin: 0;
      line-height: 1.5;
    }

    /* Minimal Components */
    .card {
      background: white;
      border-radius: var(--radius);
      box-shadow: var(--shadow-sm);
      border: 1px solid var(--gray-200);
    }
    
    [data-theme="dark"] .card {
      background: var(--gray-100);
      border-color: var(--gray-300);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2) var(--space-4);
      font-size: 0.875rem;
      font-weight: 500;
      border-radius: var(--radius-sm);
      border: 1px solid transparent;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: var(--primary);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--primary-hover);
    }

    .btn-ghost {
      background: transparent;
      color: var(--gray-700);
      border-color: var(--gray-300);
    }

    .btn-ghost:hover:not(:disabled) {
      background: var(--gray-100);
    }

    .btn-danger {
      background: white;
      color: var(--danger);
      border-color: var(--danger);
    }

    .btn-danger:hover:not(:disabled) {
      background: var(--danger);
      color: white;
    }

    /* Button sizes */
    .btn-sm {
      padding: var(--space-1) var(--space-3);
      font-size: 0.75rem;
    }

    .btn-outline {
      background: transparent;
      color: var(--gray-700);
      border-color: var(--gray-300);
    }

    .btn-outline:hover:not(:disabled) {
      background: var(--gray-100);
    }

    .btn-success {
      background: var(--success);
      color: white;
    }

    .btn-success:hover:not(:disabled) {
      background: #0f9d58;
    }

    .btn-error {
      background: var(--danger);
      color: white;
    }

    .btn-error:hover:not(:disabled) {
      background: #dc2626;
    }

    .input {
      width: 100%;
      padding: var(--space-2) var(--space-3);
      font-size: 0.875rem;
      border: 1px solid var(--gray-300);
      border-radius: var(--radius-sm);
      background: white;
      transition: border-color 0.15s;
    }

    .input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    [data-theme="dark"] .input {
      background: var(--gray-100);
      border-color: var(--gray-300);
      color: var(--gray-900);
    }

    .input-bordered {
      border: 1px solid var(--gray-300);
    }

    .input-sm {
      padding: var(--space-1) var(--space-2);
      font-size: 0.75rem;
    }

    /* Tables */
    .table {
      width: 100%;
      font-size: 0.875rem;
      border-collapse: collapse;
    }

    .table th {
      padding: var(--space-3);
      text-align: left;
      font-weight: 500;
      color: var(--gray-500);
      background: var(--gray-50);
      border-bottom: 1px solid var(--gray-200);
    }

    .table td {
      padding: var(--space-3);
      border-bottom: 1px solid var(--gray-100);
    }

    [data-theme="dark"] .table th {
      background: var(--gray-200);
      border-color: var(--gray-300);
    }

    [data-theme="dark"] .table td {
      border-color: var(--gray-200);
    }

    .table-zebra tbody tr:nth-child(odd) {
      background: var(--gray-50);
    }

    [data-theme="dark"] .table-zebra tbody tr:nth-child(odd) {
      background: var(--gray-200);
    }

    /* Badges */
    .badge {
      display: inline-flex;
      align-items: center;
      padding: var(--space-1) var(--space-2);
      font-size: 0.75rem;
      font-weight: 500;
      border-radius: 9999px;
    }

    .badge-info {
      background: rgba(37, 99, 235, 0.1);
      color: var(--primary);
    }

    .badge-success {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
    }

    .badge-warning {
      background: rgba(245, 158, 11, 0.1);
      color: var(--warning);
    }

    .badge-error {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
    }

    /* Layout */
    #mainContent {
      transition: margin-left 0.3s;
      margin-left: 14rem;
      min-height: 100vh;
      background: var(--gray-50);
    }

    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--space-4);
    }

    .section-title {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--gray-900);
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    /* Tab styles */
    .tab-button {
      background: transparent;
      color: var(--gray-500);
      border: none;
      position: relative;
    }
    
    .tab-button:hover {
      color: var(--gray-700);
      background: var(--gray-100);
    }
    
    .tab-button.tab-active {
      background: white;
      color: var(--primary);
      box-shadow: var(--shadow-sm);
    }
    
    [data-theme="dark"] .tab-button {
      color: var(--gray-500);
    }
    
    [data-theme="dark"] .tab-button:hover {
      color: var(--gray-300);
      background: var(--gray-200);
    }
    
    [data-theme="dark"] .tab-button.tab-active {
      background: var(--gray-100);
      color: var(--primary);
    }

    /* Animations */
    .animate-in {
      animation: fadeIn 0.3s ease-out;
    }

    .animate-out {
      animation: fadeOut 0.3s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }


    /* Checkbox styles */
    .checkbox {
      width: 1rem;
      height: 1rem;
      cursor: pointer;
    }

    .checkbox-sm {
      width: 0.875rem;
      height: 0.875rem;
    }

    /* Form controls */
    .form-control {
      margin-bottom: var(--space-4);
    }

    .label {
      display: block;
      margin-bottom: var(--space-1);
    }

    .label-text {
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--gray-700);
    }

    [data-theme="dark"] .label-text {
      color: var(--gray-300);
    }

    /* Alert */
    .alert {
      padding: var(--space-3) var(--space-4);
      border-radius: var(--radius-sm);
      margin-bottom: var(--space-4);
    }

    .alert-success {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
      border: 1px solid rgba(16, 185, 129, 0.2);
    }

    .alert-error {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
      border: 1px solid rgba(239, 68, 68, 0.2);
    }

    .alert-warning {
      background: rgba(245, 158, 11, 0.1);
      color: var(--warning);
      border: 1px solid rgba(245, 158, 11, 0.2);
    }

    .alert-info {
      background: rgba(37, 99, 235, 0.1);
      color: var(--primary);
      border: 1px solid rgba(37, 99, 235, 0.2);
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 50;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      opacity: 0;
      transition: opacity 0.3s;
    }

    .modal-toggle:checked + .modal {
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 1;
    }

    .modal-box {
      background: white;
      padding: var(--space-6);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      max-width: 32rem;
      width: 91.666667%;
      max-height: calc(100vh - 5em);
      overflow-y: auto;
    }

    [data-theme="dark"] .modal-box {
      background: var(--gray-100);
    }

    .modal-action {
      display: flex;
      justify-content: flex-end;
      gap: var(--space-2);
      margin-top: var(--space-4);
    }

    /* Utility classes */
    .text-primary {
      color: var(--primary);
    }

    .text-success {
      color: var(--success);
    }

    .text-error {
      color: var(--danger);
    }

    .text-warning {
      color: var(--warning);
    }

    .editable-imei {
      cursor: pointer;
      text-decoration: underline;
      text-decoration-style: dotted;
    }

    .editable-imei:hover {
      text-decoration-style: solid;
    }

    /* Toast notification */
    .toast-notification {
      min-width: 250px;
      max-width: 400px;
    }

    /* Responsive */
    @media (max-width: 768px) {
      #mainContent {
        margin-left: 0;
      }
      
      .btn span:not(.badge) {
        display: none;
      }
      
      .section-header {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--space-2);
      }
    }
  </style>

  <!-- Loading Overlay CSS (Updated from BOSS home) -->
  <style>
    .loading-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(255, 255, 255, 0.9);
      display: flex; justify-content: center; align-items: center;
      z-index: 9999;
      backdrop-filter: blur(12px);
    }

    /* Loading spinner for fallback */
    .loading {
      display: inline-block;
      width: 1.5rem;
      height: 1.5rem;
      border: 2px solid #e5e7eb;
      border-radius: 50%;
      border-top-color: #3b82f6;
      animation: spin 0.6s linear infinite;
    }

    .loading-lg {
      width: 2.5rem;
      height: 2.5rem;
    }

    .loading-spinner {
      display: inline-block;
      width: 1.5rem;
      height: 1.5rem;
      border: 2px solid #e5e7eb;
      border-radius: 50%;
      border-top-color: #3b82f6;
      animation: spin 0.6s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>

  <!-- Loading JavaScript (Updated from BOSS home) -->
  <script>
    let lottieAnimation = null;
    let loadingCount = 0; // Track loading state

    // Show/Hide Loading Function with state management
    function showLoading(show) {
      const loader = document.getElementById('loadingOverlay');

      if (show) {
        loadingCount++;
        // Only show if first loading request
        if (loadingCount === 1) {
          loader.style.display = 'flex';
          loader.classList.remove('animate__fadeOut');
          loader.classList.add('animate__fadeIn');

          // ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡πà‡∏ô Lottie animation
          if (!lottieAnimation) {
            console.log('üîÑ Loading Lottie animation from /Loading/Loading.json');
            fetch('/Loading/Loading.json')
              .then(response => {
                if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
              })
              .then(animationData => {
                lottieAnimation = lottie.loadAnimation({
                  container: document.getElementById('lottieContainer'),
                  renderer: 'svg',
                  loop: true,
                  autoplay: true,
                  animationData: animationData
                });

                console.log('‚úÖ Lottie animation loaded successfully');
              })
              .catch(error => {
                console.error('‚ùå Error loading Lottie animation:', error);
                // Fallback ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠ Lottie ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
                document.getElementById('lottieContainer').innerHTML = '<div class="loading loading-spinner loading-lg"></div>';
              });
          } else {
            lottieAnimation.play();
          }
        }
      } else {
        loadingCount--;
        // Only hide when all loading requests are done
        if (loadingCount <= 0) {
          loadingCount = 0; // Reset to prevent negative
          if (lottieAnimation) {
            lottieAnimation.pause();
          }
          loader.classList.remove('animate__fadeIn');
          loader.classList.add('animate__fadeOut');
          setTimeout(() => { loader.style.display = 'none'; }, 600);
        }
      }
    }

    // Auto cleanup ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏´‡∏ô‡πâ‡∏≤
    window.addEventListener('beforeunload', () => {
      if (lottieAnimation) {
        lottieAnimation.destroy();
        lottieAnimation = null;
      }
    });
  </script>


  <!-- Firebase v9 SDK -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
    import { getDatabase, ref, onValue, set, push, serverTimestamp, onDisconnect, get, update, remove } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js';
    
    // Firebase configuration - using correct project
    const firebaseConfig = {
      apiKey: "AIzaSyCv4EBbKN8Kr4IMRqszJGBWTSoMihtYLo0",
      authDomain: "pheenongacc.firebaseapp.com",
      databaseURL: "https://pheenongacc-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "pheenongacc",
      storageBucket: "pheenongacc.appspot.com",
      messagingSenderId: "917944021415",
      appId: "1:917944021415:web:8c8b3d42e52a1dc8c2f0b5",
      measurementId: "G-94BG9ECQTZ"
    };
    
    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);
    
    // Make database available globally
    window.firebaseDatabase = database;
    window.firebaseRef = ref;
    window.firebaseOnValue = onValue;
    window.firebaseSet = set;
    window.firebasePush = push;
    window.firebaseServerTimestamp = serverTimestamp;
    window.firebaseOnDisconnect = onDisconnect;
    window.firebaseGet = get;
    window.firebaseUpdate = update;
    window.firebaseRemove = remove;
    
    console.log('Firebase initialized successfully for Add New Product');
  </script>

  <!-- Socket.IO and Real-time Integration -->
  <script>
    // Initialize Socket.IO connection for Add New Product page
    let firebaseSessionId = null;
    let addProductSocket = null;
    
    function initializeAddProductSocket() {
      if (!window.socketIOAvailable || typeof io === 'undefined') {
        console.warn('Socket.IO not available, skipping real-time features');
        return;
      }
      
      // Use existing socket or create new one if not exists
      if (!socket) {
        try {
          socket = io({
            transports: ['websocket', 'polling'],
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            timeout: 20000
          });
        } catch (error) {
          console.error('Failed to create socket:', error);
          return;
        }
      }
      
      // Make socket globally available
      addProductSocket = socket;
      window.addProductSocket = socket;
      
      // Set up additional event listeners for add product features
      socket.off('connect.addProduct'); // Remove any existing listeners
      socket.on('connect', function addProductConnect() {
        console.log('Socket.IO connected for Add New Product');
        
        // Join add product room
        const branchCode = getCurrentBranchCode();
        socket.emit('join-room', {
          room: `add-product-${branchCode}`,
          userId: localStorage.getItem('userId'),
          userName: localStorage.getItem('userName'),
          userRole: localStorage.getItem('userRole')
        });
        
        // Create Firebase session
        createAddProductSession();
      });
      
      // Product-specific events
      socket.on('product-added', (data) => {
        if (data.userId !== localStorage.getItem('userId')) {
          console.log('New product added by another user:', data);
          showNotification(`üì¶ ${data.userName} ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏´‡∏°‡πà: ${data.productName}`, 'info');
        }
      });
      
      socket.on('stock-sent-for-approval', (data) => {
        if (data.userId !== localStorage.getItem('userId')) {
          console.log('Stock sent for approval:', data);
          showNotification(`üìã ${data.userName} ‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥`, 'info');
        }
      });
      
      socket.on('branch-stock-updated', (data) => {
        console.log('Branch stock updated:', data);
        showNotification(`üìä ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Branch Stock ‡∏ñ‡∏π‡∏Å‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó`, 'info');
      });
      
      // User activity events
      socket.on('user-joined-add-product', (data) => {
        console.log('User joined add product:', data);
        updateOnlineUsers();
      });
      
      socket.on('user-left-add-product', (data) => {
        console.log('User left add product:', data);
        updateOnlineUsers();
      });
    }
    
    // Get current branch code
    function getCurrentBranchCode() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('branch') || localStorage.getItem('activeBranch') || 'PATTANI';
    }
    
    // Show notification function (fallback if notification system not loaded)
    function showNotification(message, type = 'info', duration = 3000) {
      if (typeof window.NotificationManager !== 'undefined') {
        window.NotificationManager.show(message, type, duration);
      } else {
        // Fallback to console
        console.log(`${type.toUpperCase()}: ${message}`);
      }
    }
  </script>

</head>

<body class="flex flex-col min-h-screen">
  <!-- Loading Overlay (Updated from BOSS home) -->
  <div id="loadingOverlay" class="loading-overlay animate__animated animate__fadeOut" style="display: none;">
    <div class="text-center">
      <div id="lottieContainer" class="w-96 h-96 mx-auto flex items-center justify-center"></div>
    </div>
  </div>

    </div>
  
  <!-- Sidebar Container -->
  <div id="sidebarContainer"></div>

  <div class="flex min-h-screen">
    <!-- Main Content -->
    <div class="flex-1 flex flex-col ml-56" id="mainContent">
      <!-- Header -->
      <header class="p-4 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between"
                       id="mainHeader">
        <div>
          <h1 class="text-lg font-semibold" id="pageTitle">‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤</h1>
          <p class="text-sm text-gray-600 dark:text-gray-300" id="branchInfo">
            ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏≤‡∏Ç‡∏≤...
          </p>
        </div>

        <!-- Modular Notifications -->
        <div class="flex items-center gap-4">
          <!-- POS Notification Bell -->
          <div class="notification-bell pos-module" id="posNotificationBell">
            <button class="notification-toggle" title="‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô POS">
              <i class="bi bi-bell"></i>
              <span class="notification-badge" id="posNotificationCount">0</span>
            </button>
            
            <!-- Dropdown Notifications -->
            <div class="notification-dropdown" id="posNotificationDropdown">
              <div class="notification-header">
                <h3><i class="bi bi-shop-window"></i> ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô POS</h3>
                <div class="notification-actions">
                  <button class="mark-all-read" onclick="markAllAsRead('pos')">
                    <i class="bi bi-check-all"></i>
                  </button>
                  <button class="clear-all" onclick="clearAllNotifications('pos')">
                    <i class="bi bi-trash"></i>
                  </button>
                </div>
              </div>
              <div class="notification-list" id="posNotificationList">
                <!-- Notifications will be inserted here -->
              </div>
            </div>
          </div>
        </div>
      </header>

      <!-- Toast Notification Container for POS Module -->
      <div id="posToastContainer" class="toast-container pos-module"></div>

      <!-- Branch Selection & Barcode Scanner -->
      <div class="card animate-in mb-6 p-6">
        <div class="section-header">
          <h2 class="section-title">
            <i class="bi bi-building text-primary"></i>
            ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏≤‡∏Ç‡∏≤ &amp; ‡∏™‡πÅ‡∏Å‡∏ô‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏î‡πâ‡∏´‡∏•‡∏≤‡∏¢‡∏ä‡∏¥‡πâ‡∏ô)
          </h2>
        </div>
        
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <!-- Branch Select -->
          <div>
            <label for="branchSelect" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              ‡∏™‡∏≤‡∏Ç‡∏≤
            </label>
            <select id="branchSelect" class="input" disabled>
              <option value="">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î...</option>
            </select>
          </div>
          
          <!-- Manual Barcode Entry -->
          <div>
            <label for="manualBarcode" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              ‡∏Å‡∏£‡∏≠‡∏Å‡πÄ‡∏•‡∏Ç‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î / IMEI / Serial Number
            </label>
            <div class="flex gap-2">
              <input 
                type="text" 
                id="manualBarcode" 
                class="input flex-1" 
                placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡πÄ‡∏•‡∏Ç‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î ‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡∏î Enter ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á..." 
              />
              <button id="btnAddManualCode" class="btn btn-primary">
                <i class="bi bi-plus-circle"></i>
                <span class="hidden sm:inline">‡πÄ‡∏û‡∏¥‡πà‡∏°</span>
              </button>
              <button id="btnToggleContinuous" class="btn btn-outline" title="‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á">
                <i class="bi bi-arrow-repeat"></i>
                <span class="hidden sm:inline">‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á</span>
              </button>
            </div>
            <div class="flex items-center justify-between mt-1">
              <p class="text-xs text-gray-500">
                <i class="bi bi-info-circle"></i> ‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏à‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ "‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥" ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
              </p>
              <div class="flex items-center gap-2">
                <label class="flex items-center gap-1 text-xs">
                  <input type="checkbox" id="continuousMode" class="checkbox checkbox-sm">
                  <span class="text-gray-600">‡πÇ‡∏´‡∏°‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á</span>
                </label>
              </div>
            </div>
          </div>
          
          <!-- Scan Button -->
          <div>
            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              ‡∏™‡πÅ‡∏Å‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
            </label>
            <div class="flex gap-2">
              <button id="btnScanBarcode" class="btn btn-primary flex-1">
                <i class="bi bi-upc-scan"></i>
                ‡∏™‡πÅ‡∏Å‡∏ô‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î
              </button>
              <button id="btnBatchScan" class="btn btn-success" title="‡∏™‡πÅ‡∏Å‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏ä‡∏¥‡πâ‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á">
                <i class="bi bi-collection"></i>
                <span class="hidden sm:inline">‡∏™‡πÅ‡∏Å‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á</span>
              </button>
            </div>
            <p class="text-xs text-gray-500 mt-1">
              <i class="bi bi-lightbulb"></i> ‡∏™‡πÅ‡∏Å‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏ä‡∏¥‡πâ‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
            </p>
          </div>
        </div>
        
        <!-- Enhanced Scan Status -->
        <div id="scanStatus" class="mt-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg hidden">
          <div class="flex items-center justify-between">
            <div class="flex items-center gap-2 text-sm">
              <div class="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>
              <span class="text-blue-700 dark:text-blue-300" id="scanStatusText">
                ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡∏™‡πÅ‡∏Å‡∏ô‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î...
              </span>
            </div>
            <div class="flex items-center gap-2 text-xs">
              <span id="scanCounter" class="text-blue-600 font-medium">‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß: 0 ‡∏ä‡∏¥‡πâ‡∏ô</span>
              <button id="btnStopScanning" class="btn btn-sm btn-error">
                <i class="bi bi-stop-circle"></i> ‡∏´‡∏¢‡∏∏‡∏î
              </button>
            </div>
          </div>
          <div id="scanProgress" class="mt-2 hidden">
            <div class="w-full bg-gray-200 rounded-full h-2">
              <div id="scanProgressBar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
          </div>
        </div>

        <!-- Recent Additions Preview -->
        <div id="recentAdditions" class="mt-4 hidden">
          <div class="flex items-center justify-between mb-2">
            <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300">
              <i class="bi bi-clock-history mr-1"></i>‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
            </h4>
            <button id="btnClearRecent" class="btn btn-xs btn-ghost">
              <i class="bi bi-x"></i> ‡∏•‡πâ‡∏≤‡∏á
            </button>
          </div>
          <div id="recentList" class="max-h-32 overflow-y-auto space-y-1">
            <!-- Recent items will be added here -->
          </div>
        </div>
      </div>

      <!-- Stock List -->
      <div class="card animate-in p-6">
        <div class="section-header mb-6">
          <h2 class="section-title">
            <i class="bi bi-box-seam text-primary"></i>
            ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏ï‡πä‡∏≠‡∏Å
            <span class="badge badge-info">
              <span id="stockCount">0</span> ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
            </span>
          </h2>
        </div>
        
        <!-- Tab Navigation -->
        <div class="flex gap-1 p-1 bg-gray-100 dark:bg-gray-700 rounded-lg mb-6">
          <button 
            class="flex-1 flex items-center justify-center gap-2 px-4 py-2 rounded-md font-medium text-sm transition-all duration-200 tab-button tab-active"
            id="tab-unverified"
          >
            <i class="bi bi-clock-history"></i>
            <span>‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥</span>
            <span class="badge badge-warning" id="unverifiedCount">0</span>
          </button>
          <button 
            class="flex-1 flex items-center justify-center gap-2 px-4 py-2 rounded-md font-medium text-sm transition-all duration-200 tab-button"
            id="tab-verified"
          >
            <i class="bi bi-check-circle"></i>
            <span>‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß</span>
            <span class="badge badge-success" id="verifiedCount">0</span>
          </button>
        </div>
        
        <!-- Tab Content: ‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥ -->
        <div id="content-unverified">
          <!-- ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ Workflow -->
          <div class="alert alert-info mb-4">
            <i class="bi bi-info-circle-fill"></i>
            <span>
              <strong>‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô:</strong>
              <ol class="ml-4 mt-1 text-sm">
                <li>1. Scan/‡∏Å‡∏£‡∏≠‡∏Å‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î ‚Üí ‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏à‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ "‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥" ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ</li>
                <li>2. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å</li>
                <li>3. ‡∏Å‡∏î "‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å</li>
                <li>4. ‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤ "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤/‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥"</li>
              </ol>
              <div class="mt-2 text-xs text-blue-600">
                <i class="bi bi-lightbulb"></i> 
                <strong>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:</strong> ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ "‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥" ‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å ‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà backend ‡∏ï‡∏±‡πâ‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ pending ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
              </div>
            </span>
          </div>
          
          <!-- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏∏‡πà‡∏°‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å -->
          <div class="flex justify-between items-center mb-6 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
            <div class="flex gap-3">
              <button id="btnSelectAll" class="btn btn-primary btn-sm">
                <i class="bi bi-check2-all"></i> ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
              </button>
              <button id="btnDeselectAll" class="btn btn-outline btn-sm">
                <i class="bi bi-x-lg"></i> ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
              </button>
              <button id="btnManualReload" class="btn btn-warning btn-sm">
                <i class="bi bi-arrow-clockwise"></i> ‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä
              </button>
            </div>
            <div class="flex items-center gap-3">
              <span class="text-sm text-gray-600 dark:text-gray-400">
                ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß: <span class="font-bold text-primary-600" id="selectedCount">0</span> ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
              </span>
              <button id="btnSendToStock" class="btn btn-success">
                <i class="bi bi-send-fill"></i> ‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å
              </button>
            </div>
          </div>
          
          <div id="stockContainer">
            <!-- Content will be populated by JavaScript -->
          </div>
        </div>
        
        <!-- Tab Content: ‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß -->
        <div id="content-verified" class="hidden">
          <!-- Filter ‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà -->
          <div class="flex gap-4 mb-4">
            <div class="form-control">
              <label class="label">
                <span class="label-text">‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô</span>
              </label>
              <input type="date" id="dateFrom" class="input input-bordered" />
            </div>
            <div class="form-control">
              <label class="label">
                <span class="label-text">‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î</span>
              </label>
              <input type="date" id="dateTo" class="input input-bordered" />
            </div>
            <div class="form-control">
              <label class="label">
                <span class="label-text">&nbsp;</span>
              </label>
              <button class="btn btn-primary" id="btnLoadVerifiedHistory">
                <i class="bi bi-search"></i> ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤
              </button>
            </div>
          </div>
          
          <div id="verifiedContainer">
            <!-- Content will be populated by JavaScript -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <footer class="mt-4 text-center">
    <small>¬© 2025 ‡∏ö‡∏£‡∏¥‡∏©‡∏±‡∏ó 2 ‡∏û‡∏µ‡πà‡∏ô‡πâ‡∏≠‡∏á ‡πÇ‡∏°‡∏ö‡∏≤‡∏¢ ‡∏à‡∏≥‡∏Å‡∏±‡∏î. ‡∏™‡∏á‡∏ß‡∏ô‡∏•‡∏¥‡∏Ç‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå.</small>
  </footer>

  <!-- Modals -->
  <input type="checkbox" id="confirmActionModal" class="modal-toggle" />
  <div class="modal">
    <div class="modal-box">
      <h3 class="font-bold text-lg">‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥</h3>
      <p class="py-4" id="confirmActionText">‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</p>
      <div class="modal-action">
        <label for="confirmActionModal" class="btn btn-secondary" id="cancelActionBtn">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</label>
        <label for="confirmActionModal" class="btn btn-primary" id="okActionBtn">‡∏ï‡∏Å‡∏•‡∏á</label>
      </div>
    </div>
  </div>

  <!-- Hidden barcode input -->
  <input type="text" id="barcodeInput" autofocus lang="en" inputmode="latin" autocomplete="off" autocorrect="off" autocapitalize="off" style="ime-mode: disabled; display:none;" />

        <p class="text-sm font-medium" id="loadingText">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...</p>
    </div>
  </div>

  <!-- 
    Barcode Modal - Not used anymore since products are added directly to pending list
  -->

  <script type="text/javascript">
    //<![CDATA[
    // URL Parameters and Constants
    const urlParams = new URLSearchParams(window.location.search);
    let BRANCH_CODE = urlParams.get("branch") || localStorage.getItem('activeBranch');

    if (!BRANCH_CODE) {
      console.warn("Branch not found in URL or localStorage, defaulting to 'PATTANI'");
      BRANCH_CODE = 'PATTANI';
    }
    window.currentBranchCode = BRANCH_CODE;
    console.log(`[addNewProduct] Using branch code: ${BRANCH_CODE}`);
    
    // Initialize Sidebar Component
    let sidebar;
    
    // ==================== LOGGING SYSTEM ====================
    
    const Logger = {
      levels: {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3
      },
      currentLevel: 1, // Default to INFO in production
      
      log: function(level, message, data = null) {
        if (level < this.currentLevel) return;
        
        const timestamp = new Date().toISOString();
        const levelName = Object.keys(this.levels).find(key => this.levels[key] === level);
        
        const logEntry = {
          timestamp,
          level: levelName,
          message,
          data,
          url: window.location.href,
          userAgent: navigator.userAgent
        };
        
        // Console output
        if (level === this.levels.ERROR) {
          console.error(`[${levelName}] ${message}`, data);
        } else if (level === this.levels.WARN) {
          console.warn(`[${levelName}] ${message}`, data);
        } else if (window.location.hostname === 'localhost' || this.currentLevel === 0) {
          console.log(`[${levelName}] ${message}`, data);
        }
        
        // Store in localStorage for debugging
        if (level >= this.levels.WARN) {
          this.storeLog(logEntry);
        }
      },
      
      storeLog: function(logEntry) {
        try {
          const logs = JSON.parse(localStorage.getItem('appLogs') || '[]');
          logs.push(logEntry);
          // Keep only last 100 logs
          localStorage.setItem('appLogs', JSON.stringify(logs.slice(-100)));
        } catch (e) {
          // Ignore storage errors
        }
      },
      
      debug: function(message, data) {
        this.log(this.levels.DEBUG, message, data);
      },
      
      info: function(message, data) {
        this.log(this.levels.INFO, message, data);
      },
      
      warn: function(message, data) {
        this.log(this.levels.WARN, message, data);
      },
      
      error: function(message, data) {
        this.log(this.levels.ERROR, message, data);
      },
      
      setLevel: function(level) {
        this.currentLevel = this.levels[level] || this.levels.INFO;
      },
      
      getLogs: function() {
        return JSON.parse(localStorage.getItem('appLogs') || '[]');
      },
      
      clearLogs: function() {
        localStorage.removeItem('appLogs');
      }
    };
    
    // Set debug level for development - REMOVED a problematic check
    // This will default Logger level to INFO
    
    // ==================== END LOGGING SYSTEM ====================

    // Socket.IO initialization with error handling
    let socket = null;
    
    function initializeSocket() {
      // Check if Socket.IO is available
      if (typeof io === 'undefined' || !window.socketIOAvailable) {
        Logger.warn("Socket.IO library not available, continuing without real-time features");
        console.warn("‚ö†Ô∏è Socket.IO not available, app will work without real-time updates");
        return;
      }
      
      try {
        socket = io({
          timeout: 5000,
          transports: ['websocket', 'polling'],
          upgrade: true,
          reconnection: true,
          reconnectionAttempts: 3,
          reconnectionDelay: 1000,
          forceNew: true
        });
        
        socket.on('connect', () => {
          Logger.info("‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ realtime ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");
          console.log("‚úÖ Socket.IO connected successfully");
        });
        
        socket.on('connect_error', (error) => {
          Logger.warn("Socket.IO connection error:", error.message);
          console.warn("‚ö†Ô∏è Socket.IO connection failed:", error.message, "- app will continue working without real-time updates");
        });
        
        socket.on('disconnect', (reason) => {
          Logger.info("Socket.IO disconnected:", reason);
          console.log("üîå Socket.IO disconnected:", reason);
        });
        
        socket.on('stockUpdate', () => {
          Logger.debug("‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì update ‡∏™‡∏ï‡πä‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö realtime");
          loadStock();
        });
        
        socket.on('branchStockUpdated', () => {
          Logger.debug("‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì branchStock updated");
          loadStock();
        });
        
        socket.on('branchstockCreated', () => {
          Logger.debug("‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì branchStock created");
          loadStock();
        });
        
        socket.on('branchstockDeleted', () => {
          Logger.debug("‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì branchStock deleted");
          loadStock();
        });
        
      } catch (socketError) {
        Logger.error("Failed to initialize Socket.IO:", socketError);
        console.warn("‚ö†Ô∏è Socket.IO initialization failed:", socketError.message, "- continuing without real-time features");
        socket = null;
      }
    }
    
    // Initialize socket with delay to ensure DOM is ready
    setTimeout(() => {
      initializeSocket();
    }, 1000);

    // Global variables
    let scannedProducts = [];
    let allProductImages = [];
    let pendingAction = null;
    let selectedStocks = new Set();
    let defaultSupplier = null;

    // Global notification system instance
    let posNotificationSystem = null;
    
    // Enhanced variables for multi-item support
    let isContinuousMode = false;
    let isBatchScanning = false;
    let scanCounter = 0;
    let recentAdditions = [];
    let scanningTimeout = null;
    let autoRefreshInterval = null;

    // ==================== SECURITY & VALIDATION ====================
    
    // CSRF Token generation and management
    function generateCSRFToken() {
      const array = new Uint8Array(32);
      crypto.getRandomValues(array);
      const token = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
      localStorage.setItem('csrfToken', token);
      document.querySelector('meta[name="csrf-token"]').content = token;
      return token;
    }
    
    // Initialize CSRF token on page load
    if (!localStorage.getItem('csrfToken')) {
      generateCSRFToken();
    }
    
    // Input validation functions
    const ValidationRules = {
      barcode: {
        pattern: /^.+$/, // ‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏∞‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡∏ï‡∏±‡∏ß
        message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î'
      },
      imei: {
        pattern: /^[0-9A-Za-z]{10,20}$/, // ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ 10-20 ‡∏´‡∏•‡∏±‡∏Å
        message: '‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ 10-20 ‡∏´‡∏•‡∏±‡∏Å'
      }
    };

    // Validate barcode format
    function validateBarcode(barcode) {
      if (!barcode) return { valid: false, message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î' };
      
      barcode = barcode.trim();
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
      if (barcode.length < 1) {
        return { valid: false, message: '‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£' };
      }
      
      // ‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ç‡∏≠‡∏á‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î
      return { valid: true };
    }

    // Enhanced IMEI validation with flexibility
    function validateIMEI(imei) {
      if (!imei) return { valid: false, message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å IMEI' };
      
      imei = imei.trim();
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç (‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô)
      if (imei.length < 10 || imei.length > 20) {
        return { valid: false, message: '‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß 10-20 ‡∏´‡∏•‡∏±‡∏Å' };
      }
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏µ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏õ‡∏ô‡πÑ‡∏î‡πâ
      if (!/^[0-9A-Za-z]+$/.test(imei)) {
        return { valid: false, message: '‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÑ‡∏î‡πâ' };
      }
      
      // ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ Luhn algorithm check ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô
      // ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏ö‡∏≤‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÉ‡∏ä‡πâ Serial Number ‡∏´‡∏£‡∏∑‡∏≠ IMEI ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô
      
      return { valid: true };
    }

    // Sanitize HTML to prevent XSS
    function sanitizeHTML(str) {
      if (!str) return '';
      const temp = document.createElement('div');
      temp.textContent = str;
      return temp.innerHTML;
    }

    // Enhanced Rate limiting with different limits per action
    const RateLimiter = {
      attempts: {},
      limits: {
        'scan_barcode': { max: 20, window: 60000 },      // 20 per minute
        'manual_barcode': { max: 10, window: 60000 },    // 10 per minute
        'api_call': { max: 30, window: 60000 },          // 30 per minute
        'delete_action': { max: 5, window: 60000 },      // 5 per minute
        'update_action': { max: 15, window: 60000 }      // 15 per minute
      },
      
      check: function(action) {
        const now = Date.now();
        const userId = localStorage.getItem('userId') || 'anonymous';
        const key = `${action}_${userId}`;
        const limit = this.limits[action] || { max: 30, window: 60000 };
        
        if (!this.attempts[key]) {
          this.attempts[key] = { count: 0, resetTime: now + limit.window };
        }
        
        if (now > this.attempts[key].resetTime) {
          this.attempts[key] = { count: 0, resetTime: now + limit.window };
        }
        
        if (this.attempts[key].count >= limit.max) {
          const waitTime = Math.ceil((this.attempts[key].resetTime - now) / 1000);
          showToast(`‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠ ${waitTime} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ`, 'warning');
          
          // Log rate limit exceeded
          createAuditLog('RATE_LIMIT_EXCEEDED', {
            action: action,
            userId: userId,
            attempts: this.attempts[key].count,
            resetTime: new Date(this.attempts[key].resetTime).toISOString()
          });
          
          return false;
        }
        
        this.attempts[key].count++;
        return true;
      },
      
      reset: function(action) {
        const userId = localStorage.getItem('userId') || 'anonymous';
        const key = `${action}_${userId}`;
        delete this.attempts[key];
      }
    };

    // Enhanced Session timeout management
    let sessionTimeout;
    let warningTimeout;
    let lastActivity = Date.now();
    const SESSION_TIMEOUT = 15 * 60 * 1000; // 15 minutes
    const WARNING_TIME = 2 * 60 * 1000;     // Warning at 2 minutes before timeout

    function resetSessionTimeout() {
      lastActivity = Date.now();
      clearTimeout(sessionTimeout);
      clearTimeout(warningTimeout);
      
      // Set warning timeout
      warningTimeout = setTimeout(() => {
        showToast('‡πÄ‡∏ã‡∏™‡∏ä‡∏±‡∏ô‡∏à‡∏∞‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÉ‡∏ô 2 ‡∏ô‡∏≤‡∏ó‡∏µ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•', 'warning');
      }, SESSION_TIMEOUT - WARNING_TIME);
      
      // Set session timeout
      sessionTimeout = setTimeout(() => {
        showToast('‡πÄ‡∏ã‡∏™‡∏ä‡∏±‡∏ô‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö...', 'error');
        createAuditLog('SESSION_TIMEOUT', {
          lastActivity: new Date(lastActivity).toISOString(),
          sessionDuration: Date.now() - lastActivity
        });
        setTimeout(() => {
          logout();
        }, 2000);
      }, SESSION_TIMEOUT);
    }

    // Logout function
    async function logout() {
      try {
        // Create audit log before logout
        await createAuditLog('USER_LOGOUT', {
          logoutType: 'manual',
          sessionDuration: Date.now() - lastActivity
        });
        
        // Clear all sensitive data
        localStorage.removeItem('authToken');
        localStorage.removeItem('userId');
        localStorage.removeItem('csrfToken');
        localStorage.removeItem('branchCode');
        
        // Clear session storage
        sessionStorage.clear();
        
        // Disconnect socket (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
        try {
          if (socket && socket.connected) {
            socket.disconnect();
          }
        } catch (socketDisconnectError) {
          Logger.warn("Failed to disconnect socket:", socketDisconnectError);
        }
        
        // Redirect to login
        window.location.href = '/login';
      } catch (err) {
        console.error('Logout error:', err);
        // Force redirect even if audit log fails
        window.location.href = '/login';
      }
    }

    // Track user activity with debounce
    let activityDebounce;
    function trackActivity() {
      clearTimeout(activityDebounce);
      activityDebounce = setTimeout(() => {
        resetSessionTimeout();
      }, 1000);
    }

    document.addEventListener('click', trackActivity);
    document.addEventListener('keypress', trackActivity);
    document.addEventListener('mousemove', trackActivity);
    document.addEventListener('scroll', trackActivity);

    // CSRF Token management
    function getCSRFToken() {
      return localStorage.getItem('csrfToken') || generateCSRFToken();
    }

    // Enhanced fetch with CSRF token and retry logic
    async function secureFetch(url, options = {}) {
      // Rate limit check for API calls
      if (!RateLimiter.check('api_call')) {
        throw new Error('Rate limit exceeded');
      }
      
      const token = localStorage.getItem('authToken');
      const csrfToken = getCSRFToken();
      
      if (!token) {
        throw new Error('No auth token found');
      }
      
      const headers = {
        'Authorization': 'Bearer ' + token,
        'X-CSRF-Token': csrfToken,
        'X-Request-ID': generateRequestId(),
        ...options.headers
      };
      
      // Add loading state
      showLoadingState(true);
      
      try {
        const response = await fetch(url, { 
          ...options, 
          headers,
          credentials: 'same-origin'
        });
        
        // Check if token expired
        if (response.status === 401) {
          await createAuditLog('TOKEN_EXPIRED', {
            url: url,
            method: options.method || 'GET'
          });
          logout();
          throw new Error('Authentication expired');
        }
        
        // Check CSRF token mismatch
        if (response.status === 403 && response.headers.get('X-CSRF-Error')) {
          generateCSRFToken();
          throw new Error('CSRF token mismatch, please retry');
        }
        
        return response;
      } finally {
        showLoadingState(false);
      }
    }

    // Generate unique request ID for tracking
    function generateRequestId() {
      return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }

    // Show/hide loading state (disabled to prevent multiple loadings)
    function showLoadingState(show) {
      console.log('showLoadingState called but disabled:', show);
      // Don't call showLoading to prevent multiple loading displays
    }

    // Safe loading functions for backward compatibility - use separate simple loading
    function safeShowLoading(options = {}) {
      console.log('safeShowLoading called with:', options);
      return 'loading_' + Date.now(); // Return fake ID for compatibility
    }

    function safeHideLoading(id) {
      console.log('safeHideLoading called with ID:', id);
      return true;
    }

    // Enhanced button loading function for compatibility
    function enhanceButtonWithLoading(button, options = {}) {
      if (!button) return;

      console.log('enhanceButtonWithLoading called for button:', button.id || 'unnamed', 'with options:', options);

      // Store original button properties
      const originalText = button.innerHTML;
      const originalDisabled = button.disabled;

      // Add loading method to button
      button.showLoading = function(message = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£...') {
        this.disabled = true;
        this.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>${message}`;
      };

      // Add success method to button
      button.showSuccess = function(message = options.successMessage || '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à') {
        this.innerHTML = `<i class="fas fa-check mr-2"></i>${message}`;
        setTimeout(() => {
          this.innerHTML = originalText;
          this.disabled = originalDisabled;
        }, 2000);
      };

      // Add error method to button
      button.showError = function(message = options.errorMessage || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î') {
        this.innerHTML = `<i class="fas fa-times mr-2"></i>${message}`;
        this.disabled = originalDisabled;
        setTimeout(() => {
          this.innerHTML = originalText;
        }, 3000);
      };

      // Add reset method to button
      button.resetLoading = function() {
        this.innerHTML = originalText;
        this.disabled = originalDisabled;
      };

      return button;
    }

    function safeUpdateMessage(id, message, subMessage = null) {
      console.log('safeUpdateMessage called:', message, subMessage);
      return true; // Just log for compatibility
    }

    function safeUpdateProgress(id, percentage) {
      console.log('safeUpdateProgress called:', percentage + '%');
      return true; // Just log for compatibility
    }
    
    // ==================== END SECURITY & VALIDATION ====================

    // ==================== AUDIT LOG SYSTEM ====================
    
    // Enhanced audit logging function with IP and device tracking
    async function createAuditLog(action, details) {
      // TEMPORARILY DISABLE AUDIT LOGGING DUE TO BACKEND ISSUES
      console.log('Audit log disabled:', action, details);
      return;
    }

    // Determine severity level based on action type
    function getSeverityLevel(action) {
      const highSeverity = ['DELETE', 'LOGIN_FAILED', 'UNAUTHORIZED_ACCESS', 'RATE_LIMIT_EXCEEDED', 'TOKEN_EXPIRED'];
      const mediumSeverity = ['UPDATE', 'CREATE', 'APPROVE', 'REJECT', 'SEND_TO_STOCK'];
      const lowSeverity = ['VIEW', 'SEARCH', 'SCAN', 'TAB_SWITCH'];
      
      if (highSeverity.some(a => action.includes(a))) return 'HIGH';
      if (mediumSeverity.some(a => action.includes(a))) return 'MEDIUM';
      if (lowSeverity.some(a => action.includes(a))) return 'LOW';
      return 'INFO';
    }

    // Retry failed audit logs
    async function retryFailedAuditLogs() {
      const failedLogs = JSON.parse(localStorage.getItem('failedAuditLogs') || '[]');
      if (failedLogs.length === 0) return;
      
      const token = localStorage.getItem('authToken');
      if (!token) return;
      
      Logger.info(`Retrying ${failedLogs.length} failed audit logs...`);
      
      for (const log of failedLogs) {
        try {
          const response = await fetch('/api/audit/log', {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + token,
              'X-CSRF-Token': getCSRFToken()
            },
            body: JSON.stringify(log)
          });
          
          if (response.ok) {
            // Remove successful log
            const remaining = JSON.parse(localStorage.getItem('failedAuditLogs') || '[]');
            const filtered = remaining.filter(l => l.timestamp !== log.timestamp);
            localStorage.setItem('failedAuditLogs', JSON.stringify(filtered));
          }
        } catch (err) {
          console.error('Retry audit log failed:', err);
        }
      }
    }

    // Get detailed device information
    function getDeviceInfo() {
      const ua = navigator.userAgent;
      const parser = new UAParser(ua);
      const result = parser.getResult();
      
      return {
        userAgent: ua,
        browser: {
          name: result.browser.name || 'Unknown',
          version: result.browser.version || 'Unknown',
          major: result.browser.major || 'Unknown'
        },
        os: {
          name: result.os.name || 'Unknown',
          version: result.os.version || 'Unknown'
        },
        device: {
          type: result.device.type || 'desktop',
          vendor: result.device.vendor || 'Unknown',
          model: result.device.model || 'Unknown'
        },
        screen: {
          width: window.screen.width,
          height: window.screen.height,
          pixelRatio: window.devicePixelRatio || 1
        },
        viewport: {
          width: window.innerWidth,
          height: window.innerHeight
        },
        language: navigator.language || 'Unknown',
        platform: navigator.platform || 'Unknown',
        cookieEnabled: navigator.cookieEnabled,
        onLine: navigator.onLine,
        doNotTrack: navigator.doNotTrack || 'Unknown'
      };
    }

    // Get location info (requires user permission)
    async function getLocationInfo() {
      try {
        if ('geolocation' in navigator) {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              timeout: 5000,
              maximumAge: 300000 // 5 minutes cache
            });
          });
          
          return {
            location: {
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              accuracy: position.coords.accuracy
            }
          };
        }
      } catch (err) {
        // User denied location or error occurred
        Logger.debug('Location not available:', err.message);
      }
      
      return { location: null };
    }

    // Simple UA Parser (embedded to avoid external dependency)
    class UAParser {
      constructor(ua) {
        this.ua = ua.toLowerCase();
      }
      
      getResult() {
        return {
          browser: this.getBrowser(),
          os: this.getOS(),
          device: this.getDevice()
        };
      }
      
      getBrowser() {
        const browsers = [
          { name: 'Chrome', pattern: /chrome\/(\d+)\.(\d+)/ },
          { name: 'Firefox', pattern: /firefox\/(\d+)\.(\d+)/ },
          { name: 'Safari', pattern: /version\/(\d+)\.(\d+).*safari/ },
          { name: 'Edge', pattern: /edg\/(\d+)\.(\d+)/ },
          { name: 'Opera', pattern: /opr\/(\d+)\.(\d+)/ }
        ];
        
        for (const browser of browsers) {
          const match = this.ua.match(browser.pattern);
          if (match) {
            return {
              name: browser.name,
              version: `${match[1]}.${match[2]}`,
              major: match[1]
            };
          }
        }
        
        return { name: 'Unknown', version: 'Unknown', major: 'Unknown' };
      }
      
      getOS() {
        const systems = [
          { name: 'Windows 11', pattern: /windows nt 10\.0.*win64/ },
          { name: 'Windows 10', pattern: /windows nt 10\.0/ },
          { name: 'Windows 8.1', pattern: /windows nt 6\.3/ },
          { name: 'Windows 8', pattern: /windows nt 6\.2/ },
          { name: 'Windows 7', pattern: /windows nt 6\.1/ },
          { name: 'macOS', pattern: /mac os x (\d+)[._](\d+)/ },
          { name: 'iOS', pattern: /iphone.*os (\d+)[._](\d+)/ },
          { name: 'Android', pattern: /android (\d+)\.(\d+)/ },
          { name: 'Linux', pattern: /linux/ }
        ];
        
        for (const os of systems) {
          const match = this.ua.match(os.pattern);
          if (match) {
            const version = match[1] ? `${match[1]}.${match[2] || 0}` : 'Unknown';
            return { name: os.name, version };
          }
        }
        
        return { name: 'Unknown', version: 'Unknown' };
      }
      
      getDevice() {
        if (/mobile/i.test(this.ua)) {
          return { type: 'mobile' };
        } else if (/tablet|ipad/i.test(this.ua)) {
          return { type: 'tablet' };
        }
        return { type: 'desktop' };
      }
    }

    // ==================== END AUDIT LOG SYSTEM ====================

    // ==================== UTILITY FUNCTIONS ====================
    
    // Toast notification function
    function showToast(message, type = 'info') {
      // Remove existing toasts
      const existingToasts = document.querySelectorAll('.toast-notification');
      existingToasts.forEach(toast => toast.remove());
      
      const toast = document.createElement('div');
      toast.className = `toast-notification alert alert-${type === 'success' ? 'success' : type === 'error' ? 'error' : type === 'warning' ? 'warning' : 'info'} fixed top-4 right-4 z-50 max-w-sm shadow-lg animate-in`;
      
      const icon = type === 'success' ? 'bi-check-circle-fill' : type === 'error' ? 'bi-x-circle-fill' : type === 'warning' ? 'bi-exclamation-triangle-fill' : 'bi-info-circle-fill';
      
      toast.innerHTML = `
        <div class="flex items-center gap-3">
          <i class="bi ${icon} text-xl"></i>
          <span>${message}</span>
          <button onclick="this.parentElement.parentElement.remove()" class="btn btn-sm btn-ghost">
            <i class="bi bi-x"></i>
          </button>
        </div>
      `;
      
      document.body.appendChild(toast);
      
      // Auto remove after 5 seconds
      setTimeout(() => {
        toast.classList.add('animate-out');
        setTimeout(() => toast.remove(), 300);
      }, 5000);
    }

    // Get current user info with caching
    async function getCurrentUserInfo() {
      try {
        const token = localStorage.getItem('authToken');
        if (!token) return { userId: null, userName: '', role: null, branch: null };
        
        // Check if cached user info is still valid
        const cachedUser = sessionStorage.getItem('currentUser');
        if (cachedUser) {
          const userData = JSON.parse(cachedUser);
          // Cache for 5 minutes
          if (Date.now() - userData.cachedAt < 5 * 60 * 1000) {
            return userData;
          }
        }
        
        const res = await fetch('/api/users/me', {
          headers: { 'Authorization': 'Bearer ' + token }
        });
        const result = await res.json();
        
        if (!res.ok || !result.success) {
          throw new Error(result.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ');
        }
        
        if (result.data) {
          const userInfo = { 
            userId: result.data._id, 
            userName: result.data.name,
            role: result.data.role,
            branch: result.data.branch,
            permissions: result.data.allowedPages || [],
            cachedAt: Date.now()
          };
          
          // Cache user info
          sessionStorage.setItem('currentUser', JSON.stringify(userInfo));
          localStorage.setItem('userId', result.data._id);
          
          return userInfo;
        }
        
        return { userId: null, userName: '', role: null, branch: null };
      } catch (err) {
        Logger.error('Error getting user info:', err);
        return { userId: null, userName: '', role: null, branch: null };
      }
    }

    // ==================== END UTILITY FUNCTIONS ====================

    // ==================== API FUNCTIONS ====================
    
    // Load product images
    async function loadProductImages() {
      try {
        const res = await secureFetch('/api/product-image');
        const result = await res.json();
        
        if (!res.ok || result.status !== 'success') {
          throw new Error(result.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ');
        }
        
        allProductImages = result.data || [];
        Logger.debug('Product images loaded:', allProductImages.length);
      } catch (err) {
        Logger.error('Error loadProductImages:', err);
        showToast('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ: ' + err.message, 'error');
      }
    }
    
    // Load suppliers with enhanced validation
    async function loadSuppliers() {
      try {
        const res = await secureFetch('/api/supplier');
        const data = await res.json();
        console.log('üì° Suppliers API Response:', data);
        
        if (!res.ok || !data.success) {
          throw new Error(data.error || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î suppliers');
        }
        
        if (data.data && data.data.length > 0) {
          // ‡πÉ‡∏ä‡πâ supplier ‡πÅ‡∏£‡∏Å‡πÄ‡∏õ‡πá‡∏ô default ‡πÅ‡∏•‡∏∞‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏ß‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ fallback
          defaultSupplier = data.data[0];
          Logger.info('Default supplier set:', defaultSupplier.name);
          console.log('‚úÖ Default supplier loaded:', defaultSupplier);
          
          // ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ supplier ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÑ‡∏ß‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ fallback
          window.availableSuppliers = data.data;
          console.log('üìã Available suppliers:', data.data.map(s => s.name));
        } else {
          Logger.warn('No suppliers found in system');
          console.warn('‚ö†Ô∏è No suppliers found, using fallback');
          // ‡πÉ‡∏ä‡πâ fallback supplier
          defaultSupplier = {
            name: '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏',
            _id: 'default'
          };
          window.availableSuppliers = [defaultSupplier];
        }
      } catch (err) {
        Logger.error('Error loading suppliers:', err);
        console.error('‚ùå Error loading suppliers:', err);
        // ‡πÉ‡∏ä‡πâ fallback supplier
        defaultSupplier = {
          name: '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏',
          _id: 'default'
        };
        window.availableSuppliers = [defaultSupplier];
      }
    }

    // Load branch info
    async function loadBranchInfo() {
      try {
        const branchCode = BRANCH_CODE;
        const token = localStorage.getItem("authToken") || "";
        
        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å /api/branch ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á list ‡∏™‡∏≤‡∏Ç‡∏≤
        const res = await fetch(`/api/branch`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        const js = await res.json();
        if (res.ok && js.success) {
          // ‡∏´‡∏≤ record ‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö branch_code
          const branch = js.data.find(b => b.branch_code === branchCode);
          if (branch) {
            document.getElementById("branchInfo").textContent =
              `${branch.name} - ${branch.address}`;
            // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó title ‡∏Ç‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏Ç‡∏≤‡∏à‡∏£‡∏¥‡∏á
            document.title = `‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ - ${branch.name}`;
            document.getElementById("pageTitle").textContent = `‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ - ${branch.name}`;
            return;
          }
        }
        throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≤‡∏Ç‡∏≤");
      } catch (err) {
        Logger.warn("loadBranchInfo error:", err);
        document.getElementById("branchInfo").textContent =
          "‡∏™‡∏≤‡∏Ç‡∏≤: (‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•)";
      }
    }

    // Load branches
    async function loadBranches() {
      try {
        const res = await secureFetch('/api/branch', {
          headers: {
            'Content-Type': 'application/json'
          }
        });
        const data = await res.json();
        if (!res.ok || !data.success) {
          throw new Error(data.error || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏≤‡∏Ç‡∏≤');
        }
        
        // Audit log for branch access
        createAuditLog('VIEW_BRANCHES', {
          branchCount: data.data.length
        });
        
        const branchSelect = document.getElementById('branchSelect');
        branchSelect.innerHTML = '';
        
        // ‡∏≠‡πà‡∏≤‡∏ô branch code ‡∏à‡∏≤‡∏Å URL parameter
        const branchFromUrl = BRANCH_CODE;
        
        const ptnBranches = data.data.filter(b => b.branch_code === branchFromUrl);
        
        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó title ‡∏Ç‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤
        if (ptnBranches.length > 0 && urlParams.get('name')) {
          document.title = `‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ - ${decodeURIComponent(urlParams.get('name'))}`;
        }
        
        if (ptnBranches.length === 0) {
          branchSelect.innerHTML = '<option value="">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏≤‡∏Ç‡∏≤</option>';
          showToast('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏≤‡∏Ç‡∏≤ ' + branchFromUrl, 'error');
          
          // Audit log for branch not found
          createAuditLog('BRANCH_NOT_FOUND', {
            requestedBranch: branchFromUrl
          });
          return;
        }
        
        ptnBranches.forEach(b => {
          const opt = document.createElement('option');
          opt.value = b.branch_code;
          opt.textContent = `[${b.branch_code}] ${b.name}`;
          branchSelect.appendChild(opt);
        });
        
        // Set value to BRANCH_CODE
        branchSelect.value = BRANCH_CODE;
        console.log('‚úÖ Branch select value set to:', BRANCH_CODE);
        
        branchSelect.disabled = true;
        loadStock();
      } catch (err) {
        showToast('Error loading branches: ' + err.message, 'error');
        
        // Audit log for error
        createAuditLog('ERROR_LOADING_BRANCHES', {
          error: err.message
        });
      }
    }

    // Load stock data with enhanced auto-refresh
    async function loadStock() {
      const branchSelect = document.getElementById('branchSelect');
      console.log('üîç Branch select element:', branchSelect);
      console.log('üîç Branch select value:', branchSelect?.value);
      console.log('üîç Branch select disabled:', branchSelect?.disabled);
      
      const branchId = branchSelect?.value || BRANCH_CODE;
      if (!branchId) {
        Logger.warn('No branch selected, cannot load stock');
        return;
      }
      
      Logger.info('Loading stock for branch:', branchId);
      console.log('üîç Loading stock for branch:', branchId);

      // Start auto-refresh if not in batch scanning mode
      if (!isBatchScanning && !autoRefreshInterval) {
        autoRefreshInterval = setInterval(() => {
          if (!isBatchScanning) {
            refreshStockTable();
          }
        }, 15000); // Refresh every 15 seconds
      }

      try {
        // Audit log for stock loading
        createAuditLog('VIEW_STOCK', {
          branch: branchId,
          action: 'load_stock_list'
        });
        
        // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡πÑ‡∏°‡πà filter ‡∏≠‡∏∞‡πÑ‡∏£‡πÄ‡∏•‡∏¢
        const url = `/api/branch-stock?branch_code=${branchId}&include_unverified=1&include_all=1&_=${new Date().getTime()}`;
        Logger.info('Loading stock from:', url);
        console.log('üì° API URL (include all):', url);
        console.log('üìç Branch ID being used:', branchId);
        
        const res = await secureFetch(url);
        const result = await res.json();
        
        Logger.info('API Response:', {
          success: result.success,
          dataLength: result.data ? result.data.length : 0
        });
        
        console.log('üì¶ API Response:', {
          success: result.success,
          dataLength: result.data ? result.data.length : 0
        });
        
        // ‡πÅ‡∏™‡∏î‡∏á raw response data
        console.log('üìã Raw API Response Data:', result);
        
        if (!res.ok || !result.success) {
          Logger.error('Load stock error:', result);
          console.error('‚ùå Load stock error:', result);
          showToast('‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏ï‡πä‡∏≠‡∏Å‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ' + (result.error || 'Unknown error'), 'error');
          
          // Audit log for error
          createAuditLog('ERROR_LOADING_STOCK', {
            branch: branchId,
            error: result.error || 'Unknown error'
          });
          return;
        }

        const rawStocks = result.data || [];
        Logger.info('Total stocks loaded:', rawStocks.length);
        console.log('üìä Total stocks:', rawStocks.length);
        
        // Debug: ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å API
        console.log('üîç ALL Stocks from API:', rawStocks);
        
        // Debug: ‡πÅ‡∏™‡∏î‡∏á iPhone stocks ‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞
        const iPhoneStocks = rawStocks.filter(s => s.name && s.name.toLowerCase().includes('iphone'));
        console.log('üì± iPhone stocks found:', iPhoneStocks.length);
        if (iPhoneStocks.length > 0) {
          console.log('üì± iPhone stock details:');
          iPhoneStocks.forEach((stock, i) => {
            console.log(`  ${i+1}. ${stock.name}`);
            console.log(`     - Barcode: ${stock.barcode}`);
            console.log(`     - IMEI: ${stock.imei}`);
            console.log(`     - Branch: ${stock.branch_code}`);
            console.log(`     - Verified: ${stock.verified}`);
            console.log(`     - Sent to stock: ${stock.sent_to_stock}`);
            console.log(`     - Created: ${stock.created_at}`);
          });
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö stock ‡∏ó‡∏µ‡πà‡∏°‡∏µ pending = false
        const falseStocks = rawStocks.filter(s => s.pending === false);
        console.log('üìå Stocks with pending=false:', falseStocks.length, falseStocks);
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö stock ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ pending field
        const noPendingStocks = rawStocks.filter(s => s.pending === undefined);
        console.log('üìå Stocks with no pending field:', noPendingStocks.length, noPendingStocks);
        
        // Debug: ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡∏¥‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
        if (rawStocks.length > 0) {
          Logger.debug('Sample stock data:', rawStocks[0]);
          console.log('üìã First stock item:', rawStocks[0]);
          
          // ‡πÅ‡∏™‡∏î‡∏á 5 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÅ‡∏£‡∏Å
          console.log('üìã First 5 stocks:');
          rawStocks.slice(0, 5).forEach((stock, i) => {
            console.log(`${i+1}. ${stock.name} - Status: pending=${stock.pending}, verified=${stock.verified}, sent_to_stock=${stock.sent_to_stock}, branch=${stock.branch_code}`);
          });
        }

        // Debug ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° - ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ï‡πä‡∏≠‡∏Å‡∏ó‡∏µ‡πà branch_code ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
        const currentBranch = document.getElementById('branchSelect').value;
        console.log('üè¢ Current branch:', currentBranch);
        const branchStocks = rawStocks.filter(s => s.branch_code === currentBranch);
        console.log(`üìä Stocks for branch ${currentBranch}:`, branchStocks.length);
        
        if (branchStocks.length > 0) {
          console.log('üìã Branch stocks sample:', branchStocks.slice(0, 3));
        }

        // --- NEW FILTERING LOGIC ---
        // "‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥" tab contains all items that are NOT yet verified.
        // "‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß" tab contains all items that ARE verified.
        const unverifiedStocks = rawStocks.filter(s => s.verified !== true);
        const verifiedStocks = rawStocks.filter(s => s.verified === true);

        Logger.info('Stock counts - Unverified:', unverifiedStocks.length, 'Verified:', verifiedStocks.length);
        console.log('üìä Stock breakdown:');
        console.log('  - Unverified (‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥):', unverifiedStocks.length);
        console.log('  - Verified (‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß):', verifiedStocks.length);
        
        // Debug: ‡πÅ‡∏™‡∏î‡∏á unverified stocks
        if (unverifiedStocks.length > 0) {
          console.log('üîç Unverified stocks details:');
          unverifiedStocks.forEach((stock, i) => {
            console.log(`  ${i+1}. ${stock.name} - ${stock.barcode} - ${stock.imei}`);
          });
        }
        
        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó counts
        document.getElementById('unverifiedCount').textContent = unverifiedStocks.length;
        document.getElementById('verifiedCount').textContent = verifiedStocks.length;
        document.getElementById('stockCount').textContent = rawStocks.length;

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö container ‡∏Å‡πà‡∏≠‡∏ô render
        const stockContainer = document.getElementById('stockContainer');
        const verifiedContainer = document.getElementById('verifiedContainer');
        
        console.log('üéØ Containers found:', {
          stockContainer: !!stockContainer,
          verifiedContainer: !!verifiedContainer
        });

        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏° tab ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
        const activeTab = document.querySelector('.tab-active');
        console.log('üè∑Ô∏è Active tab:', activeTab ? activeTab.id : 'none');
        
        if (activeTab && activeTab.id === 'tab-unverified') {
          console.log('üìù Rendering unverified tab with', unverifiedStocks.length, 'items...');
          renderUnverifiedStocks(unverifiedStocks);
        } else if (activeTab && activeTab.id === 'tab-verified') {
          console.log('üìù Rendering verified tab...');
          // ‡πÅ‡∏™‡∏î‡∏á verified stocks ‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏•‡∏î‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß
          renderVerifiedHistory(verifiedStocks);
        }
      } catch (err) {
        Logger.error('Error loading stock:', err);
        console.error('‚ùå Error loading stock:', err);
        showToast('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ' + err.message, 'error');
        
        // Audit log for error
        createAuditLog('ERROR_LOADING_STOCK', {
          branch: branchId,
          error: err.message
        });
      }
    }

    // Get stock info by ID
    async function getStockInfo(stockId) {
      try {
        const res = await secureFetch(`/api/branch-stock/${stockId}`);
        const data = await res.json();
        return data.success ? data.data : null;
      } catch (err) {
        Logger.error('Error getting stock info:', err);
        return null;
      }
    }

    // ==================== END API FUNCTIONS ====================

    // ==================== RENDERING FUNCTIONS ====================
    
    // Sanitize HTML to prevent XSS
    function sanitizeHTML(str) {
      if (!str) return '';
      const temp = document.createElement('div');
      temp.textContent = str;
      return temp.innerHTML;
    }
    
    // Group stock by brand
    function groupStockByBrand(stocks) {
      const map = {};
      stocks.forEach(stock => {
        const brand = stock.brand || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡πÅ‡∏ö‡∏£‡∏ô‡∏î‡πå';
        if (!map[brand]) map[brand] = [];
        map[brand].push(stock);
      });
      return map;
    }

    // Render unverified stocks (‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥)
    function renderUnverifiedStocks(unverifiedArray) {
      Logger.info('Rendering unverified stocks:', unverifiedArray.length);
      console.log('üé® Starting renderUnverifiedStocks with', unverifiedArray.length, 'items');
      
      try {
        const container = document.getElementById("stockContainer");
        if (!container) {
          Logger.error('stockContainer element not found!');
          console.error('‚ùå stockContainer element not found!');
          return;
        }
        
        console.log('üì¶ Container found:', container);
        container.innerHTML = '';
        
        if (unverifiedArray.length === 0) {
          container.innerHTML = `
            <div class="text-center py-8 text-gray-500">
              <i class="bi bi-inbox text-4xl mb-2 block"></i>
              ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥
            </div>`;
          return;
        }
        
        const grouped = groupStockByBrand(unverifiedArray);
        console.log('üè∑Ô∏è Grouped by brand:', Object.keys(grouped));
        
        Object.keys(grouped).forEach(brand => {
          console.log(`üè≠ Rendering brand: ${brand}`);
          const items = grouped[brand];
          const brandSection = document.createElement("div");
          brandSection.className = "mb-6 p-4 bg-white dark:bg-gray-800 rounded-lg shadow";
          
          const hdr = document.createElement("h5");
          hdr.className = "section-title mb-3 flex items-center justify-between text-lg font-semibold";
          
          // Calculate latest addition time for this brand
          const latestItem = items.reduce((latest, item) => {
            const itemTime = new Date(item.created_at);
            return itemTime > new Date(latest.created_at) ? item : latest;
          }, items[0]);
          
          const timeAgo = getTimeAgo(new Date(latestItem.created_at));
          
          hdr.innerHTML = `
            <div class="flex items-center gap-2">
              <i class="bi bi-box-seam-fill text-blue-500"></i> 
              ${brand} (${items.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)
            </div>
            <div class="text-sm font-normal text-gray-500">
              <i class="bi bi-clock"></i> ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: ${timeAgo}
            </div>
          `;
          brandSection.appendChild(hdr);
          
          const tblWrap = document.createElement("div");
          tblWrap.className = "overflow-x-auto";
          tblWrap.innerHTML = `
            <table class="table table-zebra w-full">
              <thead class="bg-gray-100 dark:bg-gray-700">
                <tr>
                  <th class="p-3 text-center w-16">
                    <input type="checkbox" class="checkbox checkbox-sm brand-checkbox" data-brand="${brand}">
                  </th>
                  <th class="p-3 text-center">‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î</th>
                  <th class="p-3">‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤</th>
                  <th class="p-3 text-center">IMEI</th>
                  <th class="p-3 text-center">‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞</th>
                  <th class="p-3 text-center">Actions</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>`;
          brandSection.appendChild(tblWrap);
          
          const tbody = tblWrap.querySelector("tbody");
          items.forEach((stock, index) => {
            console.log(`  üìù Rendering item ${index + 1}:`, stock.name);
            try {
              let imeiDisplay = '';
              const stockType = stock.stockType || stock.product_id?.stockType || 'imei';
              
              if (stockType === 'quantity') {
                imeiDisplay = '<span class="badge badge-info">‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ IMEI</span>';
              } else if (stock.imei && stock.imei.trim() !== '') {
                imeiDisplay = `<span class="text-green-600 dark:text-green-400">${stock.imei || ''}</span>`;
              } else {
                imeiDisplay = '<span class="text-orange-600 dark:text-orange-400">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏Å‡∏£‡∏≠‡∏Å</span>';
              }
              
              let statusBadge = '';
              let isCheckboxDisabled = false;
              if (stock.sent_to_stock === true) {
                statusBadge = '<span class="badge badge-warning"><i class="bi bi-clock-history mr-1"></i>‡∏£‡∏≠‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥</span>';
                isCheckboxDisabled = true;
              } else {
                statusBadge = '<span class="badge badge-info"><i class="bi bi-send mr-1"></i>‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡πà‡∏á</span>';
                isCheckboxDisabled = false;
              }
              
              const tr = document.createElement("tr");
              tr.innerHTML = `
                <td class="p-3 text-center">
                  <input type="checkbox" class="checkbox checkbox-sm stock-checkbox" 
                         data-stock-id="${stock._id}" 
                         data-brand="${brand}" ${isCheckboxDisabled ? 'disabled' : ''}>
                </td>
                <td class="p-3 text-center">${stock.barcode || "-"}</td>
                <td class="p-3">${stock.name || "-"}</td>
                <td class="p-3 text-center">${imeiDisplay}</td>
                <td class="p-3 text-center">${statusBadge}</td>
                <td class="p-3 text-center">
                  <button class="btn btn-sm btn-error remove-stock-button" data-stock-id="${stock._id}">
                    <i class="bi bi-trash"></i> ‡∏•‡∏ö
                  </button>
                </td>`;
              tbody.appendChild(tr);
            } catch (itemErr) {
              console.error(`‚ùå Error rendering item ${index}:`, itemErr, stock);
            }
          });
          
          container.appendChild(brandSection);
          console.log(`‚úÖ Brand ${brand} rendered successfully`);
        });
        
        setupCheckboxListeners();
        selectedStocks.clear();
        updateSelectedCount();
        console.log('‚úÖ renderUnverifiedStocks completed successfully');
        
      } catch (err) {
        console.error('‚ùå Error in renderUnverifiedStocks:', err);
        console.error('Stack trace:', err.stack);
        showToast('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ' + err.message, 'error');
      }
    }

    // Render verified history
    function renderVerifiedHistory(stocks) {
      const container = document.getElementById('verifiedContainer');
      container.innerHTML = '';
      
      if (stocks.length === 0) {
        container.innerHTML = '<div class="text-center text-gray-500 py-8">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥</div>';
        return;
      }
      
      const grouped = groupStockByBrand(stocks);
      
      Object.keys(grouped).forEach(brand => {
        const items = grouped[brand];
        const brandSection = document.createElement("div");
        brandSection.className = "mb-6 p-4 bg-white dark:bg-gray-800 rounded-lg shadow";
        
        const hdr = document.createElement("h5");
        hdr.className = "section-title mb-3 flex items-center gap-2 text-lg font-semibold";
        hdr.innerHTML = `<i class="bi bi-box-seam-fill text-blue-500"></i> ${brand} (${items.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)`;
        brandSection.appendChild(hdr);
        
        const tblWrap = document.createElement("div");
        tblWrap.className = "overflow-x-auto";
        tblWrap.innerHTML = `
          <table class="table table-zebra w-full">
            <thead class="bg-gray-100 dark:bg-gray-700">
              <tr>
                <th class="p-3 text-center w-16">
                  <input type="checkbox" class="checkbox checkbox-sm brand-checkbox" data-brand="${brand}">
                </th>
                <th class="p-3 text-center">‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î</th>
                <th class="p-3">‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤</th>
                <th class="p-3 text-center">IMEI</th>
                <th class="p-3 text-center">‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞</th>
                <th class="p-3 text-center">Actions</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>`;
        brandSection.appendChild(tblWrap);
        
        const tbody = tblWrap.querySelector("tbody");
        items.forEach(stock => {
          let imeiDisplay = '';
          const stockType = stock.stockType || stock.product_id?.stockType || 'imei';
          
          if (stockType === 'quantity') {
            imeiDisplay = '<span class="badge badge-info">‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ IMEI</span>';
          } else if (stock.imei && stock.imei.trim() !== '') {
            imeiDisplay = `<span class="text-green-600 dark:text-green-400">${sanitizeHTML(stock.imei)}</span>`;
          } else {
            imeiDisplay = '<span class="text-orange-600 dark:text-orange-400">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏Å‡∏£‡∏≠‡∏Å</span>';
          }
          
          let statusBadge = '';
          let isCheckboxDisabled = false;
          if (stock.sent_to_stock === true) {
            statusBadge = '<span class="badge badge-warning"><i class="bi bi-clock-history mr-1"></i>‡∏£‡∏≠‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥</span>';
            isCheckboxDisabled = true;
          } else {
            statusBadge = '<span class="badge badge-info"><i class="bi bi-send mr-1"></i>‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡πà‡∏á</span>';
            isCheckboxDisabled = false;
          }
          
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td class="p-3 text-center">
              <input type="checkbox" class="checkbox checkbox-sm stock-checkbox" 
                     data-stock-id="${stock._id}" 
                     data-brand="${brand}" ${isCheckboxDisabled ? 'disabled' : ''}>
            </td>
            <td class="p-3 text-center">${sanitizeHTML(stock.barcode||"-")}</td>
            <td class="p-3">${sanitizeHTML(stock.name||"-")}</td>
            <td class="p-3 text-center">${imeiDisplay}</td>
            <td class="p-3 text-center">${statusBadge}</td>
            <td class="p-3 text-center">
              <button class="btn btn-sm btn-error remove-stock-button" data-stock-id="${stock._id}">
                <i class="bi bi-trash"></i> ‡∏•‡∏ö
              </button>
            </td>`;
          tbody.appendChild(tr);
        });
        
        container.appendChild(brandSection);
      });
      
      setupCheckboxListeners();
      selectedStocks.clear();
      updateSelectedCount();
    }

    // ==================== END RENDERING FUNCTIONS ====================

    // Load verified history
    async function loadVerifiedHistory() {
      try {
        Logger.info('Loading verified history...');
        
        const branchId = document.getElementById('branchSelect')?.value || BRANCH_CODE;
        if (!branchId || branchId === 'all') {
          Logger.warn('No specific branch selected for verified history');
          const container = document.getElementById('verifiedContainer');
          if (container) {
            container.innerHTML = '<div class="text-center text-gray-500 py-8">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏≤‡∏Ç‡∏≤</div>';
          }
          return;
        }
        
        // Get date range
        const dateFrom = document.getElementById('dateFrom')?.value;
        const dateTo = document.getElementById('dateTo')?.value;
        
        if (!dateFrom || !dateTo) {
          showToast('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà', 'warning');
          return;
        }
        
        // Build URL with date filters
        let url = `/api/branch-stock?branch_code=${branchId}&verified=true`;
        
        // Add date filters
        if (dateFrom) {
          url += `&date_from=${dateFrom}`;
        }
        if (dateTo) {
          // Add 1 day to include the entire end date
          const endDate = new Date(dateTo);
          endDate.setDate(endDate.getDate() + 1);
          url += `&date_to=${endDate.toISOString().split('T')[0]}`;
        }
        
        Logger.info('Loading verified stocks from:', url);
        
        const res = await secureFetch(url);
        const result = await res.json();
        
        if (!res.ok || !result.success) {
          throw new Error(result.error || '‡πÇ‡∏´‡∏•‡∏î‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        }
        
        const verifiedStocks = result.data || [];
        Logger.info('Verified stocks loaded:', verifiedStocks.length);
        
        // Filter only verified stocks
        const filteredVerifiedStocks = verifiedStocks.filter(s => s.verified === true);
        
        // Use existing renderVerifiedHistory function
        renderVerifiedHistory(filteredVerifiedStocks);
        
        // Update count
        document.getElementById('verifiedCount').textContent = filteredVerifiedStocks.length;
        
        // Audit log
        createAuditLog('VIEW_VERIFIED_HISTORY', {
          branch: branchId,
          dateFrom: dateFrom,
          dateTo: dateTo,
          recordCount: filteredVerifiedStocks.length
        });
        
      } catch (err) {
        Logger.error('Error loading verified history:', err);
        showToast('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥: ' + err.message, 'error');
        const container = document.getElementById('verifiedContainer');
        if (container) {
          container.innerHTML = '<div class="text-center text-gray-500 py-8">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</div>';
        }
        
        // Audit log for error
        createAuditLog('ERROR_LOADING_VERIFIED_HISTORY', {
          error: err.message
        });
      }
    }

    // ==================== STOCK MANAGEMENT FUNCTIONS ====================
    
    // Approve pending stock
    async function approvePending(stockId) {
      try {
        // Rate limit check
        if (!RateLimiter.check('update_action')) return;
        
        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
        const userInfo = await getCurrentUserInfo();
        const userId = userInfo.userId;
        const userName = userInfo.userName;

        // Get stock info for audit
        const stockInfo = await getStockInfo(stockId);

        const res = await secureFetch(`/api/branch-stock/${stockId}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            pending: false,
            verified: true,
            verified_by: userId,
            verified_by_name: userName,
            verified_at: new Date().toISOString()
          })
        });
        const data = await res.json();
        if (!res.ok || !data.success) {
          throw new Error(data.error || '‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        }
        
        // Audit log for approval
        createAuditLog('APPROVE_STOCK', {
          resourceId: stockId,
          resourceName: stockInfo?.name || 'Unknown',

          imei: stockInfo?.imei,
          branch: document.getElementById('branchSelect').value,
          approvedBy: userName
        });
        
        showToast('‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢', 'success');
        loadStock();
      } catch (err) {
        showToast('Error approving: ' + err.message, 'error');
        
        // Audit log for error
        createAuditLog('ERROR_APPROVE_STOCK', {
          resourceId: stockId,
          error: err.message
        });
      }
    }

    // Reject pending stock
    async function rejectPending(stockId) {
      customConfirm('‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏è‡∏¥‡πÄ‡∏™‡∏ò‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ?', async () => {
        try {
          // Rate limit check
          if (!RateLimiter.check('delete_action')) return;
          
          // Get stock info for audit
          const stockInfo = await getStockInfo(stockId);
          
          const res = await secureFetch(`/api/branch-stock/${stockId}`, {
            method: 'DELETE'
          });
          const data = await res.json();
          if (!res.ok || !data.success) {
            throw new Error(data.error || '‡∏õ‡∏è‡∏¥‡πÄ‡∏™‡∏ò‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
          }
          
          // Audit log for rejection
          createAuditLog('REJECT_STOCK', {
            resourceId: stockId,
            resourceName: stockInfo?.name || 'Unknown',
  
            imei: stockInfo?.imei,
            branch: document.getElementById('branchSelect').value,
            reason: 'Rejected from pending list'
          });
          
          showToast('‡∏õ‡∏è‡∏¥‡πÄ‡∏™‡∏ò‡πÅ‡∏•‡∏∞‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢', 'success');
          loadStock();
        } catch (err) {
          showToast('Error rejecting: ' + err.message, 'error');
          
          // Audit log for error
          createAuditLog('ERROR_REJECT_STOCK', {
            resourceId: stockId,
            error: err.message
          });
        }
      });
    }

    // Remove stock
    async function removeStock(stockId, showAlert = true) {
      try {
        // Get stock info for audit log
        const stockInfo = await getStockInfo(stockId);
        
        const res = await secureFetch(`/api/branch-stock/${stockId}`, {
          method: 'DELETE'
        });
        
        const data = await res.json();
        if (!res.ok || !data.success) {
          throw new Error(data.error || '‡∏•‡∏ö‡∏™‡∏ï‡πä‡∏≠‡∏Å‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        }
        
        // Audit log
        createAuditLog('DELETE_STOCK', {
          resourceId: stockId,
          resourceName: stockInfo?.name || 'Unknown',

          imei: stockInfo?.imei,
          branch: document.getElementById('branchSelect').value,
          reason: 'Manual deletion'
        });
        
        if (showAlert) showToast('‡∏•‡∏ö‡∏™‡∏ï‡πä‡∏≠‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢', 'success');

        // POS Notification - Item removed
        if (posNotificationSystem && showAlert) {
          posNotificationSystem.showToast('pos', {
            title: '‡∏•‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÅ‡∏•‡πâ‡∏ß',
            message: `‡∏•‡∏ö ${stockInfo?.name || '‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤'} ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß`,
            type: 'warning',
            icon: 'üóëÔ∏è'
          });
          
          posNotificationSystem.addNotification('pos', {
            title: '‡∏•‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö',
            message: `${stockInfo?.name || '‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏ä‡∏∑‡πà‡∏≠'} (${stockInfo?.barcode || ''})`,
            type: 'warning',
            icon: 'üóÇÔ∏è',
            metadata: {
              productName: stockInfo?.name,
    
              barcode: stockInfo?.barcode,
              reason: 'Manual deletion',
              timestamp: new Date().toLocaleString('th-TH')
            }
          });
        }

        loadStock();
      } catch (err) {
        if (showAlert) showToast('Error removing stock: ' + err.message, 'error');
        else throw err;
      }
    }

    // ==================== END STOCK MANAGEMENT FUNCTIONS ====================

    // ==================== EVENT HANDLERS ====================
    
    // Enhanced barcode scan handler with multi-item support
    async function handleBarcodeScan(barcode, options = {}) {
      Logger.debug('Scanned barcode:', barcode);
      
      if (!barcode || barcode.trim() === '') {
        showToast('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î', 'warning');
        return false;
      }
      
      if (!RateLimiter.check('scan_barcode')) return false;
      const validation = validateBarcode(barcode);
      if (!validation.valid) {
        showToast(validation.message, 'error');
        return false;
      }
      
      barcode = barcode.trim();
      
      // ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
      if (!isBatchScanning) showLoadingState(true);
      
      try {
        const res = await secureFetch(`/api/product/find-by-barcode?code=${barcode}`);
        const result = await res.json();
        
        if (!res.ok || !result.success) {
          showToast('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î‡∏ô‡∏µ‡πâ', 'error');
          return false;
        }
        
        const product = result.data;
        const stockType = product.stockType || 'imei';
        let imeiValue = '';
        let barcodeValue = barcode;

        console.log(`üîç Product stockType: ${stockType}`);

        // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤
        if (stockType === 'imei') {
            // ‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó IMEI - ‡πÉ‡∏ä‡πâ barcode ‡πÄ‡∏õ‡πá‡∏ô IMEI
            const imeiValidation = validateIMEI(barcode);
            if (!imeiValidation.valid) {
                showToast(`‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç IMEI (${barcode}) ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: ${imeiValidation.message}`, 'error');
                return { success: false, error: 'invalid_imei', message: imeiValidation.message };
            }
            imeiValue = barcode;
            barcodeValue = barcode;
            console.log(`‚úÖ ‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç IMEI: ${barcode} ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ${product.name}`);
        } else if (stockType === 'quantity') {
            // ‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó quantity - ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ IMEI
            imeiValue = ''; // ‡πÑ‡∏°‡πà‡∏°‡∏µ IMEI
            barcodeValue = barcode;
            console.log(`‚úÖ ‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î: ${barcode} ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏à‡∏≥‡∏ô‡∏ß‡∏ô ${product.name}`);
        } else {
            // Default fallback
            console.log(`‚ö†Ô∏è ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô (${stockType}), ‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô quantity`);
            imeiValue = '';
            barcodeValue = barcode;
        }
        
        const branchCode = document.getElementById('branchSelect')?.value || BRANCH_CODE;
        console.log(`üîç Checking for duplicate products with values:`, { barcodeValue, imeiValue, stockType, branchCode });
        
        const duplicateCheck = await validateDuplicateProducts(barcodeValue, imeiValue, stockType, branchCode);
        console.log(`üîç Duplicate check result:`, duplicateCheck);
        
        if (duplicateCheck.isDuplicate) {
          console.warn('‚ùå Duplicate product found:', duplicateCheck);
          
          if (!isBatchScanning) {
            showDuplicateAlert(duplicateCheck);
          } else {
            addToRecentList(barcode, product.name, 'duplicate', '‡∏û‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ã‡πâ‡∏≥');
          }

          // POS Notification - Duplicate detected
          if (posNotificationSystem) {
            if (!isBatchScanning) {
              posNotificationSystem.showToast('pos', {
                title: '‡∏û‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ã‡πâ‡∏≥',
                message: `${product.name} ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß`,
                type: 'warning',
                icon: '‚ö†Ô∏è',
                duration: 5000
              });
            }
            
            posNotificationSystem.addNotification('pos', {
              title: '‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ã‡πâ‡∏≥',
              message: `${product.name} (${barcode}) ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß`,
              type: 'warning',
              icon: 'üîç',
              metadata: {
                productName: product.name,
                barcode: barcode,
                source: duplicateCheck.source,
                timestamp: new Date().toLocaleString('th-TH')
              }
            });
          }

          return { success: false, error: 'duplicate_product', details: duplicateCheck };
        }
        
        const userInfo = await getCurrentUserInfo();
        console.log('üîç User info:', userInfo);
        
        // ‡πÉ‡∏ä‡πâ supplier name ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö - ‡∏•‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡πÅ‡∏ö‡∏ö trim ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà trim
        let supplierName = '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏';
        if (defaultSupplier && defaultSupplier.name) {
          supplierName = defaultSupplier.name; // ‡πÉ‡∏ä‡πâ original name ‡∏ï‡∏£‡∏á‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏ô database
        }
        console.log('üîç Default supplier object:', defaultSupplier);
        console.log('üîç Supplier name to use:', `"${supplierName}"`);
        
        // ‡πÉ‡∏ä‡πâ supplier ‡∏à‡∏£‡∏¥‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞ force fallback
        console.log('üîç Using actual supplier from system:', supplierName);
        
        const stockData = {
          branch_code: branchCode,
          barcode: barcodeValue,

          imei: imeiValue,
          name: product.name,
          price: product.price || 0,
          brand: product.brand || '',
          model: product.model || '',
          category: product.category || '',
          stockType: stockType,
          supplier: supplierName,
          scanned_by: userInfo.userId,
          scanned_by_name: userInfo.userName,
          updated_by: userInfo.userId,
          stock_value: 0,
          created_at: new Date().toISOString(),
          // üî• ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏à‡∏≤‡∏Å Product/PO
          poNumber: product.poNumber || '',
          cost: product.cost || 0,
          taxType: product.taxType || '',
          taxRate: product.taxRate || 0,
          documentNumber: product.documentNumber || '',
          categoryGroup: product.categoryGroup || null,
          invoiceNumber: product.invoiceNumber || ''
        };
        
        console.log('üì§ Sending stock data to API:', stockData);
        console.log('üì§ Supplier field specifically:', stockData.supplier);

        const createRes = await secureFetch('/api/branch-stock', {
            method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(stockData)
        });
        
        const createResult = await createRes.json();
        console.log('üì• API Response:', { status: createRes.status, result: createResult });
        console.log('üì• Full API Response body:', createResult);
        
        if (!createRes.ok || !createResult.success) {
          console.error('‚ùå API Error:', createResult);
          
          if (createResult.error && createResult.error.toLowerCase().includes('duplicate')) {
            if (!isBatchScanning) {
              showToast('‡∏û‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ã‡πâ‡∏≥‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö! ' + createResult.error, 'error');
            } else {
              addToRecentList(barcode, product.name, 'duplicate', '‡∏û‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ã‡πâ‡∏≥');
            }
            return { success: false, error: 'duplicate_api', details: createResult };
                    } else if (createResult.error && (createResult.error.includes('‡πÑ‡∏°‡πà‡∏û‡∏ö Supplier') || createResult.error.includes('Supplier'))) {
            // ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á supplier - ‡∏•‡∏≠‡∏á‡∏™‡πà‡∏á‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏°‡∏µ supplier ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ default
            console.warn('‚ö†Ô∏è Supplier issue detected, retrying with fallback supplier...');
            console.warn('‚ö†Ô∏è Original error:', createResult.error);
            
            // ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ supplier ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö - ‡∏•‡∏≠‡∏á‡∏´‡∏•‡∏≤‡∏¢‡πÅ‡∏ö‡∏ö
            const fallbackStrategies = [];
            
            // ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ supplier ‡∏à‡∏£‡∏¥‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö (‡πÑ‡∏°‡πà trim)
            if (defaultSupplier && defaultSupplier.name) {
              fallbackStrategies.push({ ...stockData, supplier: defaultSupplier.name });
            }
            
            // ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ supplier ‡∏à‡∏£‡∏¥‡∏á‡πÅ‡∏ï‡πà trim ‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á
            if (defaultSupplier && defaultSupplier.name) {
              fallbackStrategies.push({ ...stockData, supplier: defaultSupplier.name.trim() });
            }
            
            // ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ supplier ‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            if (window.availableSuppliers) {
              for (const supplier of window.availableSuppliers) {
                if (supplier.name && supplier.name !== defaultSupplier?.name) {
                  // ‡∏•‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡πÅ‡∏ö‡∏ö original ‡πÅ‡∏•‡∏∞ trim
                  fallbackStrategies.push({ ...stockData, supplier: supplier.name });
                  fallbackStrategies.push({ ...stockData, supplier: supplier.name.trim() });
                }
              }
            }
            
            // ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
            fallbackStrategies.push(
              { ...stockData, supplier: '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏' },
              { ...stockData, supplier: 'Default' },
              { ...stockData, supplier: 'System' },
              { ...stockData, supplier: 'General' },
              // ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô supplier (‡∏ö‡∏≤‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ô‡∏µ‡πâ)
              { ...stockData, supplier: product.brand || 'Unknown' },
              // ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ null ‡∏´‡∏£‡∏∑‡∏≠ undefined (‡∏ö‡∏≤‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏≤‡∏à‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ)
              { ...stockData, supplier: null },
              { ...stockData, supplier: '' }
            );
            
            for (let i = 0; i < fallbackStrategies.length; i++) {
              const fallbackStockData = fallbackStrategies[i];
              console.log(`üîÑ Retry attempt ${i + 1} with supplier strategy:`, fallbackStockData.supplier);
              
              try {
                const retryRes = await secureFetch('/api/branch-stock', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(fallbackStockData)
                });
                
                const retryResult = await retryRes.json();
                console.log(`üì• Retry ${i + 1} API Response:`, { status: retryRes.status, result: retryResult });
                
                if (retryRes.ok && retryResult.success) {
                  console.log(`‚úÖ Retry ${i + 1} successful!`);
                  // Continue to success section
                  break;
                } else {
                  console.warn(`‚ùå Retry ${i + 1} failed:`, retryResult.error);
                  if (i === fallbackStrategies.length - 1) {
                    // Last attempt failed
                    throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡πÅ‡∏°‡πâ‡πÉ‡∏ä‡πâ fallback strategies ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î');
                  }
                }
                
              } catch (retryError) {
                console.error(`‚ùå Retry ${i + 1} attempt failed:`, retryError);
                if (i === fallbackStrategies.length - 1) {
                  throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÑ‡∏î‡πâ: ' + retryError.message);
                }
              }
            }
            
          } else {
            const errorMessage = createResult.error || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÑ‡∏î‡πâ';
            console.error('‚ùå Stock creation failed:', errorMessage);
            throw new Error(errorMessage);
          }
        }
        
        // Success - ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏Å‡∏£‡∏ì‡∏µ create ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å ‡πÅ‡∏•‡∏∞ retry ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
        console.log('‚úÖ Stock created successfully!');
        scanCounter++;
        updateScanCounter();
        addToRecentList(barcode, product.name, 'success', '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        
        if (!isBatchScanning) {
          showToast(`‡πÄ‡∏û‡∏¥‡πà‡∏° '${product.name}' ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢`, 'success');
        }

        // POS Notification - Item added successfully
        if (posNotificationSystem) {
          const stockText = stockType === 'imei' ? `IMEI: ${imeiValue}` : '‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏à‡∏≥‡∏ô‡∏ß‡∏ô';
          
          if (!isBatchScanning) {
            posNotificationSystem.showToast('pos', {
              title: '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
              message: `${product.name} ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß`,
              type: 'success',
              icon: 'üì¶'
            });
          }
          
          posNotificationSystem.addNotification('pos', {
            title: '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏´‡∏°‡πà',
            message: `${product.name} (${stockText}) - ${product.brand || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡πÅ‡∏ö‡∏£‡∏ô‡∏î‡πå'}`,
            type: 'info',
            icon: 'üìù',
            metadata: {
              productName: product.name,
              barcode: barcodeValue,
              imei: imeiValue,
              stockType: stockType,
              timestamp: new Date().toLocaleString('th-TH')
            }
          });
        }
        
        // Auto-refresh table for better UX
        if (scanCounter % 3 === 0 || !isBatchScanning) {
          refreshStockTable();
        }
        
        return { success: true, productName: product.name, stockType: stockType };

      } catch (err) {
        Logger.error('Error in barcode handling process:', err);
        console.error('‚ùå Error in handleBarcodeScan:', err);
        
        if (!isBatchScanning) {
          showToast('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + err.message, 'error');
        } else {
          addToRecentList(barcode, '‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö', 'error', err.message);
        }

        // POS Notification - Error handling
        if (posNotificationSystem && !isBatchScanning) {
          posNotificationSystem.showToast('pos', {
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: `‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ: ${err.message}`,
            type: 'error',
            icon: '‚ö†Ô∏è',
            duration: 6000
          });
          
          posNotificationSystem.addNotification('pos', {
            title: '‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤',
            message: `‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î: ${barcode} - ${err.message}`,
            type: 'error',
            icon: 'üö®',
            metadata: {
              barcode: barcode,
              error: err.message,
              timestamp: new Date().toLocaleString('th-TH')
            }
          });
        }
        
        return { success: false, error: 'exception', message: err.message };
      } finally {
        if (!isBatchScanning) {
          showLoadingState(false);
        }
        clearInputs();
      }
    }

    // Enhanced batch scanning function
    async function startBatchScanning() {
      isBatchScanning = true;
      scanCounter = 0;
      
      const scanStatus = document.getElementById('scanStatus');
      const scanStatusText = document.getElementById('scanStatusText');
      const barcodeInput = document.getElementById('barcodeInput');
      
      scanStatus.classList.remove('hidden');
      scanStatusText.textContent = '‡πÇ‡∏´‡∏°‡∏î‡∏™‡πÅ‡∏Å‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á - ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πÅ‡∏Å‡∏ô‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î...';
      
      if (barcodeInput) {
        barcodeInput.focus();
      }
      
      showRecentAdditions();
      updateScanCounter();
      
      // Auto-refresh table every 5 seconds during batch scanning
      autoRefreshInterval = setInterval(() => {
        refreshStockTable();
      }, 5000);
      
      showToast('‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÇ‡∏´‡∏°‡∏î‡∏™‡πÅ‡∏Å‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á - ‡∏™‡πÅ‡∏Å‡∏ô‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢!', 'info');

      // POS Notification - Batch scanning started
      if (posNotificationSystem) {
        posNotificationSystem.showToast('pos', {
          title: '‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÇ‡∏´‡∏°‡∏î‡∏™‡πÅ‡∏Å‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á',
          message: '‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡πÅ‡∏Å‡∏ô‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô',
          type: 'info',
          icon: 'üîÑ',
          duration: 3000
        });
      }
    }

    // Stop batch scanning
    function stopBatchScanning() {
      isBatchScanning = false;
      
      const scanStatus = document.getElementById('scanStatus');
      scanStatus.classList.add('hidden');
      
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
      }
      
      if (scanCounter > 0) {
        showToast(`‡∏™‡πÅ‡∏Å‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${scanCounter} ‡∏ä‡∏¥‡πâ‡∏ô`, 'success');
        refreshStockTable();

        // POS Notification - Batch scanning completed
        if (posNotificationSystem) {
          posNotificationSystem.showToast('pos', {
            title: '‡∏™‡πÅ‡∏Å‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô',
            message: `‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${scanCounter} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`,
            type: 'success',
            icon: '‚úÖ',
            duration: 4000
          });
          
          posNotificationSystem.addNotification('pos', {
            title: '‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡∏™‡πÅ‡∏Å‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á',
            message: `‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${scanCounter} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`,
            type: 'success',
            icon: 'üìä',
            actions: [
              {
                label: '‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£',
                action: 'primary',
                callback: () => {
                  switchTab('unverified');
                }
              }
            ],
            metadata: {
              itemCount: scanCounter,
              scanType: 'batch',
              timestamp: new Date().toLocaleString('th-TH')
            }
          });
        }
      }
      
      scanCounter = 0;
      updateScanCounter();
    }

    // Update scan counter display
    function updateScanCounter() {
      const counterElement = document.getElementById('scanCounter');
      if (counterElement) {
        counterElement.textContent = `‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß: ${scanCounter} ‡∏ä‡∏¥‡πâ‡∏ô`;
      }
    }

    // Add item to recent additions list
    function addToRecentList(barcode, productName, status, message) {
      const timestamp = new Date();
      const recentItem = {
        barcode: barcode,
        productName: productName,
        status: status, // 'success', 'error', 'duplicate'
        message: message,
        timestamp: timestamp
      };
      
      recentAdditions.unshift(recentItem);
      
      // Keep only last 10 items
      if (recentAdditions.length > 10) {
        recentAdditions = recentAdditions.slice(0, 10);
      }
      
      renderRecentList();
      showRecentAdditions();
    }

    // Render recent additions list
    function renderRecentList() {
      const recentList = document.getElementById('recentList');
      if (!recentList) return;
      
      recentList.innerHTML = '';
      
      recentAdditions.forEach(item => {
        const div = document.createElement('div');
        div.className = `flex items-center justify-between p-2 rounded text-xs ${
          item.status === 'success' ? 'bg-green-50 text-green-700 dark:bg-green-900/20' :
          item.status === 'error' ? 'bg-red-50 text-red-700 dark:bg-red-900/20' :
          'bg-yellow-50 text-yellow-700 dark:bg-yellow-900/20'
        }`;
        
        const icon = item.status === 'success' ? 'bi-check-circle' :
                    item.status === 'error' ? 'bi-x-circle' :
                    'bi-exclamation-triangle';
        
        div.innerHTML = `
          <div class="flex items-center gap-2">
            <i class="bi ${icon}"></i>
            <span class="font-mono">${item.barcode}</span>
            <span class="truncate max-w-32">${item.productName}</span>
          </div>
          <span class="text-xs opacity-75">${item.timestamp.toLocaleTimeString('th-TH')}</span>
        `;
        
        recentList.appendChild(div);
      });
    }

    // Show/hide recent additions
    function showRecentAdditions() {
      const recentAdditions = document.getElementById('recentAdditions');
      if (recentAdditions) {
        recentAdditions.classList.remove('hidden');
      }
    }

    function hideRecentAdditions() {
      const recentAdditions = document.getElementById('recentAdditions');
      if (recentAdditions) {
        recentAdditions.classList.add('hidden');
      }
    }

    // Clear inputs helper
    function clearInputs() {
      const barcodeInput = document.getElementById('barcodeInput');
      const manualBarcode = document.getElementById('manualBarcode');
      
      if (barcodeInput) barcodeInput.value = '';
      if (manualBarcode && !isContinuousMode) manualBarcode.value = '';
    }

    // Enhanced table refresh
    async function refreshStockTable() {
      try {
        // Add visual loading indicator
        const stockContainer = document.getElementById('stockContainer');
        if (stockContainer) {
          stockContainer.style.opacity = '0.7';
        }
        
        await loadStock();
        
        if (stockContainer) {
          stockContainer.style.opacity = '1';
        }
      } catch (err) {
        Logger.error('Error refreshing stock table:', err);
      }
    }

    // ==================== ENHANCED DUPLICATE VALIDATION SYSTEM ====================
    
    // Comprehensive duplicate validation function
    async function validateDuplicateProducts(barcode, imei, stockType, branchCode) {
      try {
        // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô Branch Stock (‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
        const branchStockCheck = await checkBranchStockDuplicate(barcode, imei, stockType, branchCode);
        if (branchStockCheck.isDuplicate) {
          return {
            isDuplicate: true,
            source: 'branch_stock',
            duplicateInfo: branchStockCheck.data,
            message: createDuplicateMessage(branchStockCheck.data, 'branch_stock'),
            recommendation: getDuplicateRecommendation(branchStockCheck.data)
          };
        }
        
        // 2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô PO Items (Cross-check)
        const poItemsCheck = await checkPOItemsDuplicate(barcode, imei, stockType);
        if (poItemsCheck.isDuplicate) {
          return {
            isDuplicate: true,
            source: 'po_items',
            duplicateInfo: poItemsCheck.data,
            message: createDuplicateMessage(poItemsCheck.data, 'po_items'),
            recommendation: getDuplicateRecommendation(poItemsCheck.data)
          };
        }
        
        return {
          isDuplicate: false,
          source: null,
          duplicateInfo: null,
          message: null,
          recommendation: null
        };
        
      } catch (error) {
        Logger.error('Duplicate validation error:', error);
        // Fallback to existing method
        return await fallbackDuplicateCheck(barcode, imei, stockType, branchCode);
      }
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ã‡πâ‡∏≥‡πÉ‡∏ô Branch Stock
    async function checkBranchStockDuplicate(barcode, imei, stockType, branchCode) {
      try {
        const url = `/api/branch-stock?branch_code=${branchCode}&include_unverified=1&include_all=1`;
        const res = await secureFetch(url);
        const result = await res.json();
        
        if (res.ok && result.success && result.data) {
          const existingStocks = result.data;
          let duplicate = null;
          
          if (stockType === 'quantity') {
            duplicate = existingStocks.find(s => 
              s.barcode === barcode && 
              s.stockType === 'quantity'
            );
          } else { // 'imei' type
            duplicate = existingStocks.find(s => 
              s.barcode === barcode && 
              s.imei === imei &&
              s.stockType === 'imei'
            );
          }
          
          if (duplicate) {
            Logger.warn('Found duplicate in branch stock:', duplicate);
            return { isDuplicate: true, data: duplicate };
          }
        }
        
        return { isDuplicate: false, data: null };
      } catch (err) {
        Logger.error('Error checking branch stock duplicate:', err);
        return { isDuplicate: false, data: null };
      }
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ã‡πâ‡∏≥‡πÉ‡∏ô PO Items
    async function checkPOItemsDuplicate(barcode, imei, stockType) {
      try {
        // ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà API endpoint ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
        const response = await secureFetch('/api/purchase-order/check-duplicate-items', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            barcode: barcode,
            imei: imei,
            stockType: stockType
          })
        });
        
        if (response.status === 404) {
          // Fallback ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ API endpoint
          return await checkPOItemsFallback(barcode, imei, stockType);
        }
        
        const result = await response.json();
        
        if (!response.ok || !result.success) {
          return { isDuplicate: false, data: null };
        }
        
        return {
          isDuplicate: result.data.isDuplicate,
          data: result.data.duplicateInfo
        };
        
      } catch (error) {
        Logger.warn('PO items duplicate check failed, using fallback:', error.message);
        return await checkPOItemsFallback(barcode, imei, stockType);
      }
    }
    
    // Fallback ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö PO Items
    async function checkPOItemsFallback(barcode, imei, stockType) {
      try {
        // ‡πÉ‡∏ä‡πâ client-side check ‡∏´‡∏≤‡∏Å API ‡πÑ‡∏°‡πà‡∏°‡∏µ
        // TODO: Implement client-side PO items check if needed
        Logger.warn('Using client-side PO items check - limited functionality');
        return { isDuplicate: false, data: null };
      } catch (error) {
        Logger.error('PO items fallback check error:', error);
        return { isDuplicate: false, data: null };
      }
    }
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ã‡πâ‡∏≥
    function createDuplicateMessage(duplicateInfo, source) {
      if (!duplicateInfo) return '‡∏û‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ã‡πâ‡∏≥‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö';
      
      let message = `üö´ ‡∏û‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ã‡πâ‡∏≥!\n\n`;
      
      message += `üì¶ ‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤: ${duplicateInfo.name || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏'}\n`;
      message += `üè∑Ô∏è ‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î: ${duplicateInfo.barcode || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏'}\n`;
      
      if (duplicateInfo.imei && (duplicateInfo.stockType === 'imei' || !duplicateInfo.stockType)) {
        message += `üì± IMEI: ${duplicateInfo.imei}\n`;
      }
      
      if (source === 'branch_stock') {
        message += `üè¢ ‡∏™‡∏≤‡∏Ç‡∏≤: ${duplicateInfo.branch_code || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏'}\n`;
        
        if (duplicateInfo.verified) {
          message += `‚úÖ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: ‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß\n`;
        } else if (duplicateInfo.pending) {
          message += `‚è≥ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: ‡∏£‡∏≠‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥\n`;
        } else if (duplicateInfo.sent_to_stock) {
          message += `üì§ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: ‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß\n`;
        } else {
          message += `‚è±Ô∏è ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: ‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥\n`;
        }
        
        if (duplicateInfo.created_at) {
          message += `üìÖ ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°: ${new Date(duplicateInfo.created_at).toLocaleString('th-TH')}\n`;
        }
        if (duplicateInfo.scanned_by_name) {
          message += `üë§ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏î‡∏¢: ${duplicateInfo.scanned_by_name}\n`;
        }
        
      } else if (source === 'po_items') {
        message += `üìã ‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠: ${duplicateInfo.poNumber || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏'}\n`;
        if (duplicateInfo.supplier) {
          message += `üè≠ ‡∏ã‡∏±‡∏û‡∏û‡∏•‡∏≤‡∏¢‡πÄ‡∏≠‡∏≠‡∏£‡πå: ${duplicateInfo.supplier.name || duplicateInfo.supplier}\n`;
        }
      }
      
      return message;
    }
    
    // ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ã‡πâ‡∏≥
    function getDuplicateRecommendation(duplicateInfo) {
      if (!duplicateInfo) return null;
      
      if (duplicateInfo.verified) {
        return {
          type: 'success',
          message: '‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏î‡πâ',
          canProceed: true
        };
      } else if (duplicateInfo.pending || duplicateInfo.sent_to_stock) {
        return {
          type: 'warning',
          message: '‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ô‡∏µ‡πâ‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡∏à‡∏≤‡∏Å‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡∏Å‡πà‡∏≠‡∏ô',
          canProceed: false
        };
      } else {
        return {
          type: 'info',
          message: '‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ô‡∏µ‡πâ‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏∑‡πà‡∏ô‡πÑ‡∏î‡πâ',
          canProceed: false
        };
      }
    }
    
    // ‡πÅ‡∏™‡∏î‡∏á Enhanced Duplicate Alert
    function showDuplicateAlert(duplicateResult) {
      const { duplicateInfo, source, message, recommendation } = duplicateResult;
      
      const existingAlert = document.querySelector('.duplicate-alert-modal');
      if (existingAlert) existingAlert.remove();
      
      const alertModal = document.createElement('div');
      alertModal.className = 'duplicate-alert-modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      
      let recommendationHtml = '';
      if (recommendation) {
        const iconClass = recommendation.type === 'success' ? 'bi-check-circle-fill text-green-500' :
                         recommendation.type === 'warning' ? 'bi-exclamation-triangle-fill text-yellow-500' :
                         'bi-info-circle-fill text-blue-500';
        
        recommendationHtml = `
          <div class="mt-3 p-3 rounded-lg ${recommendation.type === 'success' ? 'bg-green-50 dark:bg-green-900/20 border border-green-200' :
                                            recommendation.type === 'warning' ? 'bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200' :
                                            'bg-blue-50 dark:bg-blue-900/20 border border-blue-200'}">
            <div class="flex items-start gap-2">
              <i class="bi ${iconClass} mt-0.5"></i>
              <span class="text-sm">${recommendation.message}</span>
            </div>
          </div>
        `;
      }
      
      let actionButtons = '';
      if (source === 'branch_stock' && duplicateInfo) {
        actionButtons += `
          <button onclick="viewDuplicateDetails('${duplicateInfo._id}')" 
                  class="btn btn-info btn-sm mr-2">
            <i class="bi bi-eye mr-1"></i> ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î
          </button>
        `;
        
        if (duplicateInfo.branch_code !== BRANCH_CODE) {
          actionButtons += `
            <button onclick="switchToBranch('${duplicateInfo.branch_code}')" 
                    class="btn btn-warning btn-sm mr-2">
              <i class="bi bi-arrow-right mr-1"></i> ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏™‡∏≤‡∏Ç‡∏≤ ${duplicateInfo.branch_code}
            </button>
          `;
        }
      }
      
      alertModal.innerHTML = `
        <div class="modal-box max-w-lg">
          <div class="flex items-start gap-3">
            <i class="bi bi-exclamation-triangle-fill text-red-500 text-3xl flex-shrink-0 mt-1"></i>
            <div class="flex-1">
              <h3 class="text-lg font-bold mb-3 text-red-600">‡∏û‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ã‡πâ‡∏≥!</h3>
              <div class="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-3 mb-4">
                <pre class="whitespace-pre-wrap text-sm text-gray-700 dark:text-gray-300 font-medium">${message}</pre>
              </div>
              
              ${recommendationHtml}
              
              ${actionButtons ? `
                <div class="mt-4">
                  <p class="text-sm text-gray-600 dark:text-gray-400 mb-2">‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£:</p>
                  <div class="flex flex-wrap gap-2">
                    ${actionButtons}
                  </div>
                </div>
              ` : ''}
            </div>
          </div>
          <div class="modal-action mt-4">
            <button onclick="this.closest('.duplicate-alert-modal').remove()"
                    class="btn btn-primary">
              <i class="bi bi-check mr-1"></i> ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÅ‡∏•‡πâ‡∏ß
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(alertModal);
    }
    
    // ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ã‡πâ‡∏≥
    async function viewDuplicateDetails(stockId) {
      try {
        const response = await secureFetch(`/api/branch-stock/${stockId}`);
        const result = await response.json();
        
        if (response.ok && result.success) {
          showItemDetailsModal(result.data);
        } else {
          showToast('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏î‡πâ', 'error');
        }
      } catch (error) {
        Logger.error('Error viewing duplicate details:', error);
        showToast('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î', 'error');
      }
    }
    
    // ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤
    function showItemDetailsModal(itemData) {
      const existingModal = document.querySelector('.item-details-modal');
      if (existingModal) existingModal.remove();
      
      const modal = document.createElement('div');
      modal.className = 'item-details-modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      
      const stockTypeBadge = itemData.stockType === 'imei' 
        ? '<span class="badge badge-info"><i class="bi bi-qr-code mr-1"></i>‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏•‡∏Ç IMEI</span>'
        : '<span class="badge badge-success"><i class="bi bi-boxes mr-1"></i>‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏•‡∏Ç IMEI</span>';
      
      let statusBadge = '';
      if (itemData.verified) {
        statusBadge = '<span class="badge badge-success"><i class="bi bi-check-circle mr-1"></i>‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß</span>';
      } else if (itemData.pending) {
        statusBadge = '<span class="badge badge-warning"><i class="bi bi-clock mr-1"></i>‡∏£‡∏≠‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥</span>';
      } else if (itemData.sent_to_stock) {
        statusBadge = '<span class="badge badge-info"><i class="bi bi-send mr-1"></i>‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß</span>';
      } else {
        statusBadge = '<span class="badge badge-ghost"><i class="bi bi-hourglass mr-1"></i>‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥</span>';
      }
      
      modal.innerHTML = `
        <div class="modal-box max-w-2xl">
          <h3 class="text-lg font-bold mb-4">
            <i class="bi bi-box-seam mr-2 text-blue-500"></i>
            ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤
          </h3>
          
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label class="label"><span class="label-text font-medium">‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤</span></label>
              <div class="text-lg font-semibold">${itemData.name || '-'}</div>
            </div>
            <div>
              <label class="label"><span class="label-text font-medium">‡πÅ‡∏ö‡∏£‡∏ô‡∏î‡πå</span></label>
              <div>${itemData.brand || '-'}</div>
            </div>
            <div>
              <label class="label"><span class="label-text font-medium">‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î</span></label>
              <div class="font-mono bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">
                ${itemData.barcode || '-'}
              </div>
            </div>
            <div>

              <div class="font-mono bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">
                ${itemData.barcode || '-'}
              </div>
            </div>
            ${itemData.stockType === 'imei' ? `
              <div>
                <label class="label"><span class="label-text font-medium">IMEI</span></label>
                <div class="font-mono bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">
                  ${itemData.imei || '-'}
                </div>
              </div>
            ` : ''}
            <div>
              <label class="label"><span class="label-text font-medium">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏™‡∏ï‡πá‡∏≠‡∏Å</span></label>
              <div>${stockTypeBadge}</div>
            </div>
            <div>
              <label class="label"><span class="label-text font-medium">‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞</span></label>
              <div>${statusBadge}</div>
            </div>
            <div>
              <label class="label"><span class="label-text font-medium">‡∏™‡∏≤‡∏Ç‡∏≤</span></label>
              <div>${itemData.branch_code || '-'}</div>
            </div>
            <div>
              <label class="label"><span class="label-text font-medium">‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°</span></label>
              <div>${itemData.created_at ? new Date(itemData.created_at).toLocaleString('th-TH') : '-'}</div>
            </div>
            <div>
              <label class="label"><span class="label-text font-medium">‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏î‡∏¢</span></label>
              <div>${itemData.scanned_by_name || '-'}</div>
            </div>
          </div>
          
          <div class="modal-action mt-6">
            <button onclick="this.closest('.item-details-modal').remove()" 
                    class="btn btn-primary">
              <i class="bi bi-x mr-1"></i> ‡∏õ‡∏¥‡∏î
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
    }
    
    // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏™‡∏≤‡∏Ç‡∏≤‡∏≠‡∏∑‡πà‡∏ô
    function switchToBranch(branchCode) {
      if (confirm(`‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏õ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏Ç‡∏≤ ${branchCode} ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?`)) {
        window.location.href = `addNewProduct_pattani.html?branch=${branchCode}`;
      }
    }
    
    // Fallback duplicate check (‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏î‡∏¥‡∏°)
    async function fallbackDuplicateCheck(barcode, imei, stockType, branchCode) {
      try {
        const existingStock = await checkExistingPendingStock(barcode, imei, stockType, branchCode);
        
        if (existingStock) {
          return {
            isDuplicate: true,
            source: 'fallback',
            duplicateInfo: existingStock,
            message: createDuplicateMessage(existingStock, 'branch_stock'),
            recommendation: getDuplicateRecommendation(existingStock)
          };
        }
        
        return {
          isDuplicate: false,
          source: null,
          duplicateInfo: null,
          message: null,
          recommendation: null
        };
        
      } catch (error) {
        Logger.error('Fallback duplicate check failed:', error);
        return {
          isDuplicate: false,
          source: null,
          duplicateInfo: null,
          message: null,
          recommendation: null
        };
      }
    }
    
    // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö backward compatibility
    async function checkExistingPendingStock(barcode, imei, stockType, branchCode) {
      try {
        const url = `/api/branch-stock?branch_code=${branchCode}&barcode=${barcode}&include_unverified=1&include_all=1`;
        const res = await secureFetch(url);
        const result = await res.json();
        
        if (res.ok && result.success && result.data) {
          const existingStocks = result.data;
          
          if (stockType === 'quantity') {
            const duplicate = existingStocks.find(s => 
              s.barcode === barcode && 
              s.stockType === 'quantity'
            );
            
            if (duplicate) {
              Logger.warn('Found duplicate quantity stock:', duplicate);
              return duplicate;
            }
          } else { // 'imei' type
            const duplicate = existingStocks.find(s => 
              s.barcode === barcode && 
              s.imei === imei &&
              s.stockType === 'imei'
            );
            
            if (duplicate) {
              Logger.warn('Found duplicate IMEI stock:', duplicate);
              return duplicate;
            }
          }
        }
        return null;
      } catch (err) {
        Logger.error('Error checking existing stock:', err);
        return null;
      }
    }
    
    // ==================== END ENHANCED DUPLICATE VALIDATION SYSTEM ====================

    // Setup checkbox listeners
    function setupCheckboxListeners() {
      // Brand checkboxes - select all items in brand
      document.querySelectorAll('.brand-checkbox').forEach(cb => {
        cb.addEventListener('change', function() {
          const brand = this.dataset.brand;
          const stockCheckboxes = document.querySelectorAll(`.stock-checkbox[data-brand="${brand}"]:not(:disabled)`);
          
          stockCheckboxes.forEach(stockCb => {
            stockCb.checked = this.checked;
            if (this.checked) {
              selectedStocks.add(stockCb.dataset.stockId);
            } else {
              selectedStocks.delete(stockCb.dataset.stockId);
            }
          });
          
          updateSelectedCount();
        });
      });
      
      // Individual stock checkboxes
      document.querySelectorAll('.stock-checkbox').forEach(cb => {
        cb.addEventListener('change', function() {
          if (this.checked) {
            selectedStocks.add(this.dataset.stockId);
          } else {
            selectedStocks.delete(this.dataset.stockId);
          }
          updateSelectedCount();
          
          // Update brand checkbox state
          const brand = this.dataset.brand;
          const brandCheckbox = document.querySelector(`.brand-checkbox[data-brand="${brand}"]`);
          if (brandCheckbox) {
            const allInBrand = document.querySelectorAll(`.stock-checkbox[data-brand="${brand}"]:not(:disabled)`);
            const checkedInBrand = document.querySelectorAll(`.stock-checkbox[data-brand="${brand}"]:checked`);
            brandCheckbox.checked = allInBrand.length === checkedInBrand.length && allInBrand.length > 0;
          }
        });
      });
      
      // Remove stock button
      document.querySelectorAll('.remove-stock-button').forEach(btn => {
        btn.addEventListener('click', async function() {
          const stockId = this.dataset.stockId;
          customConfirm('‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ô‡∏µ‡πâ?', async () => {
            await removeStock(stockId);
          });
        });
      });
    }

    // Update selected count
    function updateSelectedCount() {
      const count = selectedStocks.size;
      const countElement = document.getElementById('selectedCount');
      if (countElement) {
        countElement.textContent = count;
      }
      
      // Show/hide bulk actions
      const bulkActions = document.getElementById('bulkActions');
      if (bulkActions) {
        bulkActions.style.display = count > 0 ? 'flex' : 'none';
      }
    }

    // Bulk send to stock
    async function bulkSendToStock() {
      if (selectedStocks.size === 0) {
        showToast('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á', 'warning');
        return;
      }
      
      customConfirm(`‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ${selectedStocks.size} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å?`, async () => {
        try {
          // Rate limit check
          if (!RateLimiter.check('update_action')) return;
          
          const stockIds = Array.from(selectedStocks);
          const userInfo = await getCurrentUserInfo();
          
          // Update each stock with pending status (NOT verified)
          const promises = stockIds.map(stockId => 
            secureFetch(`/api/branch-stock/${stockId}`, {
              method: 'PATCH',
            headers: { 
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ 
                sent_to_stock: true,  // ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô true ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å
                pending: true,  // ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô pending ‡πÅ‡∏ó‡∏ô verified
                verified: false, // ‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡∏à‡∏≤‡∏Å‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å
                sent_by: userInfo.userId,
                sent_by_name: userInfo.userName,
                sent_at: new Date().toISOString()
              })
            })
          );
          
          const results = await Promise.all(promises);
          const successCount = results.filter(r => r.ok).length;
          
          // Audit log
          createAuditLog('BULK_SEND_TO_STOCK', {
            stockCount: stockIds.length,
            successCount: successCount,
            branch: document.getElementById('branchSelect').value
          });
          
          showToast(`‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ${successCount}/${stockIds.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢`, 'success');

          // POS Notification - Items sent to stock department
          if (posNotificationSystem) {
            posNotificationSystem.showToast('pos', {
              title: '‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
              message: `‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ${successCount} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß`,
              type: 'success',
              icon: 'üì§',
              duration: 4000
            });
            
            posNotificationSystem.addNotification('pos', {
              title: '‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å',
              message: `‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ${successCount}/${stockIds.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß`,
              type: 'success',
              icon: '‚úÖ',
              actions: [
                {
                  label: '‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á',
                  action: 'primary',
                  callback: () => {
                    // Switch to verified tab or show details
                    switchTab('verified');
                  }
                }
              ],
              metadata: {
                itemCount: successCount,
                totalCount: stockIds.length,
                sentBy: userInfo.userName,
                timestamp: new Date().toLocaleString('th-TH')
              }
            });
          }
          
          // Clear selection
          selectedStocks.clear();
          updateSelectedCount();
          
          // ‡∏™‡πà‡∏á socket event ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Ç‡∏∂‡πâ‡∏ô (‡∏ñ‡πâ‡∏≤ socket ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
          try {
            if (socket && socket.connected) {
              socket.emit('stockSentForApproval', {
                stockIds: stockIds,
                branchCode: document.getElementById('branchSelect').value,
                sentBy: userInfo.userId,
                sentByName: userInfo.userName,
                timestamp: new Date().toISOString()
              });
              Logger.debug("Socket event sent: stockSentForApproval");
            } else {
              Logger.debug("Socket not available, skipping real-time notification");
            }
          } catch (socketEmitError) {
            Logger.warn("Failed to emit socket event:", socketEmitError);
          }
          
          // Reload stock
          loadStock();
          
        } catch (err) {
          showToast('Error sending to stock: ' + err.message, 'error');
          
          // Audit log for error
          createAuditLog('ERROR_BULK_SEND_TO_STOCK', {
            error: err.message,
            stockCount: selectedStocks.size
          });
        }
      });
    }

    // Custom confirm dialog
    function customConfirm(message, onConfirm) {
      const dialog = document.createElement('div');
      dialog.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      dialog.innerHTML = `
        <div class="modal-box">
          <h3 class="text-lg font-bold mb-4">‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£</h3>
          <p class="mb-4">${message}</p>
          <div class="modal-action">
            <button onclick="this.closest('.fixed').remove()" class="btn btn-ghost">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
            <button class="btn btn-primary confirm-btn">‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(dialog);
      
      dialog.querySelector('.confirm-btn').addEventListener('click', () => {
        dialog.remove();
        onConfirm();
      });
    }

    // ‡πÄ‡∏û‡∏¥‡πà‡∏° function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á alert ‡πÅ‡∏ö‡∏ö‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î
    function customAlert(message, type = 'info') {
      const existingAlert = document.querySelector('.custom-alert-modal');
      if (existingAlert) existingAlert.remove();
      
      const alertModal = document.createElement('div');
      alertModal.className = 'custom-alert-modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      
      const iconClass = type === 'warning' ? 'bi-exclamation-triangle-fill text-yellow-500' : 
                       type === 'error' ? 'bi-x-circle-fill text-red-500' : 
                       'bi-info-circle-fill text-blue-500';
      
      alertModal.innerHTML = `
        <div class="modal-box max-w-md">
          <div class="flex items-start gap-3">
            <i class="bi ${iconClass} text-2xl flex-shrink-0 mt-1"></i>
            <div class="flex-1">
              <h3 class="text-lg font-bold mb-2">‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô</h3>
              <pre class="whitespace-pre-wrap text-sm text-gray-700 dark:text-gray-300">${message}</pre>
            </div>
          </div>
          <div class="modal-action mt-4">
            <button onclick="this.closest('.custom-alert-modal').remove()"
                    class="btn btn-primary">
              ‡∏ï‡∏Å‡∏•‡∏á
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(alertModal);
    }

    // ==================== END EVENT HANDLERS ====================

    // ==================== HELPER FUNCTIONS ====================
    
    // Toggle sidebar
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      const mainContent = document.getElementById('mainContent');
      const mainHeader = document.getElementById('mainHeader');
      const toggleIcon = document.getElementById('toggleIcon');
      
      sidebar.classList.toggle('-translate-x-full');
      mainContent.classList.toggle('ml-0');
      mainContent.classList.toggle('ml-56');
      
      if (mainHeader) {
        mainHeader.classList.toggle('ml-0');
        mainHeader.classList.toggle('ml-56');
      }
      
      // Update icon
      if (sidebar.classList.contains('-translate-x-full')) {
        toggleIcon.classList.remove('bi-x');
        toggleIcon.classList.add('bi-list');
      } else {
        toggleIcon.classList.remove('bi-list');
        toggleIcon.classList.add('bi-x');
      }
    }

    // Switch tab
    function switchTab(tabName) {
      Logger.info('Switching to tab:', tabName);
      
      // Update tab buttons
      document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('tab-active');
      });
      const targetTab = document.getElementById(`tab-${tabName}`);
      if (targetTab) {
        targetTab.classList.add('tab-active');
      }
      
      // Show/hide content
      const unverifiedContent = document.getElementById('content-unverified');
      const verifiedContent = document.getElementById('content-verified');
      
      if (unverifiedContent) {
        if (tabName === 'unverified') {
          unverifiedContent.classList.remove('hidden');
          unverifiedContent.style.display = 'block';
        } else {
          unverifiedContent.classList.add('hidden');
          unverifiedContent.style.display = 'none';
        }
      }
      
      if (verifiedContent) {
        if (tabName === 'verified') {
          verifiedContent.classList.remove('hidden');
          verifiedContent.style.display = 'block';
        } else {
          verifiedContent.classList.add('hidden');
          verifiedContent.style.display = 'none';
        }
      }
      
      // Audit log for tab switch
      createAuditLog('TAB_SWITCH', {
        tab: tabName,
        branch: document.getElementById('branchSelect').value
      });
      
      // Load appropriate data
      if (tabName === 'verified') {
        loadVerifiedHistory();
      } else {
        loadStock();
      }
    }

         // Calculate time ago in Thai
    function getTimeAgo(date) {
      const now = new Date();
      const diffInMs = now - date;
      const diffInMinutes = Math.floor(diffInMs / (1000 * 60));
      const diffInHours = Math.floor(diffInMs / (1000 * 60 * 60));
      const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));
      
      if (diffInMinutes < 1) return '‡πÄ‡∏û‡∏¥‡πà‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°';
      if (diffInMinutes < 60) return `${diffInMinutes} ‡∏ô‡∏≤‡∏ó‡∏µ‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß`;
      if (diffInHours < 24) return `${diffInHours} ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß`;
      if (diffInDays < 7) return `${diffInDays} ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß`;
      return date.toLocaleDateString('th-TH');
    }

    // Enhanced notification for successful addition
    function showSuccessfulAddition(productName, brand) {
      const toast = document.createElement('div');
      toast.className = 'fixed bottom-4 right-4 bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded-lg shadow-lg z-50 animate-in';
      toast.innerHTML = `
        <div class="flex items-center gap-2">
          <i class="bi bi-check-circle-fill text-green-600"></i>
          <div>
            <div class="font-medium">${productName}</div>
            <div class="text-sm opacity-75">‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤ ${brand} ‡πÅ‡∏•‡πâ‡∏ß</div>
          </div>
        </div>
      `;
      
      document.body.appendChild(toast);
      
      // Auto remove after 3 seconds
      setTimeout(() => {
        toast.classList.add('animate-out');
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }

    // ==================== END HELPER FUNCTIONS ====================

    // ==================== INITIALIZATION ====================
    
    // Clear failed audit logs on page load
    function clearFailedAuditLogs() {
      localStorage.removeItem('failedAuditLogs');
      console.log('Cleared failed audit logs');
    }
    
    // Firebase Session Management Functions
function createAddProductSession() {
  if (!window.firebaseDatabase) {
    console.warn('Firebase not initialized yet');
    return;
  }
  
  const branchCode = getCurrentBranchCode();
  const userId = localStorage.getItem('userId');
  const userName = localStorage.getItem('userName');
  
  if (!userId || !userName) {
    console.warn('User info not available for session creation');
    return;
  }
  
  firebaseSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const sessionRef = window.firebaseRef(window.firebaseDatabase, `pos/${branchCode}/sessions/${firebaseSessionId}`);
  
  const sessionData = {
    userId: userId,
    userName: userName,
    userRole: localStorage.getItem('userRole') || 'user',
    activity: 'add_product',
    page: 'addNewProduct_pattani',
    loginTime: window.firebaseServerTimestamp(),
    lastActive: window.firebaseServerTimestamp(),
    status: 'online',
    device: navigator.userAgent,
    branchCode: branchCode
  };
  
  // Set session data
  window.firebaseSet(sessionRef, sessionData)
    .then(() => {
      console.log('Add product session created:', firebaseSessionId);
      
      // Set up disconnect handler
      window.firebaseOnDisconnect(sessionRef).update({
        status: 'offline',
        logoutTime: window.firebaseServerTimestamp()
      });
      
      // Update activity on user actions
      trackUserActivity(sessionRef);
    })
    .catch(error => {
      console.error('Error creating session:', error);
    });
}

// Track user activity
function trackUserActivity(sessionRef) {
  let activityTimer;
  
  function updateActivity() {
    if (sessionRef) {
      window.firebaseUpdate(sessionRef, {
        lastActive: window.firebaseServerTimestamp()
      }).catch(err => console.warn('Activity update failed:', err));
    }
  }
  
  // Update activity every 30 seconds if user is active
  function resetActivityTimer() {
    clearTimeout(activityTimer);
    activityTimer = setTimeout(updateActivity, 30000);
  }
  
  // Track various user activities
  document.addEventListener('click', resetActivityTimer);
  document.addEventListener('keypress', resetActivityTimer);
  document.addEventListener('scroll', resetActivityTimer);
  
  // Initial activity update
  resetActivityTimer();
}

// Monitor online users
function updateOnlineUsers() {
  if (!window.firebaseDatabase) return;
  
  const branchCode = getCurrentBranchCode();
  const onlineUsersRef = window.firebaseRef(window.firebaseDatabase, `pos/${branchCode}/onlineUsers`);
  
  window.firebaseOnValue(onlineUsersRef, (snapshot) => {
    const users = snapshot.val();
    if (users) {
      const onlineCount = Object.values(users).filter(u => u.status === 'online' && u.activity === 'add_product').length;
      console.log(`Online users in add product: ${onlineCount}`);
    }
  });
}

// Log activity to Firebase
window.logAddProductActivity = function(action, details) {
  if (!window.firebaseDatabase) return;
  
  const branchCode = getCurrentBranchCode();
  const activityRef = window.firebaseRef(window.firebaseDatabase, `pos/${branchCode}/activityHistory`);
  
  const activityData = {
    action: action,
    userId: localStorage.getItem('userId'),
    userName: localStorage.getItem('userName'),
    timestamp: window.firebaseServerTimestamp(),
    page: 'addNewProduct_pattani',
    details: details || {}
  };
  
  window.firebasePush(activityRef, activityData)
    .catch(err => console.warn('Activity log failed:', err));
};

// Send stock update to Firebase
function sendStockUpdateToFirebase(updateData) {
  if (!window.firebaseDatabase) return;
  
  const branchCode = getCurrentBranchCode();
  const stockUpdatesRef = window.firebaseRef(window.firebaseDatabase, `pos/${branchCode}/stockUpdates`);
  
  const stockUpdateData = {
    ...updateData,
    timestamp: Date.now(),
    updatedBy: localStorage.getItem('userName'),
    branchCode: branchCode,
    requiresRefresh: true
  };
  
  window.firebasePush(stockUpdatesRef, stockUpdateData)
    .then(() => {
      console.log('Stock update sent to Firebase:', stockUpdateData);
    })
    .catch(err => console.warn('Failed to send stock update to Firebase:', err));
}

// Initialize Firebase connections
function initializeFirebaseConnections() {
  // Check if Firebase is ready
  if (window.firebaseDatabase) {
    createAddProductSession();
    updateOnlineUsers();
    
    // Log page access
    window.logAddProductActivity('PAGE_ACCESS', {
      page: 'Add New Product',
      branch: getCurrentBranchCode()
    });
  } else {
    // Retry after a short delay
    setTimeout(initializeFirebaseConnections, 1000);
  }
}

// DOMContentLoaded
document.addEventListener('DOMContentLoaded', async function() {
      showLoading(true);

      try {
      Logger.info('Initializing Add New Product page...');
      
      try {
        // Clear failed audit logs to prevent infinite retry
        clearFailedAuditLogs();
        
        // Check authentication
        const token = localStorage.getItem('authToken');
        if (!token) {
          window.location.href = '../login.html';
          return;
        }
        
        // Initialize CSRF token
        if (!localStorage.getItem('csrfToken')) {
          generateCSRFToken();
        }
        
        // Initialize Modular Notification System
        if (typeof ModularNotificationSystem !== 'undefined') {
          posNotificationSystem = new ModularNotificationSystem();
          console.log('üîî POS Notification System initialized');
          
          // Add welcome notification
          posNotificationSystem.addNotification('pos', {
            title: '‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô',
            message: `‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ - ‡∏™‡∏≤‡∏Ç‡∏≤ ${BRANCH_CODE}`,
            type: 'success',
            icon: 'üì¶',
            actions: [
              {
                label: '‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡πÅ‡∏Å‡∏ô',
                action: 'primary',
                callback: () => {
                  console.log('üîç ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡πÅ‡∏Å‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤');
                  document.getElementById('manualBarcode')?.focus();
                }
              }
            ]
          });
        } else {
          console.warn('‚ö†Ô∏è ModularNotificationSystem not available');
        }
        
        // Reset session timeout
        resetSessionTimeout();
        
        // Comment out retry failed audit logs to prevent errors
        // setTimeout(() => retryFailedAuditLogs(), 5000);
        
        // Load initial data
        await Promise.all([
          loadBranchInfo(),
          loadBranches(),
          loadProductImages(),
          loadSuppliers(),
          getCurrentUserInfo()
        ]);
        
        // Setup event listeners
        
        // Barcode input
        const barcodeInput = document.getElementById('barcodeInput');
        if (barcodeInput) {
          barcodeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
              handleBarcodeScan(e.target.value);
              e.target.value = ''; // Clear after scan
            }
          });
        }
        
        // Manual barcode button with enhanced loading
        const btnAddManualCode = document.getElementById('btnAddManualCode');
        if (btnAddManualCode) {
          enhanceButtonWithLoading(btnAddManualCode, {
            spinnerType: 'default',
            successMessage: '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            errorMessage: '‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à'
          });
          
          btnAddManualCode.onclick = async function() {
            const manualBarcode = document.getElementById('manualBarcode');
            if (!manualBarcode || !manualBarcode.value.trim()) {
              showToast('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡πÄ‡∏•‡∏Ç‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î', 'warning');
              manualBarcode?.focus();
              return;
            }
            
            const barcode = manualBarcode.value.trim();
            const loadingId = safeShowLoading({
              message: '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î...',
              subMessage: `‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö: ${barcode}`,
              showProgress: true,
              spinnerType: 'default'
            });
            
            try {
              safeUpdateMessage(loadingId, '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤...', '‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤');
              safeUpdateProgress(loadingId, 25);
              
              const success = await handleBarcodeScan(barcode);
              
              if (success) {
                safeUpdateProgress(loadingId, 100);
                safeUpdateMessage(loadingId, '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', '‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß');
                
                if (!isContinuousMode) {
                  manualBarcode.value = '';
                } else {
                  manualBarcode.select();
                }
                
                await new Promise(resolve => setTimeout(resolve, 800));
              } else {
                throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ');
              }
              
            } catch (error) {
              safeUpdateMessage(loadingId, '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î', error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ');
              await new Promise(resolve => setTimeout(resolve, 1200));
              throw error;
            } finally {
              safeHideLoading(loadingId);
            }
          };
        }
        
        // Scan barcode button with enhanced feedback
        const btnScanBarcode = document.getElementById('btnScanBarcode');
        if (btnScanBarcode) {
          btnScanBarcode.addEventListener('click', () => {
            if (isBatchScanning) {
              stopBatchScanning();
              return;
            }
            
            // Add loading animation
            const originalText = btnScanBarcode.innerHTML;
            btnScanBarcode.innerHTML = '<i class="bi bi-upc-scan animate-pulse"></i> ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡πÅ‡∏Å‡∏ô...';
            btnScanBarcode.classList.add('btn-warning');
            btnScanBarcode.classList.remove('btn-primary');
            
            // Show scan status and focus on hidden input
            const scanStatus = document.getElementById('scanStatus');
            if (scanStatus) {
              scanStatus.classList.remove('hidden');
            }
            
            // Focus on hidden barcode input
            const barcodeInput = document.getElementById('barcodeInput');
            if (barcodeInput) {
              barcodeInput.focus();
              showToast('‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡πÅ‡∏Å‡∏ô‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πÅ‡∏Å‡∏ô‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î‡∏Ç‡∏≠‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤', 'info');
            }
            
            // Auto hide scan status after 30 seconds
            scanningTimeout = setTimeout(() => {
              if (scanStatus) {
                scanStatus.classList.add('hidden');
              }
              btnScanBarcode.innerHTML = originalText;
              btnScanBarcode.classList.remove('btn-warning');
              btnScanBarcode.classList.add('btn-primary');
            }, 30000);
          });
        }

        // Batch scan button with enhanced state management
        const btnBatchScan = document.getElementById('btnBatchScan');
        if (btnBatchScan) {
          btnBatchScan.addEventListener('click', () => {
            if (isBatchScanning) {
              // Stop batch scanning with loading feedback
              const originalText = btnBatchScan.innerHTML;
              btnBatchScan.innerHTML = '<i class="bi bi-hourglass-split animate-spin"></i> ‡∏´‡∏¢‡∏∏‡∏î...';
              btnBatchScan.disabled = true;
              
              setTimeout(() => {
                stopBatchScanning();
                btnBatchScan.innerHTML = '<i class="bi bi-collection"></i> <span class="hidden sm:inline">‡∏™‡πÅ‡∏Å‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á</span>';
                btnBatchScan.disabled = false;
                btnBatchScan.classList.remove('btn-error');
                btnBatchScan.classList.add('btn-success');
              }, 500);
            } else {
              // Start batch scanning with loading feedback
              const originalText = btnBatchScan.innerHTML;
              btnBatchScan.innerHTML = '<i class="bi bi-hourglass-split animate-spin"></i> ‡πÄ‡∏£‡∏¥‡πà‡∏°...';
              btnBatchScan.disabled = true;
              
              setTimeout(() => {
                startBatchScanning();
                btnBatchScan.innerHTML = '<i class="bi bi-stop-circle"></i> <span class="hidden sm:inline">‡∏´‡∏¢‡∏∏‡∏î‡∏™‡πÅ‡∏Å‡∏ô</span>';
                btnBatchScan.disabled = false;
                btnBatchScan.classList.remove('btn-success');
                btnBatchScan.classList.add('btn-error');
              }, 300);
            }
          });
        }

        // Clear recent additions with confirmation
        const btnClearRecent = document.getElementById('btnClearRecent');
        if (btnClearRecent) {
          btnClearRecent.addEventListener('click', () => {
            if (recentAdditions.length === 0) {
              showToast('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÉ‡∏´‡πâ‡∏•‡πâ‡∏≤‡∏á', 'info');
              return;
            }
            
            // Add loading animation
            btnClearRecent.classList.add('loading');
            
            setTimeout(() => {
              recentAdditions = [];
              renderRecentList();
              hideRecentAdditions();
              
              btnClearRecent.classList.remove('loading');
              showToast('‡∏•‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÅ‡∏•‡πâ‡∏ß', 'info');
            }, 200);
          });
        }
        
        // Manual barcode input - handle Enter key
        const manualBarcodeInput = document.getElementById('manualBarcode');
        if (manualBarcodeInput) {
          manualBarcodeInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              if (manualBarcodeInput.value.trim()) {
                await handleBarcodeScan(manualBarcodeInput.value);
                if (!isContinuousMode) {
                  manualBarcodeInput.value = ''; // Clear input after scan
                } else {
                  manualBarcodeInput.select(); // Select all for next scan
                }
              } else {
                showToast('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡πÄ‡∏•‡∏Ç‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î', 'warning');
              }
            }
          });
        }
        
        // Continuous mode toggle
        const continuousModeCheckbox = document.getElementById('continuousMode');
        if (continuousModeCheckbox) {
          continuousModeCheckbox.addEventListener('change', (e) => {
            isContinuousMode = e.target.checked;
            const manualBarcode = document.getElementById('manualBarcode');
            if (isContinuousMode) {
              showToast('‡πÄ‡∏õ‡∏¥‡∏î‡πÇ‡∏´‡∏°‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á - ‡∏ä‡πà‡∏≠‡∏á‡∏ö‡∏≤‡∏£‡πå‡πÇ‡∏Ñ‡πâ‡∏î‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏•‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤', 'info');
              if (manualBarcode) manualBarcode.focus();
            } else {
              showToast('‡∏õ‡∏¥‡∏î‡πÇ‡∏´‡∏°‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á', 'info');
            }
          });
        }

        // Toggle continuous button
        const btnToggleContinuous = document.getElementById('btnToggleContinuous');
        if (btnToggleContinuous) {
          btnToggleContinuous.addEventListener('click', () => {
            const checkbox = document.getElementById('continuousMode');
            if (checkbox) {
              checkbox.checked = !checkbox.checked;
              checkbox.dispatchEvent(new Event('change'));
            }
          });
        }
        
        // Date filters
        const dateFrom = document.getElementById('dateFrom');
        const dateTo = document.getElementById('dateTo');
        if (dateFrom) {
          dateFrom.addEventListener('change', () => {
            if (document.querySelector('.tab-active').id === 'tab-verified') {
              loadVerifiedHistory();
            }
          });
        }
        if (dateTo) {
          dateTo.addEventListener('change', () => {
            if (document.querySelector('.tab-active').id === 'tab-verified') {
              loadVerifiedHistory();
            }
          });
        }
        
        // Tab buttons
        document.getElementById('tab-unverified').addEventListener('click', () => switchTab('unverified'));
        document.getElementById('tab-verified').addEventListener('click', () => switchTab('verified'));
        
        // Manual reload button with enhanced loading
        const btnManualReload = document.getElementById('btnManualReload');
        if (btnManualReload) {
          enhanceButtonWithLoading(btnManualReload, {
            spinnerType: 'pulse',
            successMessage: '‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            errorMessage: '‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à'
          });
          
          btnManualReload.onclick = async function() {
            const loadingId = safeShowLoading({
              message: '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...',
              subMessage: '‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î',
              showProgress: true,
              autoProgress: true,
              spinnerType: 'pulse'
            });
            
            try {
              safeUpdateMessage(loadingId, '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà...', '‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå');
              await new Promise(resolve => setTimeout(resolve, 500));
              
              safeUpdateProgress(loadingId, 30);
              safeUpdateMessage(loadingId, '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...', '‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡∏∞‡∏Å‡∏£‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•');
              
              if (typeof window.forceReloadStock === 'function') {
                await window.forceReloadStock();
              } else {
                await refreshStockTable();
              }
              
              safeUpdateProgress(loadingId, 100);
              safeUpdateMessage(loadingId, '‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô', '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô');
              
              await new Promise(resolve => setTimeout(resolve, 800));
              
            } catch (error) {
              safeUpdateMessage(loadingId, '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î', '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ');
              await new Promise(resolve => setTimeout(resolve, 1200));
              throw error;
            } finally {
              safeHideLoading(loadingId);
            }
          };
        }
        
        // Load verified history button with enhanced loading
        const btnLoadVerifiedHistory = document.getElementById('btnLoadVerifiedHistory');
        if (btnLoadVerifiedHistory) {
          enhanceButtonWithLoading(btnLoadVerifiedHistory, {
            spinnerType: 'default',
            successMessage: '‡πÇ‡∏´‡∏•‡∏î‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            errorMessage: '‡πÇ‡∏´‡∏•‡∏î‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à'
          });
          
          btnLoadVerifiedHistory.onclick = async function() {
            const dateFrom = document.getElementById('dateFrom')?.value;
            const dateTo = document.getElementById('dateTo')?.value;
            
            if (!dateFrom || !dateTo) {
              showToast('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà', 'warning');
              return;
            }
            
            const loadingId = safeShowLoading({
              message: '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥...',
              subMessage: `‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà ${dateFrom} ‡∏ñ‡∏∂‡∏á ${dateTo}`,
              showProgress: true,
              spinnerType: 'default'
            });
            
            try {
              safeUpdateMessage(loadingId, '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...', '‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•');
              safeUpdateProgress(loadingId, 25);
              
              await new Promise(resolve => setTimeout(resolve, 300));
              
              safeUpdateMessage(loadingId, '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå...', '‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà');
              safeUpdateProgress(loadingId, 70);
              
              await loadVerifiedHistory();
              
              safeUpdateProgress(loadingId, 100);
              safeUpdateMessage(loadingId, '‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô', '‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏ó‡∏µ‡πà‡∏û‡∏ö');
              
              await new Promise(resolve => setTimeout(resolve, 500));
              
            } catch (error) {
              safeUpdateMessage(loadingId, '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î', '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÑ‡∏î‡πâ');
              await new Promise(resolve => setTimeout(resolve, 1200));
              throw error;
            } finally {
              safeHideLoading(loadingId);
            }
          };
        }
        
        // Send to stock button with enhanced loading
        const btnSendToStock = document.getElementById('btnSendToStock');
        if (btnSendToStock) {
          enhanceButtonWithLoading(btnSendToStock, {
            spinnerType: 'dots',
            successMessage: '‡∏™‡πà‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            errorMessage: '‡∏™‡πà‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à'
          });
          
          btnSendToStock.onclick = async function() {
            if (selectedStocks.size === 0) {
              showToast('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á', 'warning');
              return;
            }
            
            const stockCount = selectedStocks.size;
            const confirmed = await new Promise((resolve) => {
              customConfirm(`‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ${stockCount} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å?`, () => resolve(true));
              // Add timeout to auto-resolve if user doesn't respond
              setTimeout(() => resolve(false), 10000);
            });
            
            if (!confirmed) return;
            
            const loadingId = safeShowLoading({
              message: '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å...',
              subMessage: `‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• ${stockCount} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`,
              showProgress: true,
              autoProgress: false,
              spinnerType: 'dots'
            });
            
            try {
              safeUpdateMessage(loadingId, '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...', '‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å');
              safeUpdateProgress(loadingId, 10);
              
              await new Promise(resolve => setTimeout(resolve, 200));
              
              safeUpdateMessage(loadingId, '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...', '‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö');
              safeUpdateProgress(loadingId, 30);
              
              // Rate limit check
              if (!RateLimiter.check('update_action')) {
                throw new Error('Rate limit exceeded');
              }
              
              const stockIds = Array.from(selectedStocks);
              const userInfo = await getCurrentUserInfo();
              
              safeUpdateProgress(loadingId, 50);
              safeUpdateMessage(loadingId, '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...', '‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á');
              
              // Update each stock with pending status
              const promises = stockIds.map(stockId => 
                secureFetch(`/api/branch-stock/${stockId}`, {
                  method: 'PATCH',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ 
                    sent_to_stock: true,
                    pending: true,
                    verified: false,
                    sent_by: userInfo.userId,
                    sent_by_name: userInfo.userName,
                    sent_at: new Date().toISOString()
                  })
                })
              );
              
              const results = await Promise.all(promises);
              const successCount = results.filter(r => r.ok).length;
              
              safeUpdateProgress(loadingId, 80);
              safeUpdateMessage(loadingId, '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô...', '‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å');
              
              // POS Notification
              if (posNotificationSystem) {
                posNotificationSystem.showToast('pos', {
                  title: '‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
                  message: `‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ${successCount} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß`,
                  type: 'success',
                  icon: 'üì§',
                  duration: 4000
                });
                
                posNotificationSystem.addNotification('pos', {
                  title: '‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å',
                  message: `‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ${successCount}/${stockIds.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß`,
                  type: 'success',
                  icon: '‚úÖ',
                  actions: [
                    {
                      label: '‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á',
                      action: 'primary',
                      callback: () => switchTab('verified')
                    }
                  ],
                  metadata: {
                    itemCount: successCount,
                    totalCount: stockIds.length,
                    sentBy: userInfo.userName,
                    timestamp: new Date().toLocaleString('th-TH')
                  }
                });
              }
              
              safeUpdateProgress(loadingId, 100);
              safeUpdateMessage(loadingId, '‡∏™‡πà‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô', `‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ${successCount} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`);
              
              // Clear selection and reload
              selectedStocks.clear();
              updateSelectedCount();
              
              await new Promise(resolve => setTimeout(resolve, 800));
              await loadStock();
              
              showToast(`‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ${successCount}/${stockIds.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢`, 'success');
              
            } catch (error) {
              safeUpdateMessage(loadingId, '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î', error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ');
              await new Promise(resolve => setTimeout(resolve, 1200));
              showToast('Error sending to stock: ' + (error.message || 'Unknown error'), 'error');
              throw error;
            } finally {
              safeHideLoading(loadingId);
            }
          };
        }
        
        // Select all button with enhanced feedback
        const btnSelectAll = document.getElementById('btnSelectAll');
        if (btnSelectAll) {
          btnSelectAll.addEventListener('click', () => {
            // Add visual feedback
            btnSelectAll.classList.add('loading');
            
            setTimeout(() => {
              document.querySelectorAll('.stock-checkbox:not(:disabled)').forEach(cb => {
                cb.checked = true;
                selectedStocks.add(cb.dataset.stockId);
              });
              document.querySelectorAll('.pending-checkbox').forEach(cb => {
                cb.checked = true;
                selectedStocks.add(cb.dataset.stockId);
              });
              updateSelectedCount();
              
              btnSelectAll.classList.remove('loading');
              
              // Show success feedback
              const count = selectedStocks.size;
              if (count > 0) {
                showToast(`‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ${count} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÅ‡∏•‡πâ‡∏ß`, 'success');
              }
            }, 300);
          });
        }
        
        // Deselect all button with enhanced feedback
        const btnDeselectAll = document.getElementById('btnDeselectAll');
        if (btnDeselectAll) {
          btnDeselectAll.addEventListener('click', () => {
            // Add visual feedback
            btnDeselectAll.classList.add('loading');
            
            setTimeout(() => {
              document.querySelectorAll('.stock-checkbox').forEach(cb => {
                cb.checked = false;
                selectedStocks.delete(cb.dataset.stockId);
              });
              document.querySelectorAll('.pending-checkbox').forEach(cb => {
                cb.checked = false;
                selectedStocks.delete(cb.dataset.stockId);
              });
              selectedStocks.clear();
              updateSelectedCount();
              
              btnDeselectAll.classList.remove('loading');
              showToast('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß', 'info');
            }, 200);
          });
        }

        // ... existing code ...
        
        // Initialize sidebar (if sidebar.js is loaded)
        if (typeof initializeSidebar === 'function') {
          initializeSidebar();
        }
        
        // Set default dates for verified tab
        const today = new Date();
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(today.getDate() - 30);
        
        if (dateFrom) dateFrom.value = thirtyDaysAgo.toISOString().split('T')[0];
        if (dateTo) dateTo.value = today.toISOString().split('T')[0];
        
        // Check DOM elements
        console.log('üîç Checking DOM elements:');
        console.log('  - stockContainer:', !!document.getElementById('stockContainer'));
        console.log('  - verifiedContainer:', !!document.getElementById('verifiedContainer'));
        console.log('  - branchSelect:', !!document.getElementById('branchSelect'));
        console.log('  - branchSelect value:', document.getElementById('branchSelect')?.value);
        console.log('  - Active tab:', document.querySelector('.tab-active')?.id);
        
        Logger.info('Page initialization complete');
    
    // Initialize Firebase and Socket.IO connections
    try {
      initializeAddProductSocket();
      initializeFirebaseConnections();
      Logger.info('Firebase and Socket.IO initialization started');
    } catch (error) {
      Logger.error('Failed to initialize real-time features:', error);
    }
        
        // Comment out audit log for page access to prevent errors
                  // createAuditLog('PAGE_ACCESS', {
        //   page: 'addNewProduct_pattani',
        //   branch: BRANCH_CODE
        // });
        
        } catch (err) {
          Logger.error('Initialization error:', err);
          showToast('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•', 'error');
        } finally {
          // Hide Lottie loading
          setTimeout(() => { showLoading(false); }, 600);
        }
      } catch (err) {
        console.error('Failed to load page:', err);
        // Hide Lottie loading
        setTimeout(() => { showLoading(false); }, 600);
      }
    });

    // ==================== END INITIALIZATION ====================

    // Test function to check all stocks
    window.testLoadAllStocks = async function() {
      console.log('üß™ Testing: Loading ALL stocks without filter...');
      try {
        const branchCode = document.getElementById('branchSelect')?.value || BRANCH_CODE;
        const token = localStorage.getItem('authToken');
        
        // Load ALL stocks without any filter
        const res = await fetch(`/api/branch-stock?branch_code=${branchCode}`, {
          headers: {
            'Authorization': 'Bearer ' + token
          }
        });
        
        const result = await res.json();
        console.log('üß™ Test Result - All stocks:', result);
        
        if (result.data) {
          console.log('üß™ Total stocks found:', result.data.length);
          
          // Filter iPhone stocks
          const iPhoneStocks = result.data.filter(s => s.name && s.name.includes('iPhone'));
          console.log('üß™ iPhone stocks found:', iPhoneStocks.length);
          console.log('üß™ iPhone stocks details:', iPhoneStocks);
          
          // Check unverified stocks
          const unverifiedStocks = result.data.filter(s => 
            s.pending !== true && s.verified !== true
          );
          console.log('üß™ Unverified stocks:', unverifiedStocks.length);
          console.log('üß™ Unverified stocks details:', unverifiedStocks);
        }
      } catch (err) {
        console.error('üß™ Test error:', err);
      }
    };
    
    // Debug function to show all stocks with specific conditions
    window.debugShowAllStocks = async function() {
      console.log('üêõ Debug: Checking all stocks in the system...');
      try {
        const branchCode = document.getElementById('branchSelect')?.value || BRANCH_CODE;
        const token = localStorage.getItem('authToken');
        
        // Try multiple API calls with different parameters
        const endpoints = [
          `/api/branch-stock?branch_code=${branchCode}`,
          `/api/branch-stock?branch_code=${branchCode}&pending=false`,
          `/api/branch-stock?branch_code=${branchCode}&verified=false`,
          `/api/branch-stock?branch_code=${branchCode}&include_unverified=1`,
          `/api/branch-stock?branch_code=${branchCode}&include_all=1`
        ];
        
        for (const endpoint of endpoints) {
          console.log(`\nüîç Testing endpoint: ${endpoint}`);
          const res = await fetch(endpoint, {
            headers: { 'Authorization': 'Bearer ' + token }
          });
          
          if (res.ok) {
            const result = await res.json();
            if (result.data && result.data.length > 0) {
              console.log(`‚úÖ Found ${result.data.length} stocks`);
              
              // Show iPhone 13 stocks specifically
              const iPhone13Stocks = result.data.filter(s => s.name && s.name.includes('iPhone 13'));
              if (iPhone13Stocks.length > 0) {
                console.log(`üì± Found ${iPhone13Stocks.length} iPhone 13 stocks:`);
                iPhone13Stocks.forEach(stock => {
                  console.log(`  - ${stock.name}:`, {
                    id: stock._id,
                    pending: stock.pending,
                    verified: stock.verified,
                    sent_to_stock: stock.sent_to_stock,
                    created_at: stock.created_at
                  });
                });
              }
            } else {
              console.log('‚ùå No stocks found');
            }
          } else {
            console.error('‚ùå API call failed:', res.status);
          }
        }
      } catch (err) {
        console.error('üêõ Debug error:', err);
      }
    };
    
    console.log('üí° Debug functions available: debugShowAllStocks()');
    
    // Add test function to window for easy access
    console.log('üí° Test function available: testLoadAllStocks()');
    
    // Force reload stock with cache bypass
    window.forceReloadStock = async function() {
      console.log('üîÑ Force reloading stock with cache bypass...');
      try {
        const branchCode = document.getElementById('branchSelect')?.value || BRANCH_CODE;
        const token = localStorage.getItem('authToken');
        
        // Clear any cached data
        sessionStorage.removeItem('stockData');
        
        // Add timestamp and random number to force cache bypass
        const timestamp = new Date().getTime();
        const random = Math.random();
        const url = `/api/branch-stock?branch_code=${branchCode}&include_unverified=1&include_all=1&_=${timestamp}&r=${random}`;
        
        console.log('üåê Fetching from:', url);
        
        const res = await fetch(url, {
          headers: {
              'Authorization': 'Bearer ' + token,
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          },
          cache: 'no-store'
        });
        
        const result = await res.json();
        console.log('üì¶ Force reload result:', {
          success: result.success,
          dataCount: result.data ? result.data.length : 0,
          data: result.data
        });
        
        if (result.data && result.data.length > 0) {
          // Show all stocks
          console.log('üìã All stocks:');
          result.data.forEach((stock, i) => {
            console.log(`${i+1}. ${stock.name} - Barcode: ${stock.barcode}, IMEI: ${stock.imei}, Status: pending=${stock.pending}, verified=${stock.verified}, sent_to_stock=${stock.sent_to_stock}`);
          });
          
          // Show unverified stocks
          const unverified = result.data.filter(s => s.verified !== true);
          console.log(`\nüìå Unverified stocks (${unverified.length} items):`);
          unverified.forEach((stock, i) => {
            console.log(`${i+1}. ${stock.name} - Created: ${stock.created_at}`);
          });
        }
        
        // Reload the UI
        await loadStock();
        
      } catch (err) {
        console.error('‚ùå Force reload error:', err);
      }
    };
    
    // Debug function to manually add test stock
    window.addTestStock = async function(productName = 'iPhone 13') {
      console.log('üß™ Adding test stock...');
      try {
        const branchCode = document.getElementById('branchSelect')?.value || BRANCH_CODE;
        const token = localStorage.getItem('authToken');
        const userInfo = await getCurrentUserInfo();
        
        // Generate unique barcode and IMEI
        const timestamp = Date.now();
        const testBarcode = `TEST${timestamp}`;
        const testIMEI = `${timestamp}123456789012345`;
        
        const testData = {
          branch_code: branchCode,
          barcode: testBarcode,

          imei: testIMEI,
          name: productName,
          price: 29900,
          brand: 'Apple',
          model: '13',
          category: 'Smartphone',
          stockType: 'imei',
          supplier: 'Test Supplier',
          scanned_by: userInfo.userId,
          scanned_by_name: userInfo.userName,
          updated_by: userInfo.userId,
          stock_value: 0,
          created_at: new Date().toISOString()
        };
        
        console.log('üì§ Sending test data:', testData);
        
        const res = await fetch('/api/branch-stock', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + token
          },
          body: JSON.stringify(testData)
        });
        
        const result = await res.json();
        console.log('üì• Create result:', result);
        
        if (result.success) {
          console.log('‚úÖ Test stock created successfully!');
          // Force reload to see the new item
          await forceReloadStock();
        } else {
          console.error('‚ùå Failed to create test stock:', result.error);
        }
        
      } catch (err) {
        console.error('‚ùå Error adding test stock:', err);
      }
    };

    // Test function to debug quantity vs imei stock types
    window.testStockTypes = async function() {
      console.log('üß™ Testing stock types...');
      
      // Test 1: Test IMEI product
      console.log('\nüß™ Test 1: Testing IMEI product...');
      const imeiResult = await handleBarcodeScan('123456789012345');
      console.log('üìä IMEI Result:', imeiResult);
      
      // Test 2: Test Quantity product
      console.log('\nüß™ Test 2: Testing Quantity product...');
      const quantityResult = await handleBarcodeScan('QUANTITY123');
      console.log('üìä Quantity Result:', quantityResult);
      
      // Test 3: Test with actual product search
      console.log('\nüß™ Test 3: Testing product search...');
      try {
        const token = localStorage.getItem('authToken');
        const res = await fetch('/api/product/find-by-barcode?code=QUANTITY123', {
          headers: { 'Authorization': 'Bearer ' + token }
        });
        const result = await res.json();
        console.log('üìä Product search result:', result);
      } catch (err) {
        console.error('‚ùå Product search error:', err);
      }
    };

         // Test function to check available products
     window.checkAvailableProducts = async function() {
       console.log('üß™ Checking available products...');
       try {
         const token = localStorage.getItem('authToken');
         const res = await fetch('/api/product-image', {
           headers: { 'Authorization': 'Bearer ' + token }
         });
         const result = await res.json();
         console.log('üìä Available products:', result);
         
         if (result.data && result.data.length > 0) {
           console.log('üìã First 5 products:');
           result.data.slice(0, 5).forEach((product, i) => {
             console.log(`${i+1}. ${product.name} - stockType: ${product.stockType || 'undefined'}, barcode: ${product.barcode}`);
           });
           
           // Find quantity products
           const quantityProducts = result.data.filter(p => p.stockType === 'quantity');
           console.log(`üìä Quantity products found: ${quantityProducts.length}`);
           if (quantityProducts.length > 0) {
             console.log('üìã Quantity products:');
             quantityProducts.forEach((product, i) => {
               console.log(`${i+1}. ${product.name} - barcode: ${product.barcode}`);
             });
           }
         }
       } catch (err) {
         console.error('‚ùå Error checking products:', err);
       }
     };

     // Test function to check available suppliers
     window.checkAvailableSuppliers = async function() {
       console.log('üß™ Checking available suppliers...');
       try {
         const token = localStorage.getItem('authToken');
         const res = await fetch('/api/supplier', {
           headers: { 'Authorization': 'Bearer ' + token }
         });
         const result = await res.json();
         console.log('üìä Available suppliers:', result);
         
         if (result.data && result.data.length > 0) {
           console.log('üìã All suppliers:');
           result.data.forEach((supplier, i) => {
             console.log(`${i+1}. "${supplier.name}" - ID: ${supplier._id}`);
           });
         }
         
         console.log('üìã Current defaultSupplier:', defaultSupplier);
       } catch (err) {
         console.error('‚ùå Error checking suppliers:', err);
       }
     };

     // Helper function to get working supplier name
     window.getWorkingSupplierName = async function() {
       console.log('üîç Finding working supplier name...');
       try {
         const token = localStorage.getItem('authToken');
         const res = await fetch('/api/supplier', {
           headers: { 'Authorization': 'Bearer ' + token }
         });
         const result = await res.json();
         
         if (result.data && result.data.length > 0) {
           const workingSupplier = result.data[0];
           console.log('‚úÖ Working supplier found:', workingSupplier.name);
           return workingSupplier.name;
         }
         
         console.warn('‚ö†Ô∏è No suppliers found in system');
         return null;
       } catch (err) {
         console.error('‚ùå Error getting working supplier:', err);
         return null;
       }
     };

     // Test function to try adding with working supplier
     window.testWithWorkingSupplier = async function() {
       console.log('üß™ Testing with working supplier...');
       
       const workingSupplier = await getWorkingSupplierName();
       if (workingSupplier) {
         console.log('üîç Using working supplier:', workingSupplier);
         const testBarcode = 'TEST' + Date.now();
         const result = await handleBarcodeScan(testBarcode, { forceSupplier: workingSupplier });
         console.log('üìä Test result:', result);
         return result;
       } else {
         console.error('‚ùå No working supplier found');
         return null;
       }
     };

     // Test function to try adding with specific supplier
     window.testWithSupplier = async function(supplierName = '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏') {
       console.log('üß™ Testing with specific supplier:', supplierName);
       
       const testBarcode = 'TEST' + Date.now();
       const result = await handleBarcodeScan(testBarcode, { testSupplier: supplierName });
       console.log('üìä Test result:', result);
       
       return result;
     };

     // Function to validate supplier exists in system
     window.validateSupplier = async function(supplierName) {
       console.log('üîç Validating supplier:', supplierName);
       try {
         const token = localStorage.getItem('authToken');
         const res = await fetch('/api/supplier', {
           headers: { 'Authorization': 'Bearer ' + token }
         });
         const result = await res.json();
         
         if (result.data && result.data.length > 0) {
           const found = result.data.find(s => s.name === supplierName);
           console.log('üìä Supplier validation result:', found ? 'Found' : 'Not found');
           return found;
         }
         
         return null;
       } catch (err) {
         console.error('‚ùå Error validating supplier:', err);
         return null;
       }
     };

     // Function to get the first valid supplier from system
     window.getFirstValidSupplier = async function() {
       console.log('üîç Getting first valid supplier...');
       try {
         const token = localStorage.getItem('authToken');
         const res = await fetch('/api/supplier', {
           headers: { 'Authorization': 'Bearer ' + token }
         });
         const result = await res.json();
         
         if (result.data && result.data.length > 0) {
           const firstSupplier = result.data[0];
           console.log('‚úÖ First valid supplier found:', firstSupplier.name);
           return firstSupplier;
         }
         
         console.warn('‚ö†Ô∏è No suppliers found in system');
         return null;
       } catch (err) {
         console.error('‚ùå Error getting first valid supplier:', err);
         return null;
       }
     };
    
         console.log('üí° Debug functions available:');
     console.log('  - forceReloadStock() : Force reload all stock data with cache bypass');
     console.log('  - addTestStock() : Add a test iPhone 13 stock item');
     console.log('  - addTestStock("Product Name") : Add test stock with custom name');
     console.log('  - testStockTypes() : Test both IMEI and quantity stock types');
     console.log('  - checkAvailableProducts() : Check available products and their stock types');
     console.log('  - checkAvailableSuppliers() : Check available suppliers in the system');
     console.log('  - testWithSupplier("supplier name") : Test adding stock with specific supplier');
     console.log('  - getWorkingSupplierName() : Get the first working supplier name');
     console.log('  - testWithWorkingSupplier() : Test adding with working supplier');
     console.log('üîß Latest fixes:');
     console.log('  - Enhanced supplier fallback system with all available suppliers');
     console.log('  - Using comprehensive fallback strategies (original + trimmed names)');
     console.log('  - Added support for all suppliers in the system, not just default');
     console.log('  - Added null/empty supplier fallback for systems that allow it');
     console.log('');
     console.log('üõ†Ô∏è To fix supplier issue:');
     console.log('  1. Run checkAvailableSuppliers() to see actual suppliers');
     console.log('  2. Run testWithWorkingSupplier() to test with working supplier');
     console.log('  3. Check that defaultSupplier is loaded correctly');
     console.log('  4. ‚úÖ ENHANCED: Now trying all available suppliers with multiple formats');
    
    function checkConnection() {
      // Use a more flexible check for production environment
      if (window.location.hostname === 'localhost' || window.location.hostname.endsWith('2pheenong.com')) {
        console.log('Connection check passed');
      } else {
        console.log('Connection check for other domains');
      }
    }

    // ==================== CLEANUP & MEMORY MANAGEMENT ====================
    
    // Cleanup function when leaving page
    function cleanup() {
      // Stop batch scanning
      if (isBatchScanning) {
        stopBatchScanning();
      }
      
      // Clear intervals
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
      }
      
      if (scanningTimeout) {
        clearTimeout(scanningTimeout);
        scanningTimeout = null;
      }
      
      // Clear recent additions
      recentAdditions = [];
      
      Logger.info('Page cleanup completed');
    }
    
    // Add event listeners for page cleanup
    window.addEventListener('beforeunload', cleanup);
    window.addEventListener('pagehide', cleanup);
    
    // Enhanced visibility change handler
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Pause auto-refresh when tab is hidden
        if (autoRefreshInterval && !isBatchScanning) {
          clearInterval(autoRefreshInterval);
          autoRefreshInterval = null;
        }
      } else {
        // Resume auto-refresh when tab is visible
        if (!autoRefreshInterval && !isBatchScanning) {
          autoRefreshInterval = setInterval(() => {
            if (!isBatchScanning) {
              refreshStockTable();
            }
          }, 15000);
        }
      }
    });
    
    // Multi-item addition helper functions
    window.addMultipleTestItems = async function(count = 5) {
      console.log(`üß™ Adding ${count} test items...`);
      if (!isBatchScanning) startBatchScanning();
      
      for (let i = 0; i < count; i++) {
        const timestamp = Date.now() + i;
        const testBarcode = `TEST${timestamp}`;
        await new Promise(resolve => setTimeout(resolve, 500)); // Delay between items
        document.getElementById('barcodeInput').value = testBarcode;
        document.getElementById('barcodeInput').dispatchEvent(new KeyboardEvent('keypress', { key: 'Enter' }));
      }
      
      setTimeout(() => {
        if (isBatchScanning) stopBatchScanning();
      }, 2000);
    };
    
    console.log('üí° Multi-item debug functions:');
    console.log('  - addMultipleTestItems(5) : Add 5 test items in batch mode');

    // =================== POS NOTIFICATION GLOBAL FUNCTIONS ===================
    
    // Global functions for external use
    window.showPOSToast = function(title, message, type = 'info', options = {}) {
      if (posNotificationSystem) {
        return posNotificationSystem.showToast('pos', {
          title,
          message,
          type,
          icon: options.icon || 'üì¶',
          duration: options.duration || 4000,
          ...options
        });
      } else {
        console.warn('POS Notification System not initialized');
        showToast(`${title}: ${message}`, type);
      }
    };

    window.addPOSNotification = function(title, message, type = 'info', options = {}) {
      if (posNotificationSystem) {
        return posNotificationSystem.addNotification('pos', {
          title,
          message,
          type,
          icon: options.icon || 'üì¶',
          actions: options.actions || [],
          metadata: {
            source: 'external',
            timestamp: new Date().toLocaleString('th-TH'),
            ...options.metadata
          },
          ...options
        });
      } else {
        console.warn('POS Notification System not initialized');
      }
    };

    // Clear all POS notifications
    window.clearPOSNotifications = function() {
      if (posNotificationSystem) {
        posNotificationSystem.clearNotifications('pos');
      }
    };

    // Mark all POS notifications as read
    window.markAllPOSAsRead = function() {
      if (posNotificationSystem) {
        posNotificationSystem.markAllAsRead('pos');
      }
    };

    // Get notification system status
    window.getPOSNotificationStatus = function() {
      if (posNotificationSystem) {
        return {
          initialized: true,
          unreadCount: posNotificationSystem.getUnreadCount('pos'),
          totalCount: posNotificationSystem.getNotificationCount('pos'),
          system: posNotificationSystem
        };
      }
      return { initialized: false };
    };

    // Test notification function (for debugging)
    window.testPOSNotifications = function() {
      console.log('üß™ Testing POS Notifications...');
      
      if (!posNotificationSystem) {
        console.error('‚ùå POS Notification System not initialized');
        return;
      }

      // Test toast
      showPOSToast('‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö', '‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô POS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥', 'success', {
        icon: 'üß™',
        duration: 3000
      });

      // Test notification with actions
      addPOSNotification('‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô', '‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô POS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤', 'info', {
        icon: 'üîî',
        actions: [
          {
            label: '‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡πÅ‡∏Å‡∏ô',
            action: 'primary',
            callback: () => {
              console.log('‚úÖ ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡πÅ‡∏Å‡∏ô');
              document.getElementById('manualBarcode')?.focus();
            }
          },
          {
            label: '‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£',
            action: 'secondary', 
            callback: () => {
              console.log('üìã ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£');
              switchTab('unverified');
            }
          }
        ],
        metadata: {
          testId: Date.now(),
          testType: 'manual',
          module: 'inventory'
        }
      });

      // Display status
      const status = getPOSNotificationStatus();
      console.log('üìä POS Notification Status:', status);
    };

    // Auto-test on development environment
    if (window.location.hostname === 'localhost' || window.location.hostname.includes('dev')) {
      // Add test button
      setTimeout(() => {
        if (!document.getElementById('testPOSNotificationBtn')) {
          const testBtn = document.createElement('button');
          testBtn.id = 'testPOSNotificationBtn';
          testBtn.textContent = 'üîî Test POS Notifications';
          testBtn.className = 'fixed bottom-2 left-2 z-50 bg-cyan-500 text-white px-3 py-1 rounded text-sm';
          testBtn.onclick = () => testPOSNotifications();
          document.body.appendChild(testBtn);
        }
      }, 2000);
    }

    console.log('üîî POS Notification Global Functions initialized');
    
    // ==================== FIREBASE & SOCKET.IO INITIALIZATION ====================
    
    // Initialize Socket.IO and Firebase connections after DOM is ready
    setTimeout(() => {
      try {
        // Initialize Socket.IO connection
        initializeAddProductSocket();
        
        // Initialize Firebase connections
        initializeFirebaseConnections();
        
        console.log('üî• Firebase and Socket.IO initialization started');
      } catch (error) {
        console.error('‚ùå Failed to initialize real-time features:', error);
      }
    }, 1000);
    
    // Clean up Firebase session and Socket.IO on page unload
    window.addEventListener('beforeunload', function() {
      if (firebaseSessionId && window.firebaseDatabase) {
        const branchCode = getCurrentBranchCode();
        const sessionRef = window.firebaseRef(window.firebaseDatabase, `pos/${branchCode}/sessions/${firebaseSessionId}`);
        window.firebaseUpdate(sessionRef, {
          status: 'offline',
          logoutTime: window.firebaseServerTimestamp()
        }).catch(() => {}); // Ignore errors on unload
      }
      
      if (addProductSocket) {
        addProductSocket.disconnect();
      }

      // Clean up Lottie animation
      if (lottieAnimation) {
        lottieAnimation.destroy();
        lottieAnimation = null;
      }
    });
    
    // Enhanced activity tracking for product additions
    function enhanceProductAdditionTracking() {
      // Override existing addProduct function to include Firebase logging
      const originalAddToUnverified = window.addToUnverifiedStock;
      if (originalAddToUnverified) {
        window.addToUnverifiedStock = function(data) {
          // Log to Firebase
          if (window.logAddProductActivity) {
            window.logAddProductActivity('PRODUCT_ADDED', {
              barcode: data.barcode,
              productName: data.name,
              imei: data.imei,
              stockType: data.stockType,
              method: 'manual_entry'
            });
          }
          
          // Send stock update to Firebase
          sendStockUpdateToFirebase({
            action: 'PRODUCT_ADDED',
            productName: data.name,
            barcode: data.barcode,
            message: `‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏´‡∏°‡πà: ${data.name}`
          });
          
          // Emit Socket.IO event
          if (addProductSocket && addProductSocket.connected) {
            addProductSocket.emit('product-added', {
              productName: data.name,
              barcode: data.barcode,
              userId: localStorage.getItem('userId'),
              userName: localStorage.getItem('userName'),
              branchCode: getCurrentBranchCode(),
              timestamp: Date.now()
            });
          }
          
          // Call original function
          return originalAddToUnverified.call(this, data);
        };
      }
      
      // Override send for approval function
      const originalSendForApproval = window.sendForApproval;
      if (originalSendForApproval) {
        window.sendForApproval = function() {
          // Log to Firebase
          if (window.logAddProductActivity) {
            window.logAddProductActivity('STOCK_SENT_FOR_APPROVAL', {
              itemCount: Object.keys(unverifiedStock).length,
              sentBy: localStorage.getItem('userName')
            });
          }
          
          // Send stock update to Firebase
          sendStockUpdateToFirebase({
            action: 'STOCK_SENT_FOR_APPROVAL',
            message: `‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥ ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô ${Object.keys(unverifiedStock).length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`
          });
          
          // Emit Socket.IO event
          if (addProductSocket && addProductSocket.connected) {
            addProductSocket.emit('stock-sent-for-approval', {
              itemCount: Object.keys(unverifiedStock).length,
              userId: localStorage.getItem('userId'),
              userName: localStorage.getItem('userName'),
              branchCode: getCurrentBranchCode(),
              timestamp: Date.now()
            });
          }
          
          // Call original function
          return originalSendForApproval.call(this);
        };
      }
    }
    
    // Hide Lottie loading animation
    setTimeout(() => showLoading(false), 800);

    // Apply enhanced tracking after a delay to ensure functions are loaded
    setTimeout(enhanceProductAdditionTracking, 2000);
    
    // ==================== END CLEANUP & MEMORY MANAGEMENT ====================

    // Test the enhanced supplier fallback system
    window.testEnhancedSupplierFallback = async function() {
      console.log('üß™ Testing enhanced supplier fallback system...');
      
      // Test with the barcode that failed in console
      const testBarcode = '1478523691012365';
      console.log('üîç Testing with barcode from user console:', testBarcode);
      
      try {
        const result = await handleBarcodeScan(testBarcode);
        console.log('üìä Enhanced fallback test result:', result);
        
        if (result.success) {
          console.log('‚úÖ Enhanced supplier fallback system working correctly!');
          return true;
        } else {
          console.log('‚ùå Enhanced fallback system still has issues:', result.error);
          return false;
        }
      } catch (error) {
        console.error('‚ùå Error during enhanced fallback test:', error);
        return false;
      }
    };

    // Function to show current supplier configuration
    window.showSupplierConfiguration = async function() {
      console.log('üîç Current supplier configuration:');
      console.log('üìã Default supplier:', defaultSupplier);
      console.log('üìã Available suppliers:', window.availableSuppliers);
      
      if (window.availableSuppliers) {
        console.log('ÔøΩÔøΩ Supplier breakdown:');
        window.availableSuppliers.forEach((supplier, index) => {
          console.log(`${index + 1}. "${supplier.name}" (ID: ${supplier._id})`);
        });
      }
    };
  </script>
</body>
</html>