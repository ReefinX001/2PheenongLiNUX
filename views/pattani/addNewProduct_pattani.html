<!DOCTYPE html>
<!-- htmlhint-disable -->
<!-- eslint-disable -->
<!-- prettier-ignore -->
<html lang="th" class="scroll-smooth" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <title>คลังสินค้า</title>

  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png" />
  <link rel="shortcut icon" href="/favicon/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="/favicon/android-chrome-192x192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="/favicon/android-chrome-512x512.png" />

  <script src="../../js/activity-tracker.js"></script>
  <script src="/js/branch-navigation.js"></script>
  <script src="/views/pattani/sidebar/sidebar.js"></script>
  
  <!-- Security Headers -->
  <meta name="csrf-token" content="">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="X-XSS-Protection" content="1; mode=block">
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          fontFamily: {
            sans: ['Prompt', 'sans-serif'],
          },
        },
      },
    };
  </script>

  <!-- DaisyUI -->
  <link href="https://cdn.jsdelivr.net/npm/daisyui@2.51.5/dist/full.css" rel="stylesheet" type="text/css" />

  <!-- Socket.IO with fallback -->
  <script>
    // Socket.IO availability check
    window.socketIOAvailable = false;
  </script>
  <script src="/socket.io/socket.io.js" 
          onload="window.socketIOAvailable = true;" 
          onerror="console.warn('Socket.IO script failed to load, continuing without real-time features');"></script>





          

  <!-- Bootstrap Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" />

  <!-- Google Fonts: Prompt -->

  <!-- Animate.css -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />

  <!-- Lottie Animation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Prompt:wght@400;500;600&display=swap" rel="stylesheet" />
  
  <!-- Sidebar CSS -->
  <link rel="stylesheet" href="/views/pattani/sidebar/sidebar.css" />

  <!-- Modular Notification System -->
  <link rel="stylesheet" href="/css/notification-modules.css">
  <script src="/js/notification-modules.js"></script>

  <!-- Sidebar Management -->
  <script>
  </script>

  <style>
    /* Minimal Design System */
    :root {
      /* Colors - Simplified palette */
      --primary: #2563eb;
      --primary-hover: #1d4ed8;
      --success: #10b981;
      --danger: #ef4444;
      --warning: #f59e0b;
      
      /* Neutrals */
      --gray-50: #f9fafb;
      --gray-100: #f3f4f6;
      --gray-200: #e5e7eb;
      --gray-300: #d1d5db;
      --gray-500: #6b7280;
      --gray-700: #374151;
      --gray-900: #111827;
      
      /* Spacing */
      --space-1: 0.25rem;
      --space-2: 0.5rem;
      --space-3: 0.75rem;
      --space-4: 1rem;
      --space-6: 1.5rem;
      --space-8: 2rem;
      
      /* Border radius */
      --radius: 0.5rem;
      --radius-sm: 0.375rem;
      
      /* Shadows */
      --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    }

    /* Dark mode */
    [data-theme="dark"] {
      --gray-50: #18181b;
      --gray-100: #27272a;
      --gray-200: #3f3f46;
      --gray-300: #52525b;
      --gray-500: #a1a1aa;
      --gray-700: #e4e4e7;
      --gray-900: #fafafa;
    }

    /* Base Reset */
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Prompt', sans-serif;
      color: var(--gray-900);
      background: var(--gray-50);
      margin: 0;
      line-height: 1.5;
    }

    /* Minimal Components */
    .card {
      background: white;
      border-radius: var(--radius);
      box-shadow: var(--shadow-sm);
      border: 1px solid var(--gray-200);
    }
    
    [data-theme="dark"] .card {
      background: var(--gray-100);
      border-color: var(--gray-300);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2) var(--space-4);
      font-size: 0.875rem;
      font-weight: 500;
      border-radius: var(--radius-sm);
      border: 1px solid transparent;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: var(--primary);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--primary-hover);
    }

    .btn-ghost {
      background: transparent;
      color: var(--gray-700);
      border-color: var(--gray-300);
    }

    .btn-ghost:hover:not(:disabled) {
      background: var(--gray-100);
    }

    .btn-danger {
      background: white;
      color: var(--danger);
      border-color: var(--danger);
    }

    .btn-danger:hover:not(:disabled) {
      background: var(--danger);
      color: white;
    }

    /* Button sizes */
    .btn-sm {
      padding: var(--space-1) var(--space-3);
      font-size: 0.75rem;
    }

    .btn-outline {
      background: transparent;
      color: var(--gray-700);
      border-color: var(--gray-300);
    }

    .btn-outline:hover:not(:disabled) {
      background: var(--gray-100);
    }

    .btn-success {
      background: var(--success);
      color: white;
    }

    .btn-success:hover:not(:disabled) {
      background: #0f9d58;
    }

    .btn-error {
      background: var(--danger);
      color: white;
    }

    .btn-error:hover:not(:disabled) {
      background: #dc2626;
    }

    .input {
      width: 100%;
      padding: var(--space-2) var(--space-3);
      font-size: 0.875rem;
      border: 1px solid var(--gray-300);
      border-radius: var(--radius-sm);
      background: white;
      transition: border-color 0.15s;
    }

    .input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    [data-theme="dark"] .input {
      background: var(--gray-100);
      border-color: var(--gray-300);
      color: var(--gray-900);
    }

    .input-bordered {
      border: 1px solid var(--gray-300);
    }

    .input-sm {
      padding: var(--space-1) var(--space-2);
      font-size: 0.75rem;
    }

    /* Tables */
    .table {
      width: 100%;
      font-size: 0.875rem;
      border-collapse: collapse;
    }

    .table th {
      padding: var(--space-3);
      text-align: left;
      font-weight: 500;
      color: var(--gray-500);
      background: var(--gray-50);
      border-bottom: 1px solid var(--gray-200);
    }

    .table td {
      padding: var(--space-3);
      border-bottom: 1px solid var(--gray-100);
    }

    [data-theme="dark"] .table th {
      background: var(--gray-200);
      border-color: var(--gray-300);
    }

    [data-theme="dark"] .table td {
      border-color: var(--gray-200);
    }

    .table-zebra tbody tr:nth-child(odd) {
      background: var(--gray-50);
    }

    [data-theme="dark"] .table-zebra tbody tr:nth-child(odd) {
      background: var(--gray-200);
    }

    /* Badges */
    .badge {
      display: inline-flex;
      align-items: center;
      padding: var(--space-1) var(--space-2);
      font-size: 0.75rem;
      font-weight: 500;
      border-radius: 9999px;
    }

    .badge-info {
      background: rgba(37, 99, 235, 0.1);
      color: var(--primary);
    }

    .badge-success {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
    }

    .badge-warning {
      background: rgba(245, 158, 11, 0.1);
      color: var(--warning);
    }

    .badge-error {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
    }

    /* Layout */
    #mainContent {
      transition: margin-left 0.3s;
      margin-left: 14rem;
      min-height: 100vh;
      background: var(--gray-50);
    }

    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--space-4);
    }

    .section-title {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--gray-900);
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    /* Tab styles */
    .tab-button {
      background: transparent;
      color: var(--gray-500);
      border: none;
      position: relative;
    }
    
    .tab-button:hover {
      color: var(--gray-700);
      background: var(--gray-100);
    }
    
    .tab-button.tab-active {
      background: white;
      color: var(--primary);
      box-shadow: var(--shadow-sm);
    }
    
    [data-theme="dark"] .tab-button {
      color: var(--gray-500);
    }
    
    [data-theme="dark"] .tab-button:hover {
      color: var(--gray-300);
      background: var(--gray-200);
    }
    
    [data-theme="dark"] .tab-button.tab-active {
      background: var(--gray-100);
      color: var(--primary);
    }

    /* Animations */
    .animate-in {
      animation: fadeIn 0.3s ease-out;
    }

    .animate-out {
      animation: fadeOut 0.3s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }


    /* Checkbox styles */
    .checkbox {
      width: 1rem;
      height: 1rem;
      cursor: pointer;
    }

    .checkbox-sm {
      width: 0.875rem;
      height: 0.875rem;
    }

    /* Form controls */
    .form-control {
      margin-bottom: var(--space-4);
    }

    .label {
      display: block;
      margin-bottom: var(--space-1);
    }

    .label-text {
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--gray-700);
    }

    [data-theme="dark"] .label-text {
      color: var(--gray-300);
    }

    /* Alert */
    .alert {
      padding: var(--space-3) var(--space-4);
      border-radius: var(--radius-sm);
      margin-bottom: var(--space-4);
    }

    .alert-success {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
      border: 1px solid rgba(16, 185, 129, 0.2);
    }

    .alert-error {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
      border: 1px solid rgba(239, 68, 68, 0.2);
    }

    .alert-warning {
      background: rgba(245, 158, 11, 0.1);
      color: var(--warning);
      border: 1px solid rgba(245, 158, 11, 0.2);
    }

    .alert-info {
      background: rgba(37, 99, 235, 0.1);
      color: var(--primary);
      border: 1px solid rgba(37, 99, 235, 0.2);
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 50;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      opacity: 0;
      transition: opacity 0.3s;
    }

    .modal-toggle:checked + .modal {
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 1;
    }

    .modal-box {
      background: white;
      padding: var(--space-6);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      max-width: 32rem;
      width: 91.666667%;
      max-height: calc(100vh - 5em);
      overflow-y: auto;
    }

    [data-theme="dark"] .modal-box {
      background: var(--gray-100);
    }

    .modal-action {
      display: flex;
      justify-content: flex-end;
      gap: var(--space-2);
      margin-top: var(--space-4);
    }

    /* Utility classes */
    .text-primary {
      color: var(--primary);
    }

    .text-success {
      color: var(--success);
    }

    .text-error {
      color: var(--danger);
    }

    .text-warning {
      color: var(--warning);
    }

    .editable-imei {
      cursor: pointer;
      text-decoration: underline;
      text-decoration-style: dotted;
    }

    .editable-imei:hover {
      text-decoration-style: solid;
    }

    /* Toast notification */
    .toast-notification {
      min-width: 250px;
      max-width: 400px;
    }

    /* Responsive */
    @media (max-width: 768px) {
      #mainContent {
        margin-left: 0;
      }
      
      .btn span:not(.badge) {
        display: none;
      }
      
      .section-header {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--space-2);
      }
    }
  </style>

  <!-- Loading Overlay CSS (Updated from BOSS home) -->
  <style>
    .loading-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(255, 255, 255, 0.9);
      display: flex; justify-content: center; align-items: center;
      z-index: 9999;
      backdrop-filter: blur(12px);
    }

    /* Loading spinner for fallback */
    .loading {
      display: inline-block;
      width: 1.5rem;
      height: 1.5rem;
      border: 2px solid #e5e7eb;
      border-radius: 50%;
      border-top-color: #3b82f6;
      animation: spin 0.6s linear infinite;
    }

    .loading-lg {
      width: 2.5rem;
      height: 2.5rem;
    }

    .loading-spinner {
      display: inline-block;
      width: 1.5rem;
      height: 1.5rem;
      border: 2px solid #e5e7eb;
      border-radius: 50%;
      border-top-color: #3b82f6;
      animation: spin 0.6s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>

  <!-- Loading JavaScript (Updated from BOSS home) -->
  <script>
    let lottieAnimation = null;
    let loadingCount = 0; // Track loading state

    // Show/Hide Loading Function with state management
    function showLoading(show) {
      const loader = document.getElementById('loadingOverlay');

      if (show) {
        loadingCount++;
        // Only show if first loading request
        if (loadingCount === 1) {
          loader.style.display = 'flex';
          loader.classList.remove('animate__fadeOut');
          loader.classList.add('animate__fadeIn');

          // โหลดและเล่น Lottie animation
          if (!lottieAnimation) {
            console.log('🔄 Loading Lottie animation from /Loading/Loading.json');
            fetch('/Loading/Loading.json')
              .then(response => {
                if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
              })
              .then(animationData => {
                lottieAnimation = lottie.loadAnimation({
                  container: document.getElementById('lottieContainer'),
                  renderer: 'svg',
                  loop: true,
                  autoplay: true,
                  animationData: animationData
                });

                console.log('✅ Lottie animation loaded successfully');
              })
              .catch(error => {
                console.error('❌ Error loading Lottie animation:', error);
                // Fallback เฉพาะเมื่อ Lottie โหลดไม่สำเร็จ
                document.getElementById('lottieContainer').innerHTML = '<div class="loading loading-spinner loading-lg"></div>';
              });
          } else {
            lottieAnimation.play();
          }
        }
      } else {
        loadingCount--;
        // Only hide when all loading requests are done
        if (loadingCount <= 0) {
          loadingCount = 0; // Reset to prevent negative
          if (lottieAnimation) {
            lottieAnimation.pause();
          }
          loader.classList.remove('animate__fadeIn');
          loader.classList.add('animate__fadeOut');
          setTimeout(() => { loader.style.display = 'none'; }, 600);
        }
      }
    }

    // Auto cleanup เมื่อออกจากหน้า
    window.addEventListener('beforeunload', () => {
      if (lottieAnimation) {
        lottieAnimation.destroy();
        lottieAnimation = null;
      }
    });
  </script>


  <!-- Firebase v9 SDK -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
    import { getDatabase, ref, onValue, set, push, serverTimestamp, onDisconnect, get, update, remove } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js';
    
    // Firebase configuration - using correct project
    const firebaseConfig = {
      apiKey: "AIzaSyCv4EBbKN8Kr4IMRqszJGBWTSoMihtYLo0",
      authDomain: "pheenongacc.firebaseapp.com",
      databaseURL: "https://pheenongacc-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "pheenongacc",
      storageBucket: "pheenongacc.appspot.com",
      messagingSenderId: "917944021415",
      appId: "1:917944021415:web:8c8b3d42e52a1dc8c2f0b5",
      measurementId: "G-94BG9ECQTZ"
    };
    
    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);
    
    // Make database available globally
    window.firebaseDatabase = database;
    window.firebaseRef = ref;
    window.firebaseOnValue = onValue;
    window.firebaseSet = set;
    window.firebasePush = push;
    window.firebaseServerTimestamp = serverTimestamp;
    window.firebaseOnDisconnect = onDisconnect;
    window.firebaseGet = get;
    window.firebaseUpdate = update;
    window.firebaseRemove = remove;
    
    console.log('Firebase initialized successfully for Add New Product');
  </script>

  <!-- Socket.IO and Real-time Integration -->
  <script>
    // Initialize Socket.IO connection for Add New Product page
    let firebaseSessionId = null;
    let addProductSocket = null;
    
    function initializeAddProductSocket() {
      if (!window.socketIOAvailable || typeof io === 'undefined') {
        console.warn('Socket.IO not available, skipping real-time features');
        return;
      }
      
      // Use existing socket or create new one if not exists
      if (!socket) {
        try {
          socket = io({
            transports: ['websocket', 'polling'],
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            timeout: 20000
          });
        } catch (error) {
          console.error('Failed to create socket:', error);
          return;
        }
      }
      
      // Make socket globally available
      addProductSocket = socket;
      window.addProductSocket = socket;
      
      // Set up additional event listeners for add product features
      socket.off('connect.addProduct'); // Remove any existing listeners
      socket.on('connect', function addProductConnect() {
        console.log('Socket.IO connected for Add New Product');
        
        // Join add product room
        const branchCode = getCurrentBranchCode();
        socket.emit('join-room', {
          room: `add-product-${branchCode}`,
          userId: localStorage.getItem('userId'),
          userName: localStorage.getItem('userName'),
          userRole: localStorage.getItem('userRole')
        });
        
        // Create Firebase session
        createAddProductSession();
      });
      
      // Product-specific events
      socket.on('product-added', (data) => {
        if (data.userId !== localStorage.getItem('userId')) {
          console.log('New product added by another user:', data);
          showNotification(`📦 ${data.userName} เพิ่มสินค้าใหม่: ${data.productName}`, 'info');
        }
      });
      
      socket.on('stock-sent-for-approval', (data) => {
        if (data.userId !== localStorage.getItem('userId')) {
          console.log('Stock sent for approval:', data);
          showNotification(`📋 ${data.userName} ส่งสินค้าเข้าระบบอนุมัติ`, 'info');
        }
      });
      
      socket.on('branch-stock-updated', (data) => {
        console.log('Branch stock updated:', data);
        showNotification(`📊 ข้อมูล Branch Stock ถูกอัพเดท`, 'info');
      });
      
      // User activity events
      socket.on('user-joined-add-product', (data) => {
        console.log('User joined add product:', data);
        updateOnlineUsers();
      });
      
      socket.on('user-left-add-product', (data) => {
        console.log('User left add product:', data);
        updateOnlineUsers();
      });
    }
    
    // Get current branch code
    function getCurrentBranchCode() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('branch') || localStorage.getItem('activeBranch') || 'PATTANI';
    }
    
    // Show notification function (fallback if notification system not loaded)
    function showNotification(message, type = 'info', duration = 3000) {
      if (typeof window.NotificationManager !== 'undefined') {
        window.NotificationManager.show(message, type, duration);
      } else {
        // Fallback to console
        console.log(`${type.toUpperCase()}: ${message}`);
      }
    }
  </script>

</head>

<body class="flex flex-col min-h-screen">
  <!-- Loading Overlay (Updated from BOSS home) -->
  <div id="loadingOverlay" class="loading-overlay animate__animated animate__fadeOut" style="display: none;">
    <div class="text-center">
      <div id="lottieContainer" class="w-96 h-96 mx-auto flex items-center justify-center"></div>
    </div>
  </div>

    </div>
  
  <!-- Sidebar Container -->
  <div id="sidebarContainer"></div>

  <div class="flex min-h-screen">
    <!-- Main Content -->
    <div class="flex-1 flex flex-col ml-56" id="mainContent">
      <!-- Header -->
      <header class="p-4 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between"
                       id="mainHeader">
        <div>
          <h1 class="text-lg font-semibold" id="pageTitle">คลังสินค้า</h1>
          <p class="text-sm text-gray-600 dark:text-gray-300" id="branchInfo">
            กำลังโหลดสาขา...
          </p>
        </div>

        <!-- Modular Notifications -->
        <div class="flex items-center gap-4">
          <!-- POS Notification Bell -->
          <div class="notification-bell pos-module" id="posNotificationBell">
            <button class="notification-toggle" title="แจ้งเตือน POS">
              <i class="bi bi-bell"></i>
              <span class="notification-badge" id="posNotificationCount">0</span>
            </button>
            
            <!-- Dropdown Notifications -->
            <div class="notification-dropdown" id="posNotificationDropdown">
              <div class="notification-header">
                <h3><i class="bi bi-shop-window"></i> แจ้งเตือน POS</h3>
                <div class="notification-actions">
                  <button class="mark-all-read" onclick="markAllAsRead('pos')">
                    <i class="bi bi-check-all"></i>
                  </button>
                  <button class="clear-all" onclick="clearAllNotifications('pos')">
                    <i class="bi bi-trash"></i>
                  </button>
                </div>
              </div>
              <div class="notification-list" id="posNotificationList">
                <!-- Notifications will be inserted here -->
              </div>
            </div>
          </div>
        </div>
      </header>

      <!-- Toast Notification Container for POS Module -->
      <div id="posToastContainer" class="toast-container pos-module"></div>

      <!-- Branch Selection & Barcode Scanner -->
      <div class="card animate-in mb-6 p-6">
        <div class="section-header">
          <h2 class="section-title">
            <i class="bi bi-building text-primary"></i>
            เลือกสาขา &amp; สแกนบาร์โค้ด (เพิ่มได้หลายชิ้น)
          </h2>
        </div>
        
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <!-- Branch Select -->
          <div>
            <label for="branchSelect" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              สาขา
            </label>
            <select id="branchSelect" class="input" disabled>
              <option value="">กำลังโหลด...</option>
            </select>
          </div>
          
          <!-- Manual Barcode Entry -->
          <div>
            <label for="manualBarcode" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              กรอกเลขบาร์โค้ด / IMEI / Serial Number
            </label>
            <div class="flex gap-2">
              <input 
                type="text" 
                id="manualBarcode" 
                class="input flex-1" 
                placeholder="พิมพ์เลขบาร์โค้ด แล้วกด Enter เพื่อเพิ่มต่อเนื่อง..." 
              />
              <button id="btnAddManualCode" class="btn btn-primary">
                <i class="bi bi-plus-circle"></i>
                <span class="hidden sm:inline">เพิ่ม</span>
              </button>
              <button id="btnToggleContinuous" class="btn btn-outline" title="เปิด/ปิดโหมดเพิ่มต่อเนื่อง">
                <i class="bi bi-arrow-repeat"></i>
                <span class="hidden sm:inline">ต่อเนื่อง</span>
              </button>
            </div>
            <div class="flex items-center justify-between mt-1">
              <p class="text-xs text-gray-500">
                <i class="bi bi-info-circle"></i> สินค้าจะเพิ่มเข้ารายการ "รออนุมัติ" ทันที
              </p>
              <div class="flex items-center gap-2">
                <label class="flex items-center gap-1 text-xs">
                  <input type="checkbox" id="continuousMode" class="checkbox checkbox-sm">
                  <span class="text-gray-600">โหมดต่อเนื่อง</span>
                </label>
              </div>
            </div>
          </div>
          
          <!-- Scan Button -->
          <div>
            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              สแกนอัตโนมัติ
            </label>
            <div class="flex gap-2">
              <button id="btnScanBarcode" class="btn btn-primary flex-1">
                <i class="bi bi-upc-scan"></i>
                สแกนบาร์โค้ด
              </button>
              <button id="btnBatchScan" class="btn btn-success" title="สแกนหลายชิ้นต่อเนื่อง">
                <i class="bi bi-collection"></i>
                <span class="hidden sm:inline">สแกนต่อเนื่อง</span>
              </button>
            </div>
            <p class="text-xs text-gray-500 mt-1">
              <i class="bi bi-lightbulb"></i> สแกนหลายชิ้นต่อเนื่อง เพื่อเพิ่มประสิทธิภาพ
            </p>
          </div>
        </div>
        
        <!-- Enhanced Scan Status -->
        <div id="scanStatus" class="mt-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg hidden">
          <div class="flex items-center justify-between">
            <div class="flex items-center gap-2 text-sm">
              <div class="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>
              <span class="text-blue-700 dark:text-blue-300" id="scanStatusText">
                กำลังรอการสแกนบาร์โค้ด...
              </span>
            </div>
            <div class="flex items-center gap-2 text-xs">
              <span id="scanCounter" class="text-blue-600 font-medium">เพิ่มแล้ว: 0 ชิ้น</span>
              <button id="btnStopScanning" class="btn btn-sm btn-error">
                <i class="bi bi-stop-circle"></i> หยุด
              </button>
            </div>
          </div>
          <div id="scanProgress" class="mt-2 hidden">
            <div class="w-full bg-gray-200 rounded-full h-2">
              <div id="scanProgressBar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
          </div>
        </div>

        <!-- Recent Additions Preview -->
        <div id="recentAdditions" class="mt-4 hidden">
          <div class="flex items-center justify-between mb-2">
            <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300">
              <i class="bi bi-clock-history mr-1"></i>สินค้าที่เพิ่มล่าสุด
            </h4>
            <button id="btnClearRecent" class="btn btn-xs btn-ghost">
              <i class="bi bi-x"></i> ล้าง
            </button>
          </div>
          <div id="recentList" class="max-h-32 overflow-y-auto space-y-1">
            <!-- Recent items will be added here -->
          </div>
        </div>
      </div>

      <!-- Stock List -->
      <div class="card animate-in p-6">
        <div class="section-header mb-6">
          <h2 class="section-title">
            <i class="bi bi-box-seam text-primary"></i>
            รายการสต๊อก
            <span class="badge badge-info">
              <span id="stockCount">0</span> รายการ
            </span>
          </h2>
        </div>
        
        <!-- Tab Navigation -->
        <div class="flex gap-1 p-1 bg-gray-100 dark:bg-gray-700 rounded-lg mb-6">
          <button 
            class="flex-1 flex items-center justify-center gap-2 px-4 py-2 rounded-md font-medium text-sm transition-all duration-200 tab-button tab-active"
            id="tab-unverified"
          >
            <i class="bi bi-clock-history"></i>
            <span>รออนุมัติ</span>
            <span class="badge badge-warning" id="unverifiedCount">0</span>
          </button>
          <button 
            class="flex-1 flex items-center justify-center gap-2 px-4 py-2 rounded-md font-medium text-sm transition-all duration-200 tab-button"
            id="tab-verified"
          >
            <i class="bi bi-check-circle"></i>
            <span>อนุมัติแล้ว</span>
            <span class="badge badge-success" id="verifiedCount">0</span>
          </button>
        </div>
        
        <!-- Tab Content: รออนุมัติ -->
        <div id="content-unverified">
          <!-- คำอธิบาย Workflow -->
          <div class="alert alert-info mb-4">
            <i class="bi bi-info-circle-fill"></i>
            <span>
              <strong>ขั้นตอนการทำงาน:</strong>
              <ol class="ml-4 mt-1 text-sm">
                <li>1. Scan/กรอกบาร์โค้ด → สินค้าจะเข้าสู่รายการ "รออนุมัติ" ทันที</li>
                <li>2. เลือกสินค้าที่ต้องการส่งไปยังฝ่ายสต็อก</li>
                <li>3. กด "ส่งไปยังฝ่ายสต็อก" เพื่อส่งสินค้าที่เลือก</li>
                <li>4. ฝ่ายสต็อกจะเห็นสินค้าในหน้า "ตรวจสินค้า/อนุมัติ"</li>
              </ol>
              <div class="mt-2 text-xs text-blue-600">
                <i class="bi bi-lightbulb"></i> 
                <strong>หมายเหตุ:</strong> รายการ "รออนุมัติ" จะแสดงสินค้าทั้งหมดที่ยังไม่ได้ส่งไปยังฝ่ายสต็อก รวมถึงสินค้าที่ backend ตั้งสถานะ pending อัตโนมัติ
              </div>
            </span>
          </div>
          
          <!-- เพิ่มปุ่มส่งไปยังฝ่ายสต็อก -->
          <div class="flex justify-between items-center mb-6 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
            <div class="flex gap-3">
              <button id="btnSelectAll" class="btn btn-primary btn-sm">
                <i class="bi bi-check2-all"></i> เลือกทั้งหมด
              </button>
              <button id="btnDeselectAll" class="btn btn-outline btn-sm">
                <i class="bi bi-x-lg"></i> ยกเลิกเลือกทั้งหมด
              </button>
              <button id="btnManualReload" class="btn btn-warning btn-sm">
                <i class="bi bi-arrow-clockwise"></i> รีเฟรช
              </button>
            </div>
            <div class="flex items-center gap-3">
              <span class="text-sm text-gray-600 dark:text-gray-400">
                เลือกแล้ว: <span class="font-bold text-primary-600" id="selectedCount">0</span> รายการ
              </span>
              <button id="btnSendToStock" class="btn btn-success">
                <i class="bi bi-send-fill"></i> ส่งไปยังฝ่ายสต็อก
              </button>
            </div>
          </div>
          
          <div id="stockContainer">
            <!-- Content will be populated by JavaScript -->
          </div>
        </div>
        
        <!-- Tab Content: อนุมัติแล้ว -->
        <div id="content-verified" class="hidden">
          <!-- Filter ช่วงวันที่ -->
          <div class="flex gap-4 mb-4">
            <div class="form-control">
              <label class="label">
                <span class="label-text">วันที่เริ่มต้น</span>
              </label>
              <input type="date" id="dateFrom" class="input input-bordered" />
            </div>
            <div class="form-control">
              <label class="label">
                <span class="label-text">วันที่สิ้นสุด</span>
              </label>
              <input type="date" id="dateTo" class="input input-bordered" />
            </div>
            <div class="form-control">
              <label class="label">
                <span class="label-text">&nbsp;</span>
              </label>
              <button class="btn btn-primary" id="btnLoadVerifiedHistory">
                <i class="bi bi-search"></i> ค้นหา
              </button>
            </div>
          </div>
          
          <div id="verifiedContainer">
            <!-- Content will be populated by JavaScript -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <footer class="mt-4 text-center">
    <small>© 2025 บริษัท 2 พี่น้อง โมบาย จำกัด. สงวนลิขสิทธิ์.</small>
  </footer>

  <!-- Modals -->
  <input type="checkbox" id="confirmActionModal" class="modal-toggle" />
  <div class="modal">
    <div class="modal-box">
      <h3 class="font-bold text-lg">ยืนยันการกระทำ</h3>
      <p class="py-4" id="confirmActionText">ข้อความที่นี่</p>
      <div class="modal-action">
        <label for="confirmActionModal" class="btn btn-secondary" id="cancelActionBtn">ยกเลิก</label>
        <label for="confirmActionModal" class="btn btn-primary" id="okActionBtn">ตกลง</label>
      </div>
    </div>
  </div>

  <!-- Hidden barcode input -->
  <input type="text" id="barcodeInput" autofocus lang="en" inputmode="latin" autocomplete="off" autocorrect="off" autocapitalize="off" style="ime-mode: disabled; display:none;" />

        <p class="text-sm font-medium" id="loadingText">กำลังประมวลผล...</p>
    </div>
  </div>

  <!-- 
    Barcode Modal - Not used anymore since products are added directly to pending list
  -->

  <script type="text/javascript">
    //<![CDATA[
    // URL Parameters and Constants
    const urlParams = new URLSearchParams(window.location.search);
    let BRANCH_CODE = urlParams.get("branch") || localStorage.getItem('activeBranch');

    if (!BRANCH_CODE) {
      console.warn("Branch not found in URL or localStorage, defaulting to 'PATTANI'");
      BRANCH_CODE = 'PATTANI';
    }
    window.currentBranchCode = BRANCH_CODE;
    console.log(`[addNewProduct] Using branch code: ${BRANCH_CODE}`);
    
    // Initialize Sidebar Component
    let sidebar;
    
    // ==================== LOGGING SYSTEM ====================
    
    const Logger = {
      levels: {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3
      },
      currentLevel: 1, // Default to INFO in production
      
      log: function(level, message, data = null) {
        if (level < this.currentLevel) return;
        
        const timestamp = new Date().toISOString();
        const levelName = Object.keys(this.levels).find(key => this.levels[key] === level);
        
        const logEntry = {
          timestamp,
          level: levelName,
          message,
          data,
          url: window.location.href,
          userAgent: navigator.userAgent
        };
        
        // Console output
        if (level === this.levels.ERROR) {
          console.error(`[${levelName}] ${message}`, data);
        } else if (level === this.levels.WARN) {
          console.warn(`[${levelName}] ${message}`, data);
        } else if (window.location.hostname === 'localhost' || this.currentLevel === 0) {
          console.log(`[${levelName}] ${message}`, data);
        }
        
        // Store in localStorage for debugging
        if (level >= this.levels.WARN) {
          this.storeLog(logEntry);
        }
      },
      
      storeLog: function(logEntry) {
        try {
          const logs = JSON.parse(localStorage.getItem('appLogs') || '[]');
          logs.push(logEntry);
          // Keep only last 100 logs
          localStorage.setItem('appLogs', JSON.stringify(logs.slice(-100)));
        } catch (e) {
          // Ignore storage errors
        }
      },
      
      debug: function(message, data) {
        this.log(this.levels.DEBUG, message, data);
      },
      
      info: function(message, data) {
        this.log(this.levels.INFO, message, data);
      },
      
      warn: function(message, data) {
        this.log(this.levels.WARN, message, data);
      },
      
      error: function(message, data) {
        this.log(this.levels.ERROR, message, data);
      },
      
      setLevel: function(level) {
        this.currentLevel = this.levels[level] || this.levels.INFO;
      },
      
      getLogs: function() {
        return JSON.parse(localStorage.getItem('appLogs') || '[]');
      },
      
      clearLogs: function() {
        localStorage.removeItem('appLogs');
      }
    };
    
    // Set debug level for development - REMOVED a problematic check
    // This will default Logger level to INFO
    
    // ==================== END LOGGING SYSTEM ====================

    // Socket.IO initialization with error handling
    let socket = null;
    
    function initializeSocket() {
      // Check if Socket.IO is available
      if (typeof io === 'undefined' || !window.socketIOAvailable) {
        Logger.warn("Socket.IO library not available, continuing without real-time features");
        console.warn("⚠️ Socket.IO not available, app will work without real-time updates");
        return;
      }
      
      try {
        socket = io({
          timeout: 5000,
          transports: ['websocket', 'polling'],
          upgrade: true,
          reconnection: true,
          reconnectionAttempts: 3,
          reconnectionDelay: 1000,
          forceNew: true
        });
        
        socket.on('connect', () => {
          Logger.info("เชื่อมต่อ realtime สำเร็จ");
          console.log("✅ Socket.IO connected successfully");
        });
        
        socket.on('connect_error', (error) => {
          Logger.warn("Socket.IO connection error:", error.message);
          console.warn("⚠️ Socket.IO connection failed:", error.message, "- app will continue working without real-time updates");
        });
        
        socket.on('disconnect', (reason) => {
          Logger.info("Socket.IO disconnected:", reason);
          console.log("🔌 Socket.IO disconnected:", reason);
        });
        
        socket.on('stockUpdate', () => {
          Logger.debug("ได้รับสัญญาณ update สต๊อกแบบ realtime");
          loadStock();
        });
        
        socket.on('branchStockUpdated', () => {
          Logger.debug("ได้รับสัญญาณ branchStock updated");
          loadStock();
        });
        
        socket.on('branchstockCreated', () => {
          Logger.debug("ได้รับสัญญาณ branchStock created");
          loadStock();
        });
        
        socket.on('branchstockDeleted', () => {
          Logger.debug("ได้รับสัญญาณ branchStock deleted");
          loadStock();
        });
        
      } catch (socketError) {
        Logger.error("Failed to initialize Socket.IO:", socketError);
        console.warn("⚠️ Socket.IO initialization failed:", socketError.message, "- continuing without real-time features");
        socket = null;
      }
    }
    
    // Initialize socket with delay to ensure DOM is ready
    setTimeout(() => {
      initializeSocket();
    }, 1000);

    // Global variables
    let scannedProducts = [];
    let allProductImages = [];
    let pendingAction = null;
    let selectedStocks = new Set();
    let defaultSupplier = null;

    // Global notification system instance
    let posNotificationSystem = null;
    
    // Enhanced variables for multi-item support
    let isContinuousMode = false;
    let isBatchScanning = false;
    let scanCounter = 0;
    let recentAdditions = [];
    let scanningTimeout = null;
    let autoRefreshInterval = null;

    // ==================== SECURITY & VALIDATION ====================
    
    // CSRF Token generation and management
    function generateCSRFToken() {
      const array = new Uint8Array(32);
      crypto.getRandomValues(array);
      const token = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
      localStorage.setItem('csrfToken', token);
      document.querySelector('meta[name="csrf-token"]').content = token;
      return token;
    }
    
    // Initialize CSRF token on page load
    if (!localStorage.getItem('csrfToken')) {
      generateCSRFToken();
    }
    
    // Input validation functions
    const ValidationRules = {
      barcode: {
        pattern: /^.+$/, // ยอมรับทุกอักขระอย่างน้อย 1 ตัว
        message: 'กรุณากรอกบาร์โค้ด'
      },
      imei: {
        pattern: /^[0-9A-Za-z]{10,20}$/, // รองรับตัวเลขและตัวอักษร 10-20 หลัก
        message: 'หมายเลขต้องเป็นตัวเลขหรือตัวอักษร 10-20 หลัก'
      }
    };

    // Validate barcode format
    function validateBarcode(barcode) {
      if (!barcode) return { valid: false, message: 'กรุณากรอกบาร์โค้ด' };
      
      barcode = barcode.trim();
      
      // ตรวจสอบความยาวขั้นต่ำ
      if (barcode.length < 1) {
        return { valid: false, message: 'บาร์โค้ดต้องมีอย่างน้อย 1 ตัวอักษร' };
      }
      
      // ไม่จำกัดประเภทหรือความยาวของบาร์โค้ด
      return { valid: true };
    }

    // Enhanced IMEI validation with flexibility
    function validateIMEI(imei) {
      if (!imei) return { valid: false, message: 'กรุณากรอก IMEI' };
      
      imei = imei.trim();
      
      // ตรวจสอบเฉพาะความยาวและเป็นตัวเลข (ยืดหยุ่นขึ้น)
      if (imei.length < 10 || imei.length > 20) {
        return { valid: false, message: 'หมายเลขต้องมีความยาว 10-20 หลัก' };
      }
      
      // ตรวจสอบว่าเป็นตัวเลขหรือมีตัวอักษรปนได้
      if (!/^[0-9A-Za-z]+$/.test(imei)) {
        return { valid: false, message: 'หมายเลขสามารถเป็นตัวเลขหรือตัวอักษรได้' };
      }
      
      // ไม่ใช้ Luhn algorithm check เพื่อความยืดหยุ่น
      // เพราะบางอุปกรณ์ใช้ Serial Number หรือ IMEI ที่ไม่ตรงมาตรฐาน
      
      return { valid: true };
    }

    // Sanitize HTML to prevent XSS
    function sanitizeHTML(str) {
      if (!str) return '';
      const temp = document.createElement('div');
      temp.textContent = str;
      return temp.innerHTML;
    }

    // Enhanced Rate limiting with different limits per action
    const RateLimiter = {
      attempts: {},
      limits: {
        'scan_barcode': { max: 20, window: 60000 },      // 20 per minute
        'manual_barcode': { max: 10, window: 60000 },    // 10 per minute
        'api_call': { max: 30, window: 60000 },          // 30 per minute
        'delete_action': { max: 5, window: 60000 },      // 5 per minute
        'update_action': { max: 15, window: 60000 }      // 15 per minute
      },
      
      check: function(action) {
        const now = Date.now();
        const userId = localStorage.getItem('userId') || 'anonymous';
        const key = `${action}_${userId}`;
        const limit = this.limits[action] || { max: 30, window: 60000 };
        
        if (!this.attempts[key]) {
          this.attempts[key] = { count: 0, resetTime: now + limit.window };
        }
        
        if (now > this.attempts[key].resetTime) {
          this.attempts[key] = { count: 0, resetTime: now + limit.window };
        }
        
        if (this.attempts[key].count >= limit.max) {
          const waitTime = Math.ceil((this.attempts[key].resetTime - now) / 1000);
          showToast(`คุณทำรายการเร็วเกินไป กรุณารอ ${waitTime} วินาที`, 'warning');
          
          // Log rate limit exceeded
          createAuditLog('RATE_LIMIT_EXCEEDED', {
            action: action,
            userId: userId,
            attempts: this.attempts[key].count,
            resetTime: new Date(this.attempts[key].resetTime).toISOString()
          });
          
          return false;
        }
        
        this.attempts[key].count++;
        return true;
      },
      
      reset: function(action) {
        const userId = localStorage.getItem('userId') || 'anonymous';
        const key = `${action}_${userId}`;
        delete this.attempts[key];
      }
    };

    // Enhanced Session timeout management
    let sessionTimeout;
    let warningTimeout;
    let lastActivity = Date.now();
    const SESSION_TIMEOUT = 15 * 60 * 1000; // 15 minutes
    const WARNING_TIME = 2 * 60 * 1000;     // Warning at 2 minutes before timeout

    function resetSessionTimeout() {
      lastActivity = Date.now();
      clearTimeout(sessionTimeout);
      clearTimeout(warningTimeout);
      
      // Set warning timeout
      warningTimeout = setTimeout(() => {
        showToast('เซสชันจะหมดอายุใน 2 นาที กรุณาบันทึกข้อมูล', 'warning');
      }, SESSION_TIMEOUT - WARNING_TIME);
      
      // Set session timeout
      sessionTimeout = setTimeout(() => {
        showToast('เซสชันหมดอายุ กำลังออกจากระบบ...', 'error');
        createAuditLog('SESSION_TIMEOUT', {
          lastActivity: new Date(lastActivity).toISOString(),
          sessionDuration: Date.now() - lastActivity
        });
        setTimeout(() => {
          logout();
        }, 2000);
      }, SESSION_TIMEOUT);
    }

    // Logout function
    async function logout() {
      try {
        // Create audit log before logout
        await createAuditLog('USER_LOGOUT', {
          logoutType: 'manual',
          sessionDuration: Date.now() - lastActivity
        });
        
        // Clear all sensitive data
        localStorage.removeItem('authToken');
        localStorage.removeItem('userId');
        localStorage.removeItem('csrfToken');
        localStorage.removeItem('branchCode');
        
        // Clear session storage
        sessionStorage.clear();
        
        // Disconnect socket (ถ้ามี)
        try {
          if (socket && socket.connected) {
            socket.disconnect();
          }
        } catch (socketDisconnectError) {
          Logger.warn("Failed to disconnect socket:", socketDisconnectError);
        }
        
        // Redirect to login
        window.location.href = '/login';
      } catch (err) {
        console.error('Logout error:', err);
        // Force redirect even if audit log fails
        window.location.href = '/login';
      }
    }

    // Track user activity with debounce
    let activityDebounce;
    function trackActivity() {
      clearTimeout(activityDebounce);
      activityDebounce = setTimeout(() => {
        resetSessionTimeout();
      }, 1000);
    }

    document.addEventListener('click', trackActivity);
    document.addEventListener('keypress', trackActivity);
    document.addEventListener('mousemove', trackActivity);
    document.addEventListener('scroll', trackActivity);

    // CSRF Token management
    function getCSRFToken() {
      return localStorage.getItem('csrfToken') || generateCSRFToken();
    }

    // Enhanced fetch with CSRF token and retry logic
    async function secureFetch(url, options = {}) {
      // Rate limit check for API calls
      if (!RateLimiter.check('api_call')) {
        throw new Error('Rate limit exceeded');
      }
      
      const token = localStorage.getItem('authToken');
      const csrfToken = getCSRFToken();
      
      if (!token) {
        throw new Error('No auth token found');
      }
      
      const headers = {
        'Authorization': 'Bearer ' + token,
        'X-CSRF-Token': csrfToken,
        'X-Request-ID': generateRequestId(),
        ...options.headers
      };
      
      // Add loading state
      showLoadingState(true);
      
      try {
        const response = await fetch(url, { 
          ...options, 
          headers,
          credentials: 'same-origin'
        });
        
        // Check if token expired
        if (response.status === 401) {
          await createAuditLog('TOKEN_EXPIRED', {
            url: url,
            method: options.method || 'GET'
          });
          logout();
          throw new Error('Authentication expired');
        }
        
        // Check CSRF token mismatch
        if (response.status === 403 && response.headers.get('X-CSRF-Error')) {
          generateCSRFToken();
          throw new Error('CSRF token mismatch, please retry');
        }
        
        return response;
      } finally {
        showLoadingState(false);
      }
    }

    // Generate unique request ID for tracking
    function generateRequestId() {
      return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }

    // Show/hide loading state (disabled to prevent multiple loadings)
    function showLoadingState(show) {
      console.log('showLoadingState called but disabled:', show);
      // Don't call showLoading to prevent multiple loading displays
    }

    // Safe loading functions for backward compatibility - use separate simple loading
    function safeShowLoading(options = {}) {
      console.log('safeShowLoading called with:', options);
      return 'loading_' + Date.now(); // Return fake ID for compatibility
    }

    function safeHideLoading(id) {
      console.log('safeHideLoading called with ID:', id);
      return true;
    }

    // Enhanced button loading function for compatibility
    function enhanceButtonWithLoading(button, options = {}) {
      if (!button) return;

      console.log('enhanceButtonWithLoading called for button:', button.id || 'unnamed', 'with options:', options);

      // Store original button properties
      const originalText = button.innerHTML;
      const originalDisabled = button.disabled;

      // Add loading method to button
      button.showLoading = function(message = 'กำลังดำเนินการ...') {
        this.disabled = true;
        this.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>${message}`;
      };

      // Add success method to button
      button.showSuccess = function(message = options.successMessage || 'สำเร็จ') {
        this.innerHTML = `<i class="fas fa-check mr-2"></i>${message}`;
        setTimeout(() => {
          this.innerHTML = originalText;
          this.disabled = originalDisabled;
        }, 2000);
      };

      // Add error method to button
      button.showError = function(message = options.errorMessage || 'เกิดข้อผิดพลาด') {
        this.innerHTML = `<i class="fas fa-times mr-2"></i>${message}`;
        this.disabled = originalDisabled;
        setTimeout(() => {
          this.innerHTML = originalText;
        }, 3000);
      };

      // Add reset method to button
      button.resetLoading = function() {
        this.innerHTML = originalText;
        this.disabled = originalDisabled;
      };

      return button;
    }

    function safeUpdateMessage(id, message, subMessage = null) {
      console.log('safeUpdateMessage called:', message, subMessage);
      return true; // Just log for compatibility
    }

    function safeUpdateProgress(id, percentage) {
      console.log('safeUpdateProgress called:', percentage + '%');
      return true; // Just log for compatibility
    }
    
    // ==================== END SECURITY & VALIDATION ====================

    // ==================== AUDIT LOG SYSTEM ====================
    
    // Enhanced audit logging function with IP and device tracking
    async function createAuditLog(action, details) {
      // TEMPORARILY DISABLE AUDIT LOGGING DUE TO BACKEND ISSUES
      console.log('Audit log disabled:', action, details);
      return;
    }

    // Determine severity level based on action type
    function getSeverityLevel(action) {
      const highSeverity = ['DELETE', 'LOGIN_FAILED', 'UNAUTHORIZED_ACCESS', 'RATE_LIMIT_EXCEEDED', 'TOKEN_EXPIRED'];
      const mediumSeverity = ['UPDATE', 'CREATE', 'APPROVE', 'REJECT', 'SEND_TO_STOCK'];
      const lowSeverity = ['VIEW', 'SEARCH', 'SCAN', 'TAB_SWITCH'];
      
      if (highSeverity.some(a => action.includes(a))) return 'HIGH';
      if (mediumSeverity.some(a => action.includes(a))) return 'MEDIUM';
      if (lowSeverity.some(a => action.includes(a))) return 'LOW';
      return 'INFO';
    }

    // Retry failed audit logs
    async function retryFailedAuditLogs() {
      const failedLogs = JSON.parse(localStorage.getItem('failedAuditLogs') || '[]');
      if (failedLogs.length === 0) return;
      
      const token = localStorage.getItem('authToken');
      if (!token) return;
      
      Logger.info(`Retrying ${failedLogs.length} failed audit logs...`);
      
      for (const log of failedLogs) {
        try {
          const response = await fetch('/api/audit/log', {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + token,
              'X-CSRF-Token': getCSRFToken()
            },
            body: JSON.stringify(log)
          });
          
          if (response.ok) {
            // Remove successful log
            const remaining = JSON.parse(localStorage.getItem('failedAuditLogs') || '[]');
            const filtered = remaining.filter(l => l.timestamp !== log.timestamp);
            localStorage.setItem('failedAuditLogs', JSON.stringify(filtered));
          }
        } catch (err) {
          console.error('Retry audit log failed:', err);
        }
      }
    }

    // Get detailed device information
    function getDeviceInfo() {
      const ua = navigator.userAgent;
      const parser = new UAParser(ua);
      const result = parser.getResult();
      
      return {
        userAgent: ua,
        browser: {
          name: result.browser.name || 'Unknown',
          version: result.browser.version || 'Unknown',
          major: result.browser.major || 'Unknown'
        },
        os: {
          name: result.os.name || 'Unknown',
          version: result.os.version || 'Unknown'
        },
        device: {
          type: result.device.type || 'desktop',
          vendor: result.device.vendor || 'Unknown',
          model: result.device.model || 'Unknown'
        },
        screen: {
          width: window.screen.width,
          height: window.screen.height,
          pixelRatio: window.devicePixelRatio || 1
        },
        viewport: {
          width: window.innerWidth,
          height: window.innerHeight
        },
        language: navigator.language || 'Unknown',
        platform: navigator.platform || 'Unknown',
        cookieEnabled: navigator.cookieEnabled,
        onLine: navigator.onLine,
        doNotTrack: navigator.doNotTrack || 'Unknown'
      };
    }

    // Get location info (requires user permission)
    async function getLocationInfo() {
      try {
        if ('geolocation' in navigator) {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              timeout: 5000,
              maximumAge: 300000 // 5 minutes cache
            });
          });
          
          return {
            location: {
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              accuracy: position.coords.accuracy
            }
          };
        }
      } catch (err) {
        // User denied location or error occurred
        Logger.debug('Location not available:', err.message);
      }
      
      return { location: null };
    }

    // Simple UA Parser (embedded to avoid external dependency)
    class UAParser {
      constructor(ua) {
        this.ua = ua.toLowerCase();
      }
      
      getResult() {
        return {
          browser: this.getBrowser(),
          os: this.getOS(),
          device: this.getDevice()
        };
      }
      
      getBrowser() {
        const browsers = [
          { name: 'Chrome', pattern: /chrome\/(\d+)\.(\d+)/ },
          { name: 'Firefox', pattern: /firefox\/(\d+)\.(\d+)/ },
          { name: 'Safari', pattern: /version\/(\d+)\.(\d+).*safari/ },
          { name: 'Edge', pattern: /edg\/(\d+)\.(\d+)/ },
          { name: 'Opera', pattern: /opr\/(\d+)\.(\d+)/ }
        ];
        
        for (const browser of browsers) {
          const match = this.ua.match(browser.pattern);
          if (match) {
            return {
              name: browser.name,
              version: `${match[1]}.${match[2]}`,
              major: match[1]
            };
          }
        }
        
        return { name: 'Unknown', version: 'Unknown', major: 'Unknown' };
      }
      
      getOS() {
        const systems = [
          { name: 'Windows 11', pattern: /windows nt 10\.0.*win64/ },
          { name: 'Windows 10', pattern: /windows nt 10\.0/ },
          { name: 'Windows 8.1', pattern: /windows nt 6\.3/ },
          { name: 'Windows 8', pattern: /windows nt 6\.2/ },
          { name: 'Windows 7', pattern: /windows nt 6\.1/ },
          { name: 'macOS', pattern: /mac os x (\d+)[._](\d+)/ },
          { name: 'iOS', pattern: /iphone.*os (\d+)[._](\d+)/ },
          { name: 'Android', pattern: /android (\d+)\.(\d+)/ },
          { name: 'Linux', pattern: /linux/ }
        ];
        
        for (const os of systems) {
          const match = this.ua.match(os.pattern);
          if (match) {
            const version = match[1] ? `${match[1]}.${match[2] || 0}` : 'Unknown';
            return { name: os.name, version };
          }
        }
        
        return { name: 'Unknown', version: 'Unknown' };
      }
      
      getDevice() {
        if (/mobile/i.test(this.ua)) {
          return { type: 'mobile' };
        } else if (/tablet|ipad/i.test(this.ua)) {
          return { type: 'tablet' };
        }
        return { type: 'desktop' };
      }
    }

    // ==================== END AUDIT LOG SYSTEM ====================

    // ==================== UTILITY FUNCTIONS ====================
    
    // Toast notification function
    function showToast(message, type = 'info') {
      // Remove existing toasts
      const existingToasts = document.querySelectorAll('.toast-notification');
      existingToasts.forEach(toast => toast.remove());
      
      const toast = document.createElement('div');
      toast.className = `toast-notification alert alert-${type === 'success' ? 'success' : type === 'error' ? 'error' : type === 'warning' ? 'warning' : 'info'} fixed top-4 right-4 z-50 max-w-sm shadow-lg animate-in`;
      
      const icon = type === 'success' ? 'bi-check-circle-fill' : type === 'error' ? 'bi-x-circle-fill' : type === 'warning' ? 'bi-exclamation-triangle-fill' : 'bi-info-circle-fill';
      
      toast.innerHTML = `
        <div class="flex items-center gap-3">
          <i class="bi ${icon} text-xl"></i>
          <span>${message}</span>
          <button onclick="this.parentElement.parentElement.remove()" class="btn btn-sm btn-ghost">
            <i class="bi bi-x"></i>
          </button>
        </div>
      `;
      
      document.body.appendChild(toast);
      
      // Auto remove after 5 seconds
      setTimeout(() => {
        toast.classList.add('animate-out');
        setTimeout(() => toast.remove(), 300);
      }, 5000);
    }

    // Get current user info with caching
    async function getCurrentUserInfo() {
      try {
        const token = localStorage.getItem('authToken');
        if (!token) return { userId: null, userName: '', role: null, branch: null };
        
        // Check if cached user info is still valid
        const cachedUser = sessionStorage.getItem('currentUser');
        if (cachedUser) {
          const userData = JSON.parse(cachedUser);
          // Cache for 5 minutes
          if (Date.now() - userData.cachedAt < 5 * 60 * 1000) {
            return userData;
          }
        }
        
        const res = await fetch('/api/users/me', {
          headers: { 'Authorization': 'Bearer ' + token }
        });
        const result = await res.json();
        
        if (!res.ok || !result.success) {
          throw new Error(result.message || 'ไม่สามารถโหลดข้อมูลผู้ใช้ได้');
        }
        
        if (result.data) {
          const userInfo = { 
            userId: result.data._id, 
            userName: result.data.name,
            role: result.data.role,
            branch: result.data.branch,
            permissions: result.data.allowedPages || [],
            cachedAt: Date.now()
          };
          
          // Cache user info
          sessionStorage.setItem('currentUser', JSON.stringify(userInfo));
          localStorage.setItem('userId', result.data._id);
          
          return userInfo;
        }
        
        return { userId: null, userName: '', role: null, branch: null };
      } catch (err) {
        Logger.error('Error getting user info:', err);
        return { userId: null, userName: '', role: null, branch: null };
      }
    }

    // ==================== END UTILITY FUNCTIONS ====================

    // ==================== API FUNCTIONS ====================
    
    // Load product images
    async function loadProductImages() {
      try {
        const res = await secureFetch('/api/product-image');
        const result = await res.json();
        
        if (!res.ok || result.status !== 'success') {
          throw new Error(result.message || 'ไม่สามารถโหลดรูปภาพสินค้าได้');
        }
        
        allProductImages = result.data || [];
        Logger.debug('Product images loaded:', allProductImages.length);
      } catch (err) {
        Logger.error('Error loadProductImages:', err);
        showToast('ไม่สามารถโหลดรูปภาพสินค้าได้: ' + err.message, 'error');
      }
    }
    
    // Load suppliers with enhanced validation
    async function loadSuppliers() {
      try {
        const res = await secureFetch('/api/supplier');
        const data = await res.json();
        console.log('📡 Suppliers API Response:', data);
        
        if (!res.ok || !data.success) {
          throw new Error(data.error || 'ไม่สามารถโหลด suppliers');
        }
        
        if (data.data && data.data.length > 0) {
          // ใช้ supplier แรกเป็น default และเก็บข้อมูลไว้สำหรับใช้ในการ fallback
          defaultSupplier = data.data[0];
          Logger.info('Default supplier set:', defaultSupplier.name);
          console.log('✅ Default supplier loaded:', defaultSupplier);
          
          // เก็บรายการ supplier ทั้งหมดไว้สำหรับการใช้ fallback
          window.availableSuppliers = data.data;
          console.log('📋 Available suppliers:', data.data.map(s => s.name));
        } else {
          Logger.warn('No suppliers found in system');
          console.warn('⚠️ No suppliers found, using fallback');
          // ใช้ fallback supplier
          defaultSupplier = {
            name: 'ไม่ระบุ',
            _id: 'default'
          };
          window.availableSuppliers = [defaultSupplier];
        }
      } catch (err) {
        Logger.error('Error loading suppliers:', err);
        console.error('❌ Error loading suppliers:', err);
        // ใช้ fallback supplier
        defaultSupplier = {
          name: 'ไม่ระบุ',
          _id: 'default'
        };
        window.availableSuppliers = [defaultSupplier];
      }
    }

    // Load branch info
    async function loadBranchInfo() {
      try {
        const branchCode = BRANCH_CODE;
        const token = localStorage.getItem("authToken") || "";
        
        // เรียก /api/branch เพื่อดึง list สาขา
        const res = await fetch(`/api/branch`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        const js = await res.json();
        if (res.ok && js.success) {
          // หา record ที่ตรงกับ branch_code
          const branch = js.data.find(b => b.branch_code === branchCode);
          if (branch) {
            document.getElementById("branchInfo").textContent =
              `${branch.name} - ${branch.address}`;
            // อัพเดท title ของหน้าด้วยชื่อสาขาจริง
            document.title = `คลังสินค้า - ${branch.name}`;
            document.getElementById("pageTitle").textContent = `คลังสินค้า - ${branch.name}`;
            return;
          }
        }
        throw new Error("ไม่พบข้อมูลสาขา");
      } catch (err) {
        Logger.warn("loadBranchInfo error:", err);
        document.getElementById("branchInfo").textContent =
          "สาขา: (ไม่พบข้อมูล)";
      }
    }

    // Load branches
    async function loadBranches() {
      try {
        const res = await secureFetch('/api/branch', {
          headers: {
            'Content-Type': 'application/json'
          }
        });
        const data = await res.json();
        if (!res.ok || !data.success) {
          throw new Error(data.error || 'ไม่สามารถโหลดสาขา');
        }
        
        // Audit log for branch access
        createAuditLog('VIEW_BRANCHES', {
          branchCount: data.data.length
        });
        
        const branchSelect = document.getElementById('branchSelect');
        branchSelect.innerHTML = '';
        
        // อ่าน branch code จาก URL parameter
        const branchFromUrl = BRANCH_CODE;
        
        const ptnBranches = data.data.filter(b => b.branch_code === branchFromUrl);
        
        // อัพเดท title ของหน้า
        if (ptnBranches.length > 0 && urlParams.get('name')) {
          document.title = `คลังสินค้า - ${decodeURIComponent(urlParams.get('name'))}`;
        }
        
        if (ptnBranches.length === 0) {
          branchSelect.innerHTML = '<option value="">ไม่พบสาขา</option>';
          showToast('ไม่พบสาขา ' + branchFromUrl, 'error');
          
          // Audit log for branch not found
          createAuditLog('BRANCH_NOT_FOUND', {
            requestedBranch: branchFromUrl
          });
          return;
        }
        
        ptnBranches.forEach(b => {
          const opt = document.createElement('option');
          opt.value = b.branch_code;
          opt.textContent = `[${b.branch_code}] ${b.name}`;
          branchSelect.appendChild(opt);
        });
        
        // Set value to BRANCH_CODE
        branchSelect.value = BRANCH_CODE;
        console.log('✅ Branch select value set to:', BRANCH_CODE);
        
        branchSelect.disabled = true;
        loadStock();
      } catch (err) {
        showToast('Error loading branches: ' + err.message, 'error');
        
        // Audit log for error
        createAuditLog('ERROR_LOADING_BRANCHES', {
          error: err.message
        });
      }
    }

    // Load stock data with enhanced auto-refresh
    async function loadStock() {
      const branchSelect = document.getElementById('branchSelect');
      console.log('🔍 Branch select element:', branchSelect);
      console.log('🔍 Branch select value:', branchSelect?.value);
      console.log('🔍 Branch select disabled:', branchSelect?.disabled);
      
      const branchId = branchSelect?.value || BRANCH_CODE;
      if (!branchId) {
        Logger.warn('No branch selected, cannot load stock');
        return;
      }
      
      Logger.info('Loading stock for branch:', branchId);
      console.log('🔍 Loading stock for branch:', branchId);

      // Start auto-refresh if not in batch scanning mode
      if (!isBatchScanning && !autoRefreshInterval) {
        autoRefreshInterval = setInterval(() => {
          if (!isBatchScanning) {
            refreshStockTable();
          }
        }, 15000); // Refresh every 15 seconds
      }

      try {
        // Audit log for stock loading
        createAuditLog('VIEW_STOCK', {
          branch: branchId,
          action: 'load_stock_list'
        });
        
        // โหลดข้อมูลทั้งหมด ไม่ filter อะไรเลย
        const url = `/api/branch-stock?branch_code=${branchId}&include_unverified=1&include_all=1&_=${new Date().getTime()}`;
        Logger.info('Loading stock from:', url);
        console.log('📡 API URL (include all):', url);
        console.log('📍 Branch ID being used:', branchId);
        
        const res = await secureFetch(url);
        const result = await res.json();
        
        Logger.info('API Response:', {
          success: result.success,
          dataLength: result.data ? result.data.length : 0
        });
        
        console.log('📦 API Response:', {
          success: result.success,
          dataLength: result.data ? result.data.length : 0
        });
        
        // แสดง raw response data
        console.log('📋 Raw API Response Data:', result);
        
        if (!res.ok || !result.success) {
          Logger.error('Load stock error:', result);
          console.error('❌ Load stock error:', result);
          showToast('โหลดสต๊อกไม่สำเร็จ: ' + (result.error || 'Unknown error'), 'error');
          
          // Audit log for error
          createAuditLog('ERROR_LOADING_STOCK', {
            branch: branchId,
            error: result.error || 'Unknown error'
          });
          return;
        }

        const rawStocks = result.data || [];
        Logger.info('Total stocks loaded:', rawStocks.length);
        console.log('📊 Total stocks:', rawStocks.length);
        
        // Debug: แสดงข้อมูลทั้งหมดที่ได้จาก API
        console.log('🔍 ALL Stocks from API:', rawStocks);
        
        // Debug: แสดง iPhone stocks โดยเฉพาะ
        const iPhoneStocks = rawStocks.filter(s => s.name && s.name.toLowerCase().includes('iphone'));
        console.log('📱 iPhone stocks found:', iPhoneStocks.length);
        if (iPhoneStocks.length > 0) {
          console.log('📱 iPhone stock details:');
          iPhoneStocks.forEach((stock, i) => {
            console.log(`  ${i+1}. ${stock.name}`);
            console.log(`     - Barcode: ${stock.barcode}`);
            console.log(`     - IMEI: ${stock.imei}`);
            console.log(`     - Branch: ${stock.branch_code}`);
            console.log(`     - Verified: ${stock.verified}`);
            console.log(`     - Sent to stock: ${stock.sent_to_stock}`);
            console.log(`     - Created: ${stock.created_at}`);
          });
        }
        
        // ตรวจสอบ stock ที่มี pending = false
        const falseStocks = rawStocks.filter(s => s.pending === false);
        console.log('📌 Stocks with pending=false:', falseStocks.length, falseStocks);
        
        // ตรวจสอบ stock ที่ไม่มี pending field
        const noPendingStocks = rawStocks.filter(s => s.pending === undefined);
        console.log('📌 Stocks with no pending field:', noPendingStocks.length, noPendingStocks);
        
        // Debug: แสดงข้อมูลดิบเพื่อตรวจสอบ
        if (rawStocks.length > 0) {
          Logger.debug('Sample stock data:', rawStocks[0]);
          console.log('📋 First stock item:', rawStocks[0]);
          
          // แสดง 5 รายการแรก
          console.log('📋 First 5 stocks:');
          rawStocks.slice(0, 5).forEach((stock, i) => {
            console.log(`${i+1}. ${stock.name} - Status: pending=${stock.pending}, verified=${stock.verified}, sent_to_stock=${stock.sent_to_stock}, branch=${stock.branch_code}`);
          });
        }

        // Debug เพิ่มเติม - แสดงสต๊อกที่ branch_code ตรงกับที่เลือก
        const currentBranch = document.getElementById('branchSelect').value;
        console.log('🏢 Current branch:', currentBranch);
        const branchStocks = rawStocks.filter(s => s.branch_code === currentBranch);
        console.log(`📊 Stocks for branch ${currentBranch}:`, branchStocks.length);
        
        if (branchStocks.length > 0) {
          console.log('📋 Branch stocks sample:', branchStocks.slice(0, 3));
        }

        // --- NEW FILTERING LOGIC ---
        // "รออนุมัติ" tab contains all items that are NOT yet verified.
        // "อนุมัติแล้ว" tab contains all items that ARE verified.
        const unverifiedStocks = rawStocks.filter(s => s.verified !== true);
        const verifiedStocks = rawStocks.filter(s => s.verified === true);

        Logger.info('Stock counts - Unverified:', unverifiedStocks.length, 'Verified:', verifiedStocks.length);
        console.log('📊 Stock breakdown:');
        console.log('  - Unverified (รออนุมัติ):', unverifiedStocks.length);
        console.log('  - Verified (อนุมัติแล้ว):', verifiedStocks.length);
        
        // Debug: แสดง unverified stocks
        if (unverifiedStocks.length > 0) {
          console.log('🔍 Unverified stocks details:');
          unverifiedStocks.forEach((stock, i) => {
            console.log(`  ${i+1}. ${stock.name} - ${stock.barcode} - ${stock.imei}`);
          });
        }
        
        // อัพเดท counts
        document.getElementById('unverifiedCount').textContent = unverifiedStocks.length;
        document.getElementById('verifiedCount').textContent = verifiedStocks.length;
        document.getElementById('stockCount').textContent = rawStocks.length;

        // ตรวจสอบ container ก่อน render
        const stockContainer = document.getElementById('stockContainer');
        const verifiedContainer = document.getElementById('verifiedContainer');
        
        console.log('🎯 Containers found:', {
          stockContainer: !!stockContainer,
          verifiedContainer: !!verifiedContainer
        });

        // แสดงข้อมูลตาม tab ที่เลือก
        const activeTab = document.querySelector('.tab-active');
        console.log('🏷️ Active tab:', activeTab ? activeTab.id : 'none');
        
        if (activeTab && activeTab.id === 'tab-unverified') {
          console.log('📝 Rendering unverified tab with', unverifiedStocks.length, 'items...');
          renderUnverifiedStocks(unverifiedStocks);
        } else if (activeTab && activeTab.id === 'tab-verified') {
          console.log('📝 Rendering verified tab...');
          // แสดง verified stocks ที่โหลดมาแล้ว
          renderVerifiedHistory(verifiedStocks);
        }
      } catch (err) {
        Logger.error('Error loading stock:', err);
        console.error('❌ Error loading stock:', err);
        showToast('เกิดข้อผิดพลาดในการโหลดข้อมูล: ' + err.message, 'error');
        
        // Audit log for error
        createAuditLog('ERROR_LOADING_STOCK', {
          branch: branchId,
          error: err.message
        });
      }
    }

    // Get stock info by ID
    async function getStockInfo(stockId) {
      try {
        const res = await secureFetch(`/api/branch-stock/${stockId}`);
        const data = await res.json();
        return data.success ? data.data : null;
      } catch (err) {
        Logger.error('Error getting stock info:', err);
        return null;
      }
    }

    // ==================== END API FUNCTIONS ====================

    // ==================== RENDERING FUNCTIONS ====================
    
    // Sanitize HTML to prevent XSS
    function sanitizeHTML(str) {
      if (!str) return '';
      const temp = document.createElement('div');
      temp.textContent = str;
      return temp.innerHTML;
    }
    
    // Group stock by brand
    function groupStockByBrand(stocks) {
      const map = {};
      stocks.forEach(stock => {
        const brand = stock.brand || 'ไม่ระบุแบรนด์';
        if (!map[brand]) map[brand] = [];
        map[brand].push(stock);
      });
      return map;
    }

    // Render unverified stocks (สินค้ารออนุมัติ)
    function renderUnverifiedStocks(unverifiedArray) {
      Logger.info('Rendering unverified stocks:', unverifiedArray.length);
      console.log('🎨 Starting renderUnverifiedStocks with', unverifiedArray.length, 'items');
      
      try {
        const container = document.getElementById("stockContainer");
        if (!container) {
          Logger.error('stockContainer element not found!');
          console.error('❌ stockContainer element not found!');
          return;
        }
        
        console.log('📦 Container found:', container);
        container.innerHTML = '';
        
        if (unverifiedArray.length === 0) {
          container.innerHTML = `
            <div class="text-center py-8 text-gray-500">
              <i class="bi bi-inbox text-4xl mb-2 block"></i>
              ไม่มีสินค้ารออนุมัติ
            </div>`;
          return;
        }
        
        const grouped = groupStockByBrand(unverifiedArray);
        console.log('🏷️ Grouped by brand:', Object.keys(grouped));
        
        Object.keys(grouped).forEach(brand => {
          console.log(`🏭 Rendering brand: ${brand}`);
          const items = grouped[brand];
          const brandSection = document.createElement("div");
          brandSection.className = "mb-6 p-4 bg-white dark:bg-gray-800 rounded-lg shadow";
          
          const hdr = document.createElement("h5");
          hdr.className = "section-title mb-3 flex items-center justify-between text-lg font-semibold";
          
          // Calculate latest addition time for this brand
          const latestItem = items.reduce((latest, item) => {
            const itemTime = new Date(item.created_at);
            return itemTime > new Date(latest.created_at) ? item : latest;
          }, items[0]);
          
          const timeAgo = getTimeAgo(new Date(latestItem.created_at));
          
          hdr.innerHTML = `
            <div class="flex items-center gap-2">
              <i class="bi bi-box-seam-fill text-blue-500"></i> 
              ${brand} (${items.length} รายการ)
            </div>
            <div class="text-sm font-normal text-gray-500">
              <i class="bi bi-clock"></i> ล่าสุด: ${timeAgo}
            </div>
          `;
          brandSection.appendChild(hdr);
          
          const tblWrap = document.createElement("div");
          tblWrap.className = "overflow-x-auto";
          tblWrap.innerHTML = `
            <table class="table table-zebra w-full">
              <thead class="bg-gray-100 dark:bg-gray-700">
                <tr>
                  <th class="p-3 text-center w-16">
                    <input type="checkbox" class="checkbox checkbox-sm brand-checkbox" data-brand="${brand}">
                  </th>
                  <th class="p-3 text-center">บาร์โค้ด</th>
                  <th class="p-3">ชื่อสินค้า</th>
                  <th class="p-3 text-center">IMEI</th>
                  <th class="p-3 text-center">สถานะ</th>
                  <th class="p-3 text-center">Actions</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>`;
          brandSection.appendChild(tblWrap);
          
          const tbody = tblWrap.querySelector("tbody");
          items.forEach((stock, index) => {
            console.log(`  📝 Rendering item ${index + 1}:`, stock.name);
            try {
              let imeiDisplay = '';
              const stockType = stock.stockType || stock.product_id?.stockType || 'imei';
              
              if (stockType === 'quantity') {
                imeiDisplay = '<span class="badge badge-info">ไม่ใช้ IMEI</span>';
              } else if (stock.imei && stock.imei.trim() !== '') {
                imeiDisplay = `<span class="text-green-600 dark:text-green-400">${stock.imei || ''}</span>`;
              } else {
                imeiDisplay = '<span class="text-orange-600 dark:text-orange-400">ยังไม่ได้กรอก</span>';
              }
              
              let statusBadge = '';
              let isCheckboxDisabled = false;
              if (stock.sent_to_stock === true) {
                statusBadge = '<span class="badge badge-warning"><i class="bi bi-clock-history mr-1"></i>รอฝ่ายสต็อกอนุมัติ</span>';
                isCheckboxDisabled = true;
              } else {
                statusBadge = '<span class="badge badge-info"><i class="bi bi-send mr-1"></i>พร้อมส่ง</span>';
                isCheckboxDisabled = false;
              }
              
              const tr = document.createElement("tr");
              tr.innerHTML = `
                <td class="p-3 text-center">
                  <input type="checkbox" class="checkbox checkbox-sm stock-checkbox" 
                         data-stock-id="${stock._id}" 
                         data-brand="${brand}" ${isCheckboxDisabled ? 'disabled' : ''}>
                </td>
                <td class="p-3 text-center">${stock.barcode || "-"}</td>
                <td class="p-3">${stock.name || "-"}</td>
                <td class="p-3 text-center">${imeiDisplay}</td>
                <td class="p-3 text-center">${statusBadge}</td>
                <td class="p-3 text-center">
                  <button class="btn btn-sm btn-error remove-stock-button" data-stock-id="${stock._id}">
                    <i class="bi bi-trash"></i> ลบ
                  </button>
                </td>`;
              tbody.appendChild(tr);
            } catch (itemErr) {
              console.error(`❌ Error rendering item ${index}:`, itemErr, stock);
            }
          });
          
          container.appendChild(brandSection);
          console.log(`✅ Brand ${brand} rendered successfully`);
        });
        
        setupCheckboxListeners();
        selectedStocks.clear();
        updateSelectedCount();
        console.log('✅ renderUnverifiedStocks completed successfully');
        
      } catch (err) {
        console.error('❌ Error in renderUnverifiedStocks:', err);
        console.error('Stack trace:', err.stack);
        showToast('เกิดข้อผิดพลาดในการแสดงข้อมูล: ' + err.message, 'error');
      }
    }

    // Render verified history
    function renderVerifiedHistory(stocks) {
      const container = document.getElementById('verifiedContainer');
      container.innerHTML = '';
      
      if (stocks.length === 0) {
        container.innerHTML = '<div class="text-center text-gray-500 py-8">ไม่พบสินค้าอนุมัติ</div>';
        return;
      }
      
      const grouped = groupStockByBrand(stocks);
      
      Object.keys(grouped).forEach(brand => {
        const items = grouped[brand];
        const brandSection = document.createElement("div");
        brandSection.className = "mb-6 p-4 bg-white dark:bg-gray-800 rounded-lg shadow";
        
        const hdr = document.createElement("h5");
        hdr.className = "section-title mb-3 flex items-center gap-2 text-lg font-semibold";
        hdr.innerHTML = `<i class="bi bi-box-seam-fill text-blue-500"></i> ${brand} (${items.length} รายการ)`;
        brandSection.appendChild(hdr);
        
        const tblWrap = document.createElement("div");
        tblWrap.className = "overflow-x-auto";
        tblWrap.innerHTML = `
          <table class="table table-zebra w-full">
            <thead class="bg-gray-100 dark:bg-gray-700">
              <tr>
                <th class="p-3 text-center w-16">
                  <input type="checkbox" class="checkbox checkbox-sm brand-checkbox" data-brand="${brand}">
                </th>
                <th class="p-3 text-center">บาร์โค้ด</th>
                <th class="p-3">ชื่อสินค้า</th>
                <th class="p-3 text-center">IMEI</th>
                <th class="p-3 text-center">สถานะ</th>
                <th class="p-3 text-center">Actions</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>`;
        brandSection.appendChild(tblWrap);
        
        const tbody = tblWrap.querySelector("tbody");
        items.forEach(stock => {
          let imeiDisplay = '';
          const stockType = stock.stockType || stock.product_id?.stockType || 'imei';
          
          if (stockType === 'quantity') {
            imeiDisplay = '<span class="badge badge-info">ไม่ใช้ IMEI</span>';
          } else if (stock.imei && stock.imei.trim() !== '') {
            imeiDisplay = `<span class="text-green-600 dark:text-green-400">${sanitizeHTML(stock.imei)}</span>`;
          } else {
            imeiDisplay = '<span class="text-orange-600 dark:text-orange-400">ยังไม่ได้กรอก</span>';
          }
          
          let statusBadge = '';
          let isCheckboxDisabled = false;
          if (stock.sent_to_stock === true) {
            statusBadge = '<span class="badge badge-warning"><i class="bi bi-clock-history mr-1"></i>รอฝ่ายสต็อกอนุมัติ</span>';
            isCheckboxDisabled = true;
          } else {
            statusBadge = '<span class="badge badge-info"><i class="bi bi-send mr-1"></i>พร้อมส่ง</span>';
            isCheckboxDisabled = false;
          }
          
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td class="p-3 text-center">
              <input type="checkbox" class="checkbox checkbox-sm stock-checkbox" 
                     data-stock-id="${stock._id}" 
                     data-brand="${brand}" ${isCheckboxDisabled ? 'disabled' : ''}>
            </td>
            <td class="p-3 text-center">${sanitizeHTML(stock.barcode||"-")}</td>
            <td class="p-3">${sanitizeHTML(stock.name||"-")}</td>
            <td class="p-3 text-center">${imeiDisplay}</td>
            <td class="p-3 text-center">${statusBadge}</td>
            <td class="p-3 text-center">
              <button class="btn btn-sm btn-error remove-stock-button" data-stock-id="${stock._id}">
                <i class="bi bi-trash"></i> ลบ
              </button>
            </td>`;
          tbody.appendChild(tr);
        });
        
        container.appendChild(brandSection);
      });
      
      setupCheckboxListeners();
      selectedStocks.clear();
      updateSelectedCount();
    }

    // ==================== END RENDERING FUNCTIONS ====================

    // Load verified history
    async function loadVerifiedHistory() {
      try {
        Logger.info('Loading verified history...');
        
        const branchId = document.getElementById('branchSelect')?.value || BRANCH_CODE;
        if (!branchId || branchId === 'all') {
          Logger.warn('No specific branch selected for verified history');
          const container = document.getElementById('verifiedContainer');
          if (container) {
            container.innerHTML = '<div class="text-center text-gray-500 py-8">กรุณาเลือกสาขา</div>';
          }
          return;
        }
        
        // Get date range
        const dateFrom = document.getElementById('dateFrom')?.value;
        const dateTo = document.getElementById('dateTo')?.value;
        
        if (!dateFrom || !dateTo) {
          showToast('กรุณาเลือกช่วงวันที่', 'warning');
          return;
        }
        
        // Build URL with date filters
        let url = `/api/branch-stock?branch_code=${branchId}&verified=true`;
        
        // Add date filters
        if (dateFrom) {
          url += `&date_from=${dateFrom}`;
        }
        if (dateTo) {
          // Add 1 day to include the entire end date
          const endDate = new Date(dateTo);
          endDate.setDate(endDate.getDate() + 1);
          url += `&date_to=${endDate.toISOString().split('T')[0]}`;
        }
        
        Logger.info('Loading verified stocks from:', url);
        
        const res = await secureFetch(url);
        const result = await res.json();
        
        if (!res.ok || !result.success) {
          throw new Error(result.error || 'โหลดประวัติไม่สำเร็จ');
        }
        
        const verifiedStocks = result.data || [];
        Logger.info('Verified stocks loaded:', verifiedStocks.length);
        
        // Filter only verified stocks
        const filteredVerifiedStocks = verifiedStocks.filter(s => s.verified === true);
        
        // Use existing renderVerifiedHistory function
        renderVerifiedHistory(filteredVerifiedStocks);
        
        // Update count
        document.getElementById('verifiedCount').textContent = filteredVerifiedStocks.length;
        
        // Audit log
        createAuditLog('VIEW_VERIFIED_HISTORY', {
          branch: branchId,
          dateFrom: dateFrom,
          dateTo: dateTo,
          recordCount: filteredVerifiedStocks.length
        });
        
      } catch (err) {
        Logger.error('Error loading verified history:', err);
        showToast('เกิดข้อผิดพลาดในการโหลดประวัติ: ' + err.message, 'error');
        const container = document.getElementById('verifiedContainer');
        if (container) {
          container.innerHTML = '<div class="text-center text-gray-500 py-8">เกิดข้อผิดพลาดในการโหลดข้อมูล</div>';
        }
        
        // Audit log for error
        createAuditLog('ERROR_LOADING_VERIFIED_HISTORY', {
          error: err.message
        });
      }
    }

    // ==================== STOCK MANAGEMENT FUNCTIONS ====================
    
    // Approve pending stock
    async function approvePending(stockId) {
      try {
        // Rate limit check
        if (!RateLimiter.check('update_action')) return;
        
        // ดึงข้อมูลผู้ใช้
        const userInfo = await getCurrentUserInfo();
        const userId = userInfo.userId;
        const userName = userInfo.userName;

        // Get stock info for audit
        const stockInfo = await getStockInfo(stockId);

        const res = await secureFetch(`/api/branch-stock/${stockId}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            pending: false,
            verified: true,
            verified_by: userId,
            verified_by_name: userName,
            verified_at: new Date().toISOString()
          })
        });
        const data = await res.json();
        if (!res.ok || !data.success) {
          throw new Error(data.error || 'อนุมัติไม่สำเร็จ');
        }
        
        // Audit log for approval
        createAuditLog('APPROVE_STOCK', {
          resourceId: stockId,
          resourceName: stockInfo?.name || 'Unknown',

          imei: stockInfo?.imei,
          branch: document.getElementById('branchSelect').value,
          approvedBy: userName
        });
        
        showToast('อนุมัติเรียบร้อย', 'success');
        loadStock();
      } catch (err) {
        showToast('Error approving: ' + err.message, 'error');
        
        // Audit log for error
        createAuditLog('ERROR_APPROVE_STOCK', {
          resourceId: stockId,
          error: err.message
        });
      }
    }

    // Reject pending stock
    async function rejectPending(stockId) {
      customConfirm('ยืนยันการปฏิเสธรายการนี้?', async () => {
        try {
          // Rate limit check
          if (!RateLimiter.check('delete_action')) return;
          
          // Get stock info for audit
          const stockInfo = await getStockInfo(stockId);
          
          const res = await secureFetch(`/api/branch-stock/${stockId}`, {
            method: 'DELETE'
          });
          const data = await res.json();
          if (!res.ok || !data.success) {
            throw new Error(data.error || 'ปฏิเสธไม่สำเร็จ');
          }
          
          // Audit log for rejection
          createAuditLog('REJECT_STOCK', {
            resourceId: stockId,
            resourceName: stockInfo?.name || 'Unknown',
  
            imei: stockInfo?.imei,
            branch: document.getElementById('branchSelect').value,
            reason: 'Rejected from pending list'
          });
          
          showToast('ปฏิเสธและลบรายการเรียบร้อย', 'success');
          loadStock();
        } catch (err) {
          showToast('Error rejecting: ' + err.message, 'error');
          
          // Audit log for error
          createAuditLog('ERROR_REJECT_STOCK', {
            resourceId: stockId,
            error: err.message
          });
        }
      });
    }

    // Remove stock
    async function removeStock(stockId, showAlert = true) {
      try {
        // Get stock info for audit log
        const stockInfo = await getStockInfo(stockId);
        
        const res = await secureFetch(`/api/branch-stock/${stockId}`, {
          method: 'DELETE'
        });
        
        const data = await res.json();
        if (!res.ok || !data.success) {
          throw new Error(data.error || 'ลบสต๊อกไม่สำเร็จ');
        }
        
        // Audit log
        createAuditLog('DELETE_STOCK', {
          resourceId: stockId,
          resourceName: stockInfo?.name || 'Unknown',

          imei: stockInfo?.imei,
          branch: document.getElementById('branchSelect').value,
          reason: 'Manual deletion'
        });
        
        if (showAlert) showToast('ลบสต๊อกเรียบร้อย', 'success');

        // POS Notification - Item removed
        if (posNotificationSystem && showAlert) {
          posNotificationSystem.showToast('pos', {
            title: 'ลบสินค้าแล้ว',
            message: `ลบ ${stockInfo?.name || 'สินค้า'} ออกจากระบบแล้ว`,
            type: 'warning',
            icon: '🗑️'
          });
          
          posNotificationSystem.addNotification('pos', {
            title: 'ลบสินค้าออกจากระบบ',
            message: `${stockInfo?.name || 'ไม่ทราบชื่อ'} (${stockInfo?.barcode || ''})`,
            type: 'warning',
            icon: '🗂️',
            metadata: {
              productName: stockInfo?.name,
    
              barcode: stockInfo?.barcode,
              reason: 'Manual deletion',
              timestamp: new Date().toLocaleString('th-TH')
            }
          });
        }

        loadStock();
      } catch (err) {
        if (showAlert) showToast('Error removing stock: ' + err.message, 'error');
        else throw err;
      }
    }

    // ==================== END STOCK MANAGEMENT FUNCTIONS ====================

    // ==================== EVENT HANDLERS ====================
    
    // Enhanced barcode scan handler with multi-item support
    async function handleBarcodeScan(barcode, options = {}) {
      Logger.debug('Scanned barcode:', barcode);
      
      if (!barcode || barcode.trim() === '') {
        showToast('กรุณากรอกบาร์โค้ด', 'warning');
        return false;
      }
      
      if (!RateLimiter.check('scan_barcode')) return false;
      const validation = validateBarcode(barcode);
      if (!validation.valid) {
        showToast(validation.message, 'error');
        return false;
      }
      
      barcode = barcode.trim();
      
      // แสดงสถานะกำลังประมวลผล
      if (!isBatchScanning) showLoadingState(true);
      
      try {
        const res = await secureFetch(`/api/product/find-by-barcode?code=${barcode}`);
        const result = await res.json();
        
        if (!res.ok || !result.success) {
          showToast('ไม่พบข้อมูลสินค้าสำหรับบาร์โค้ดนี้', 'error');
          return false;
        }
        
        const product = result.data;
        const stockType = product.stockType || 'imei';
        let imeiValue = '';
        let barcodeValue = barcode;

        console.log(`🔍 Product stockType: ${stockType}`);

        // จัดการตามประเภทสินค้า
        if (stockType === 'imei') {
            // สินค้าประเภท IMEI - ใช้ barcode เป็น IMEI
            const imeiValidation = validateIMEI(barcode);
            if (!imeiValidation.valid) {
                showToast(`หมายเลข IMEI (${barcode}) ไม่ถูกต้อง: ${imeiValidation.message}`, 'error');
                return { success: false, error: 'invalid_imei', message: imeiValidation.message };
            }
            imeiValue = barcode;
            barcodeValue = barcode;
            console.log(`✅ ยอมรับหมายเลข IMEI: ${barcode} สำหรับสินค้า ${product.name}`);
        } else if (stockType === 'quantity') {
            // สินค้าประเภท quantity - ไม่ใช้ IMEI
            imeiValue = ''; // ไม่มี IMEI
            barcodeValue = barcode;
            console.log(`✅ ยอมรับบาร์โค้ด: ${barcode} สำหรับสินค้าประเภทจำนวน ${product.name}`);
        } else {
            // Default fallback
            console.log(`⚠️ ประเภทสินค้าไม่ชัดเจน (${stockType}), ใช้เป็น quantity`);
            imeiValue = '';
            barcodeValue = barcode;
        }
        
        const branchCode = document.getElementById('branchSelect')?.value || BRANCH_CODE;
        console.log(`🔍 Checking for duplicate products with values:`, { barcodeValue, imeiValue, stockType, branchCode });
        
        const duplicateCheck = await validateDuplicateProducts(barcodeValue, imeiValue, stockType, branchCode);
        console.log(`🔍 Duplicate check result:`, duplicateCheck);
        
        if (duplicateCheck.isDuplicate) {
          console.warn('❌ Duplicate product found:', duplicateCheck);
          
          if (!isBatchScanning) {
            showDuplicateAlert(duplicateCheck);
          } else {
            addToRecentList(barcode, product.name, 'duplicate', 'พบสินค้าซ้ำ');
          }

          // POS Notification - Duplicate detected
          if (posNotificationSystem) {
            if (!isBatchScanning) {
              posNotificationSystem.showToast('pos', {
                title: 'พบสินค้าซ้ำ',
                message: `${product.name} มีอยู่ในระบบแล้ว`,
                type: 'warning',
                icon: '⚠️',
                duration: 5000
              });
            }
            
            posNotificationSystem.addNotification('pos', {
              title: 'ตรวจพบสินค้าซ้ำ',
              message: `${product.name} (${barcode}) มีอยู่ในระบบแล้ว`,
              type: 'warning',
              icon: '🔍',
              metadata: {
                productName: product.name,
                barcode: barcode,
                source: duplicateCheck.source,
                timestamp: new Date().toLocaleString('th-TH')
              }
            });
          }

          return { success: false, error: 'duplicate_product', details: duplicateCheck };
        }
        
        const userInfo = await getCurrentUserInfo();
        console.log('🔍 User info:', userInfo);
        
        // ใช้ supplier name ที่มีอยู่จริงในระบบ - ลองทั้งแบบ trim และไม่ trim
        let supplierName = 'ไม่ระบุ';
        if (defaultSupplier && defaultSupplier.name) {
          supplierName = defaultSupplier.name; // ใช้ original name ตรงตามที่มีใน database
        }
        console.log('🔍 Default supplier object:', defaultSupplier);
        console.log('🔍 Supplier name to use:', `"${supplierName}"`);
        
        // ใช้ supplier จริงที่มีอยู่ในระบบ แทนที่จะ force fallback
        console.log('🔍 Using actual supplier from system:', supplierName);
        
        const stockData = {
          branch_code: branchCode,
          barcode: barcodeValue,

          imei: imeiValue,
          name: product.name,
          price: product.price || 0,
          brand: product.brand || '',
          model: product.model || '',
          category: product.category || '',
          stockType: stockType,
          supplier: supplierName,
          scanned_by: userInfo.userId,
          scanned_by_name: userInfo.userName,
          updated_by: userInfo.userId,
          stock_value: 0,
          created_at: new Date().toISOString(),
          // 🔥 ข้อมูลเพิ่มเติมจาก Product/PO
          poNumber: product.poNumber || '',
          cost: product.cost || 0,
          taxType: product.taxType || '',
          taxRate: product.taxRate || 0,
          documentNumber: product.documentNumber || '',
          categoryGroup: product.categoryGroup || null,
          invoiceNumber: product.invoiceNumber || ''
        };
        
        console.log('📤 Sending stock data to API:', stockData);
        console.log('📤 Supplier field specifically:', stockData.supplier);

        const createRes = await secureFetch('/api/branch-stock', {
            method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(stockData)
        });
        
        const createResult = await createRes.json();
        console.log('📥 API Response:', { status: createRes.status, result: createResult });
        console.log('📥 Full API Response body:', createResult);
        
        if (!createRes.ok || !createResult.success) {
          console.error('❌ API Error:', createResult);
          
          if (createResult.error && createResult.error.toLowerCase().includes('duplicate')) {
            if (!isBatchScanning) {
              showToast('พบสินค้าซ้ำในระบบ! ' + createResult.error, 'error');
            } else {
              addToRecentList(barcode, product.name, 'duplicate', 'พบสินค้าซ้ำ');
            }
            return { success: false, error: 'duplicate_api', details: createResult };
                    } else if (createResult.error && (createResult.error.includes('ไม่พบ Supplier') || createResult.error.includes('Supplier'))) {
            // ปัญหาเรื่อง supplier - ลองส่งแบบไม่มี supplier หรือใช้ค่า default
            console.warn('⚠️ Supplier issue detected, retrying with fallback supplier...');
            console.warn('⚠️ Original error:', createResult.error);
            
            // ลองใช้ supplier ที่มีอยู่จริงในระบบ - ลองหลายแบบ
            const fallbackStrategies = [];
            
            // ลองใช้ supplier จริงที่มีอยู่ในระบบ (ไม่ trim)
            if (defaultSupplier && defaultSupplier.name) {
              fallbackStrategies.push({ ...stockData, supplier: defaultSupplier.name });
            }
            
            // ลองใช้ supplier จริงแต่ trim ช่องว่าง
            if (defaultSupplier && defaultSupplier.name) {
              fallbackStrategies.push({ ...stockData, supplier: defaultSupplier.name.trim() });
            }
            
            // ลองใช้ supplier อื่นๆ ที่มีอยู่ในระบบทั้งหมด
            if (window.availableSuppliers) {
              for (const supplier of window.availableSuppliers) {
                if (supplier.name && supplier.name !== defaultSupplier?.name) {
                  // ลองทั้งแบบ original และ trim
                  fallbackStrategies.push({ ...stockData, supplier: supplier.name });
                  fallbackStrategies.push({ ...stockData, supplier: supplier.name.trim() });
                }
              }
            }
            
            // ลองใช้ค่าพื้นฐาน
            fallbackStrategies.push(
              { ...stockData, supplier: 'ไม่ระบุ' },
              { ...stockData, supplier: 'Default' },
              { ...stockData, supplier: 'System' },
              { ...stockData, supplier: 'General' },
              // ลองใช้ชื่อสินค้าเป็น supplier (บางระบบใช้วิธีนี้)
              { ...stockData, supplier: product.brand || 'Unknown' },
              // ลองใช้ null หรือ undefined (บางระบบอาจยอมรับได้)
              { ...stockData, supplier: null },
              { ...stockData, supplier: '' }
            );
            
            for (let i = 0; i < fallbackStrategies.length; i++) {
              const fallbackStockData = fallbackStrategies[i];
              console.log(`🔄 Retry attempt ${i + 1} with supplier strategy:`, fallbackStockData.supplier);
              
              try {
                const retryRes = await secureFetch('/api/branch-stock', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(fallbackStockData)
                });
                
                const retryResult = await retryRes.json();
                console.log(`📥 Retry ${i + 1} API Response:`, { status: retryRes.status, result: retryResult });
                
                if (retryRes.ok && retryResult.success) {
                  console.log(`✅ Retry ${i + 1} successful!`);
                  // Continue to success section
                  break;
                } else {
                  console.warn(`❌ Retry ${i + 1} failed:`, retryResult.error);
                  if (i === fallbackStrategies.length - 1) {
                    // Last attempt failed
                    throw new Error('ไม่สามารถสร้างรายการสต็อกได้แม้ใช้ fallback strategies ทั้งหมด');
                  }
                }
                
              } catch (retryError) {
                console.error(`❌ Retry ${i + 1} attempt failed:`, retryError);
                if (i === fallbackStrategies.length - 1) {
                  throw new Error('ไม่สามารถสร้างรายการสต็อกได้: ' + retryError.message);
                }
              }
            }
            
          } else {
            const errorMessage = createResult.error || 'ไม่สามารถสร้างรายการสต็อกได้';
            console.error('❌ Stock creation failed:', errorMessage);
            throw new Error(errorMessage);
          }
        }
        
        // Success - ทำงานส่วนนี้ทั้งกรณี create สำเร็จครั้งแรก และ retry สำเร็จ
        console.log('✅ Stock created successfully!');
        scanCounter++;
        updateScanCounter();
        addToRecentList(barcode, product.name, 'success', 'เพิ่มสำเร็จ');
        
        if (!isBatchScanning) {
          showToast(`เพิ่ม '${product.name}' เข้ารายการรออนุมัติเรียบร้อย`, 'success');
        }

        // POS Notification - Item added successfully
        if (posNotificationSystem) {
          const stockText = stockType === 'imei' ? `IMEI: ${imeiValue}` : 'ประเภทจำนวน';
          
          if (!isBatchScanning) {
            posNotificationSystem.showToast('pos', {
              title: 'เพิ่มสินค้าสำเร็จ',
              message: `${product.name} เข้ารายการรออนุมัติแล้ว`,
              type: 'success',
              icon: '📦'
            });
          }
          
          posNotificationSystem.addNotification('pos', {
            title: 'เพิ่มสินค้าใหม่',
            message: `${product.name} (${stockText}) - ${product.brand || 'ไม่ระบุแบรนด์'}`,
            type: 'info',
            icon: '📝',
            metadata: {
              productName: product.name,
              barcode: barcodeValue,
              imei: imeiValue,
              stockType: stockType,
              timestamp: new Date().toLocaleString('th-TH')
            }
          });
        }
        
        // Auto-refresh table for better UX
        if (scanCounter % 3 === 0 || !isBatchScanning) {
          refreshStockTable();
        }
        
        return { success: true, productName: product.name, stockType: stockType };

      } catch (err) {
        Logger.error('Error in barcode handling process:', err);
        console.error('❌ Error in handleBarcodeScan:', err);
        
        if (!isBatchScanning) {
          showToast('เกิดข้อผิดพลาด: ' + err.message, 'error');
        } else {
          addToRecentList(barcode, 'ไม่ทราบ', 'error', err.message);
        }

        // POS Notification - Error handling
        if (posNotificationSystem && !isBatchScanning) {
          posNotificationSystem.showToast('pos', {
            title: 'เกิดข้อผิดพลาด',
            message: `ไม่สามารถเพิ่มสินค้าได้: ${err.message}`,
            type: 'error',
            icon: '⚠️',
            duration: 6000
          });
          
          posNotificationSystem.addNotification('pos', {
            title: 'ข้อผิดพลาดในการเพิ่มสินค้า',
            message: `บาร์โค้ด: ${barcode} - ${err.message}`,
            type: 'error',
            icon: '🚨',
            metadata: {
              barcode: barcode,
              error: err.message,
              timestamp: new Date().toLocaleString('th-TH')
            }
          });
        }
        
        return { success: false, error: 'exception', message: err.message };
      } finally {
        if (!isBatchScanning) {
          showLoadingState(false);
        }
        clearInputs();
      }
    }

    // Enhanced batch scanning function
    async function startBatchScanning() {
      isBatchScanning = true;
      scanCounter = 0;
      
      const scanStatus = document.getElementById('scanStatus');
      const scanStatusText = document.getElementById('scanStatusText');
      const barcodeInput = document.getElementById('barcodeInput');
      
      scanStatus.classList.remove('hidden');
      scanStatusText.textContent = 'โหมดสแกนต่อเนื่อง - กรุณาสแกนบาร์โค้ด...';
      
      if (barcodeInput) {
        barcodeInput.focus();
      }
      
      showRecentAdditions();
      updateScanCounter();
      
      // Auto-refresh table every 5 seconds during batch scanning
      autoRefreshInterval = setInterval(() => {
        refreshStockTable();
      }, 5000);
      
      showToast('เริ่มโหมดสแกนต่อเนื่อง - สแกนบาร์โค้ดได้เลย!', 'info');

      // POS Notification - Batch scanning started
      if (posNotificationSystem) {
        posNotificationSystem.showToast('pos', {
          title: 'เริ่มโหมดสแกนต่อเนื่อง',
          message: 'พร้อมสแกนบาร์โค้ดหลายรายการติดต่อกัน',
          type: 'info',
          icon: '🔄',
          duration: 3000
        });
      }
    }

    // Stop batch scanning
    function stopBatchScanning() {
      isBatchScanning = false;
      
      const scanStatus = document.getElementById('scanStatus');
      scanStatus.classList.add('hidden');
      
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
      }
      
      if (scanCounter > 0) {
        showToast(`สแกนเสร็จสิ้น เพิ่มสินค้าทั้งหมด ${scanCounter} ชิ้น`, 'success');
        refreshStockTable();

        // POS Notification - Batch scanning completed
        if (posNotificationSystem) {
          posNotificationSystem.showToast('pos', {
            title: 'สแกนต่อเนื่องเสร็จสิ้น',
            message: `เพิ่มสินค้าทั้งหมด ${scanCounter} รายการสำเร็จ`,
            type: 'success',
            icon: '✅',
            duration: 4000
          });
          
          posNotificationSystem.addNotification('pos', {
            title: 'สรุปการสแกนต่อเนื่อง',
            message: `เพิ่มสินค้าเข้าระบบทั้งหมด ${scanCounter} รายการ`,
            type: 'success',
            icon: '📊',
            actions: [
              {
                label: 'ดูรายการ',
                action: 'primary',
                callback: () => {
                  switchTab('unverified');
                }
              }
            ],
            metadata: {
              itemCount: scanCounter,
              scanType: 'batch',
              timestamp: new Date().toLocaleString('th-TH')
            }
          });
        }
      }
      
      scanCounter = 0;
      updateScanCounter();
    }

    // Update scan counter display
    function updateScanCounter() {
      const counterElement = document.getElementById('scanCounter');
      if (counterElement) {
        counterElement.textContent = `เพิ่มแล้ว: ${scanCounter} ชิ้น`;
      }
    }

    // Add item to recent additions list
    function addToRecentList(barcode, productName, status, message) {
      const timestamp = new Date();
      const recentItem = {
        barcode: barcode,
        productName: productName,
        status: status, // 'success', 'error', 'duplicate'
        message: message,
        timestamp: timestamp
      };
      
      recentAdditions.unshift(recentItem);
      
      // Keep only last 10 items
      if (recentAdditions.length > 10) {
        recentAdditions = recentAdditions.slice(0, 10);
      }
      
      renderRecentList();
      showRecentAdditions();
    }

    // Render recent additions list
    function renderRecentList() {
      const recentList = document.getElementById('recentList');
      if (!recentList) return;
      
      recentList.innerHTML = '';
      
      recentAdditions.forEach(item => {
        const div = document.createElement('div');
        div.className = `flex items-center justify-between p-2 rounded text-xs ${
          item.status === 'success' ? 'bg-green-50 text-green-700 dark:bg-green-900/20' :
          item.status === 'error' ? 'bg-red-50 text-red-700 dark:bg-red-900/20' :
          'bg-yellow-50 text-yellow-700 dark:bg-yellow-900/20'
        }`;
        
        const icon = item.status === 'success' ? 'bi-check-circle' :
                    item.status === 'error' ? 'bi-x-circle' :
                    'bi-exclamation-triangle';
        
        div.innerHTML = `
          <div class="flex items-center gap-2">
            <i class="bi ${icon}"></i>
            <span class="font-mono">${item.barcode}</span>
            <span class="truncate max-w-32">${item.productName}</span>
          </div>
          <span class="text-xs opacity-75">${item.timestamp.toLocaleTimeString('th-TH')}</span>
        `;
        
        recentList.appendChild(div);
      });
    }

    // Show/hide recent additions
    function showRecentAdditions() {
      const recentAdditions = document.getElementById('recentAdditions');
      if (recentAdditions) {
        recentAdditions.classList.remove('hidden');
      }
    }

    function hideRecentAdditions() {
      const recentAdditions = document.getElementById('recentAdditions');
      if (recentAdditions) {
        recentAdditions.classList.add('hidden');
      }
    }

    // Clear inputs helper
    function clearInputs() {
      const barcodeInput = document.getElementById('barcodeInput');
      const manualBarcode = document.getElementById('manualBarcode');
      
      if (barcodeInput) barcodeInput.value = '';
      if (manualBarcode && !isContinuousMode) manualBarcode.value = '';
    }

    // Enhanced table refresh
    async function refreshStockTable() {
      try {
        // Add visual loading indicator
        const stockContainer = document.getElementById('stockContainer');
        if (stockContainer) {
          stockContainer.style.opacity = '0.7';
        }
        
        await loadStock();
        
        if (stockContainer) {
          stockContainer.style.opacity = '1';
        }
      } catch (err) {
        Logger.error('Error refreshing stock table:', err);
      }
    }

    // ==================== ENHANCED DUPLICATE VALIDATION SYSTEM ====================
    
    // Comprehensive duplicate validation function
    async function validateDuplicateProducts(barcode, imei, stockType, branchCode) {
      try {
        // 1. ตรวจสอบใน Branch Stock (ปัจจุบัน)
        const branchStockCheck = await checkBranchStockDuplicate(barcode, imei, stockType, branchCode);
        if (branchStockCheck.isDuplicate) {
          return {
            isDuplicate: true,
            source: 'branch_stock',
            duplicateInfo: branchStockCheck.data,
            message: createDuplicateMessage(branchStockCheck.data, 'branch_stock'),
            recommendation: getDuplicateRecommendation(branchStockCheck.data)
          };
        }
        
        // 2. ตรวจสอบใน PO Items (Cross-check)
        const poItemsCheck = await checkPOItemsDuplicate(barcode, imei, stockType);
        if (poItemsCheck.isDuplicate) {
          return {
            isDuplicate: true,
            source: 'po_items',
            duplicateInfo: poItemsCheck.data,
            message: createDuplicateMessage(poItemsCheck.data, 'po_items'),
            recommendation: getDuplicateRecommendation(poItemsCheck.data)
          };
        }
        
        return {
          isDuplicate: false,
          source: null,
          duplicateInfo: null,
          message: null,
          recommendation: null
        };
        
      } catch (error) {
        Logger.error('Duplicate validation error:', error);
        // Fallback to existing method
        return await fallbackDuplicateCheck(barcode, imei, stockType, branchCode);
      }
    }
    
    // ตรวจสอบซ้ำใน Branch Stock
    async function checkBranchStockDuplicate(barcode, imei, stockType, branchCode) {
      try {
        const url = `/api/branch-stock?branch_code=${branchCode}&include_unverified=1&include_all=1`;
        const res = await secureFetch(url);
        const result = await res.json();
        
        if (res.ok && result.success && result.data) {
          const existingStocks = result.data;
          let duplicate = null;
          
          if (stockType === 'quantity') {
            duplicate = existingStocks.find(s => 
              s.barcode === barcode && 
              s.stockType === 'quantity'
            );
          } else { // 'imei' type
            duplicate = existingStocks.find(s => 
              s.barcode === barcode && 
              s.imei === imei &&
              s.stockType === 'imei'
            );
          }
          
          if (duplicate) {
            Logger.warn('Found duplicate in branch stock:', duplicate);
            return { isDuplicate: true, data: duplicate };
          }
        }
        
        return { isDuplicate: false, data: null };
      } catch (err) {
        Logger.error('Error checking branch stock duplicate:', err);
        return { isDuplicate: false, data: null };
      }
    }
    
    // ตรวจสอบซ้ำใน PO Items
    async function checkPOItemsDuplicate(barcode, imei, stockType) {
      try {
        // กรณีที่ API endpoint มีอยู่
        const response = await secureFetch('/api/purchase-order/check-duplicate-items', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            barcode: barcode,
            imei: imei,
            stockType: stockType
          })
        });
        
        if (response.status === 404) {
          // Fallback หากไม่มี API endpoint
          return await checkPOItemsFallback(barcode, imei, stockType);
        }
        
        const result = await response.json();
        
        if (!response.ok || !result.success) {
          return { isDuplicate: false, data: null };
        }
        
        return {
          isDuplicate: result.data.isDuplicate,
          data: result.data.duplicateInfo
        };
        
      } catch (error) {
        Logger.warn('PO items duplicate check failed, using fallback:', error.message);
        return await checkPOItemsFallback(barcode, imei, stockType);
      }
    }
    
    // Fallback สำหรับตรวจสอบ PO Items
    async function checkPOItemsFallback(barcode, imei, stockType) {
      try {
        // ใช้ client-side check หาก API ไม่มี
        // TODO: Implement client-side PO items check if needed
        Logger.warn('Using client-side PO items check - limited functionality');
        return { isDuplicate: false, data: null };
      } catch (error) {
        Logger.error('PO items fallback check error:', error);
        return { isDuplicate: false, data: null };
      }
    }
    
    // สร้างข้อความแสดงสินค้าซ้ำ
    function createDuplicateMessage(duplicateInfo, source) {
      if (!duplicateInfo) return 'พบสินค้าซ้ำในระบบ';
      
      let message = `🚫 พบสินค้าซ้ำ!\n\n`;
      
      message += `📦 ชื่อสินค้า: ${duplicateInfo.name || 'ไม่ระบุ'}\n`;
      message += `🏷️ บาร์โค้ด: ${duplicateInfo.barcode || 'ไม่ระบุ'}\n`;
      
      if (duplicateInfo.imei && (duplicateInfo.stockType === 'imei' || !duplicateInfo.stockType)) {
        message += `📱 IMEI: ${duplicateInfo.imei}\n`;
      }
      
      if (source === 'branch_stock') {
        message += `🏢 สาขา: ${duplicateInfo.branch_code || 'ไม่ระบุ'}\n`;
        
        if (duplicateInfo.verified) {
          message += `✅ สถานะ: อนุมัติแล้ว\n`;
        } else if (duplicateInfo.pending) {
          message += `⏳ สถานะ: รอฝ่ายสต็อกอนุมัติ\n`;
        } else if (duplicateInfo.sent_to_stock) {
          message += `📤 สถานะ: ส่งไปยังฝ่ายสต็อกแล้ว\n`;
        } else {
          message += `⏱️ สถานะ: รออนุมัติ\n`;
        }
        
        if (duplicateInfo.created_at) {
          message += `📅 วันที่เพิ่ม: ${new Date(duplicateInfo.created_at).toLocaleString('th-TH')}\n`;
        }
        if (duplicateInfo.scanned_by_name) {
          message += `👤 เพิ่มโดย: ${duplicateInfo.scanned_by_name}\n`;
        }
        
      } else if (source === 'po_items') {
        message += `📋 ใบสั่งซื้อ: ${duplicateInfo.poNumber || 'ไม่ระบุ'}\n`;
        if (duplicateInfo.supplier) {
          message += `🏭 ซัพพลายเออร์: ${duplicateInfo.supplier.name || duplicateInfo.supplier}\n`;
        }
      }
      
      return message;
    }
    
    // แนะนำการดำเนินการสำหรับสินค้าซ้ำ
    function getDuplicateRecommendation(duplicateInfo) {
      if (!duplicateInfo) return null;
      
      if (duplicateInfo.verified) {
        return {
          type: 'success',
          message: 'สินค้านี้ได้รับการอนุมัติแล้ว คุณสามารถเพิ่มสินค้าใหม่ได้',
          canProceed: true
        };
      } else if (duplicateInfo.pending || duplicateInfo.sent_to_stock) {
        return {
          type: 'warning',
          message: 'สินค้านี้รอการอนุมัติจากฝ่ายสต็อก กรุณารอผลการอนุมัติก่อน',
          canProceed: false
        };
      } else {
        return {
          type: 'info',
          message: 'สินค้านี้รอการส่งไปยังฝ่ายสต็อก คุณสามารถส่งไปพร้อมกับรายการอื่นได้',
          canProceed: false
        };
      }
    }
    
    // แสดง Enhanced Duplicate Alert
    function showDuplicateAlert(duplicateResult) {
      const { duplicateInfo, source, message, recommendation } = duplicateResult;
      
      const existingAlert = document.querySelector('.duplicate-alert-modal');
      if (existingAlert) existingAlert.remove();
      
      const alertModal = document.createElement('div');
      alertModal.className = 'duplicate-alert-modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      
      let recommendationHtml = '';
      if (recommendation) {
        const iconClass = recommendation.type === 'success' ? 'bi-check-circle-fill text-green-500' :
                         recommendation.type === 'warning' ? 'bi-exclamation-triangle-fill text-yellow-500' :
                         'bi-info-circle-fill text-blue-500';
        
        recommendationHtml = `
          <div class="mt-3 p-3 rounded-lg ${recommendation.type === 'success' ? 'bg-green-50 dark:bg-green-900/20 border border-green-200' :
                                            recommendation.type === 'warning' ? 'bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200' :
                                            'bg-blue-50 dark:bg-blue-900/20 border border-blue-200'}">
            <div class="flex items-start gap-2">
              <i class="bi ${iconClass} mt-0.5"></i>
              <span class="text-sm">${recommendation.message}</span>
            </div>
          </div>
        `;
      }
      
      let actionButtons = '';
      if (source === 'branch_stock' && duplicateInfo) {
        actionButtons += `
          <button onclick="viewDuplicateDetails('${duplicateInfo._id}')" 
                  class="btn btn-info btn-sm mr-2">
            <i class="bi bi-eye mr-1"></i> ดูรายละเอียด
          </button>
        `;
        
        if (duplicateInfo.branch_code !== BRANCH_CODE) {
          actionButtons += `
            <button onclick="switchToBranch('${duplicateInfo.branch_code}')" 
                    class="btn btn-warning btn-sm mr-2">
              <i class="bi bi-arrow-right mr-1"></i> ไปยังสาขา ${duplicateInfo.branch_code}
            </button>
          `;
        }
      }
      
      alertModal.innerHTML = `
        <div class="modal-box max-w-lg">
          <div class="flex items-start gap-3">
            <i class="bi bi-exclamation-triangle-fill text-red-500 text-3xl flex-shrink-0 mt-1"></i>
            <div class="flex-1">
              <h3 class="text-lg font-bold mb-3 text-red-600">พบสินค้าซ้ำ!</h3>
              <div class="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-3 mb-4">
                <pre class="whitespace-pre-wrap text-sm text-gray-700 dark:text-gray-300 font-medium">${message}</pre>
              </div>
              
              ${recommendationHtml}
              
              ${actionButtons ? `
                <div class="mt-4">
                  <p class="text-sm text-gray-600 dark:text-gray-400 mb-2">ตัวเลือกการดำเนินการ:</p>
                  <div class="flex flex-wrap gap-2">
                    ${actionButtons}
                  </div>
                </div>
              ` : ''}
            </div>
          </div>
          <div class="modal-action mt-4">
            <button onclick="this.closest('.duplicate-alert-modal').remove()"
                    class="btn btn-primary">
              <i class="bi bi-check mr-1"></i> เข้าใจแล้ว
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(alertModal);
    }
    
    // ดูรายละเอียดสินค้าซ้ำ
    async function viewDuplicateDetails(stockId) {
      try {
        const response = await secureFetch(`/api/branch-stock/${stockId}`);
        const result = await response.json();
        
        if (response.ok && result.success) {
          showItemDetailsModal(result.data);
        } else {
          showToast('ไม่สามารถโหลดข้อมูลรายการได้', 'error');
        }
      } catch (error) {
        Logger.error('Error viewing duplicate details:', error);
        showToast('เกิดข้อผิดพลาดในการดูรายละเอียด', 'error');
      }
    }
    
    // แสดงรายละเอียดสินค้า
    function showItemDetailsModal(itemData) {
      const existingModal = document.querySelector('.item-details-modal');
      if (existingModal) existingModal.remove();
      
      const modal = document.createElement('div');
      modal.className = 'item-details-modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      
      const stockTypeBadge = itemData.stockType === 'imei' 
        ? '<span class="badge badge-info"><i class="bi bi-qr-code mr-1"></i>สินค้าที่มีเลข IMEI</span>'
        : '<span class="badge badge-success"><i class="bi bi-boxes mr-1"></i>สินค้าที่ไม่มีเลข IMEI</span>';
      
      let statusBadge = '';
      if (itemData.verified) {
        statusBadge = '<span class="badge badge-success"><i class="bi bi-check-circle mr-1"></i>อนุมัติแล้ว</span>';
      } else if (itemData.pending) {
        statusBadge = '<span class="badge badge-warning"><i class="bi bi-clock mr-1"></i>รอฝ่ายสต็อกอนุมัติ</span>';
      } else if (itemData.sent_to_stock) {
        statusBadge = '<span class="badge badge-info"><i class="bi bi-send mr-1"></i>ส่งไปยังฝ่ายสต็อกแล้ว</span>';
      } else {
        statusBadge = '<span class="badge badge-ghost"><i class="bi bi-hourglass mr-1"></i>รออนุมัติ</span>';
      }
      
      modal.innerHTML = `
        <div class="modal-box max-w-2xl">
          <h3 class="text-lg font-bold mb-4">
            <i class="bi bi-box-seam mr-2 text-blue-500"></i>
            รายละเอียดสินค้า
          </h3>
          
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label class="label"><span class="label-text font-medium">ชื่อสินค้า</span></label>
              <div class="text-lg font-semibold">${itemData.name || '-'}</div>
            </div>
            <div>
              <label class="label"><span class="label-text font-medium">แบรนด์</span></label>
              <div>${itemData.brand || '-'}</div>
            </div>
            <div>
              <label class="label"><span class="label-text font-medium">บาร์โค้ด</span></label>
              <div class="font-mono bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">
                ${itemData.barcode || '-'}
              </div>
            </div>
            <div>

              <div class="font-mono bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">
                ${itemData.barcode || '-'}
              </div>
            </div>
            ${itemData.stockType === 'imei' ? `
              <div>
                <label class="label"><span class="label-text font-medium">IMEI</span></label>
                <div class="font-mono bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">
                  ${itemData.imei || '-'}
                </div>
              </div>
            ` : ''}
            <div>
              <label class="label"><span class="label-text font-medium">ประเภทสต็อก</span></label>
              <div>${stockTypeBadge}</div>
            </div>
            <div>
              <label class="label"><span class="label-text font-medium">สถานะ</span></label>
              <div>${statusBadge}</div>
            </div>
            <div>
              <label class="label"><span class="label-text font-medium">สาขา</span></label>
              <div>${itemData.branch_code || '-'}</div>
            </div>
            <div>
              <label class="label"><span class="label-text font-medium">วันที่เพิ่ม</span></label>
              <div>${itemData.created_at ? new Date(itemData.created_at).toLocaleString('th-TH') : '-'}</div>
            </div>
            <div>
              <label class="label"><span class="label-text font-medium">เพิ่มโดย</span></label>
              <div>${itemData.scanned_by_name || '-'}</div>
            </div>
          </div>
          
          <div class="modal-action mt-6">
            <button onclick="this.closest('.item-details-modal').remove()" 
                    class="btn btn-primary">
              <i class="bi bi-x mr-1"></i> ปิด
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
    }
    
    // เปลี่ยนไปยังสาขาอื่น
    function switchToBranch(branchCode) {
      if (confirm(`ต้องการเปลี่ยนไปจัดการสินค้าที่สาขา ${branchCode} หรือไม่?`)) {
        window.location.href = `addNewProduct_pattani.html?branch=${branchCode}`;
      }
    }
    
    // Fallback duplicate check (ใช้วิธีเดิม)
    async function fallbackDuplicateCheck(barcode, imei, stockType, branchCode) {
      try {
        const existingStock = await checkExistingPendingStock(barcode, imei, stockType, branchCode);
        
        if (existingStock) {
          return {
            isDuplicate: true,
            source: 'fallback',
            duplicateInfo: existingStock,
            message: createDuplicateMessage(existingStock, 'branch_stock'),
            recommendation: getDuplicateRecommendation(existingStock)
          };
        }
        
        return {
          isDuplicate: false,
          source: null,
          duplicateInfo: null,
          message: null,
          recommendation: null
        };
        
      } catch (error) {
        Logger.error('Fallback duplicate check failed:', error);
        return {
          isDuplicate: false,
          source: null,
          duplicateInfo: null,
          message: null,
          recommendation: null
        };
      }
    }
    
    // ฟังก์ชันเดิมสำหรับ backward compatibility
    async function checkExistingPendingStock(barcode, imei, stockType, branchCode) {
      try {
        const url = `/api/branch-stock?branch_code=${branchCode}&barcode=${barcode}&include_unverified=1&include_all=1`;
        const res = await secureFetch(url);
        const result = await res.json();
        
        if (res.ok && result.success && result.data) {
          const existingStocks = result.data;
          
          if (stockType === 'quantity') {
            const duplicate = existingStocks.find(s => 
              s.barcode === barcode && 
              s.stockType === 'quantity'
            );
            
            if (duplicate) {
              Logger.warn('Found duplicate quantity stock:', duplicate);
              return duplicate;
            }
          } else { // 'imei' type
            const duplicate = existingStocks.find(s => 
              s.barcode === barcode && 
              s.imei === imei &&
              s.stockType === 'imei'
            );
            
            if (duplicate) {
              Logger.warn('Found duplicate IMEI stock:', duplicate);
              return duplicate;
            }
          }
        }
        return null;
      } catch (err) {
        Logger.error('Error checking existing stock:', err);
        return null;
      }
    }
    
    // ==================== END ENHANCED DUPLICATE VALIDATION SYSTEM ====================

    // Setup checkbox listeners
    function setupCheckboxListeners() {
      // Brand checkboxes - select all items in brand
      document.querySelectorAll('.brand-checkbox').forEach(cb => {
        cb.addEventListener('change', function() {
          const brand = this.dataset.brand;
          const stockCheckboxes = document.querySelectorAll(`.stock-checkbox[data-brand="${brand}"]:not(:disabled)`);
          
          stockCheckboxes.forEach(stockCb => {
            stockCb.checked = this.checked;
            if (this.checked) {
              selectedStocks.add(stockCb.dataset.stockId);
            } else {
              selectedStocks.delete(stockCb.dataset.stockId);
            }
          });
          
          updateSelectedCount();
        });
      });
      
      // Individual stock checkboxes
      document.querySelectorAll('.stock-checkbox').forEach(cb => {
        cb.addEventListener('change', function() {
          if (this.checked) {
            selectedStocks.add(this.dataset.stockId);
          } else {
            selectedStocks.delete(this.dataset.stockId);
          }
          updateSelectedCount();
          
          // Update brand checkbox state
          const brand = this.dataset.brand;
          const brandCheckbox = document.querySelector(`.brand-checkbox[data-brand="${brand}"]`);
          if (brandCheckbox) {
            const allInBrand = document.querySelectorAll(`.stock-checkbox[data-brand="${brand}"]:not(:disabled)`);
            const checkedInBrand = document.querySelectorAll(`.stock-checkbox[data-brand="${brand}"]:checked`);
            brandCheckbox.checked = allInBrand.length === checkedInBrand.length && allInBrand.length > 0;
          }
        });
      });
      
      // Remove stock button
      document.querySelectorAll('.remove-stock-button').forEach(btn => {
        btn.addEventListener('click', async function() {
          const stockId = this.dataset.stockId;
          customConfirm('ยืนยันการลบสินค้านี้?', async () => {
            await removeStock(stockId);
          });
        });
      });
    }

    // Update selected count
    function updateSelectedCount() {
      const count = selectedStocks.size;
      const countElement = document.getElementById('selectedCount');
      if (countElement) {
        countElement.textContent = count;
      }
      
      // Show/hide bulk actions
      const bulkActions = document.getElementById('bulkActions');
      if (bulkActions) {
        bulkActions.style.display = count > 0 ? 'flex' : 'none';
      }
    }

    // Bulk send to stock
    async function bulkSendToStock() {
      if (selectedStocks.size === 0) {
        showToast('กรุณาเลือกสินค้าที่ต้องการส่ง', 'warning');
        return;
      }
      
      customConfirm(`ยืนยันการส่งสินค้า ${selectedStocks.size} รายการไปยังฝ่ายสต็อก?`, async () => {
        try {
          // Rate limit check
          if (!RateLimiter.check('update_action')) return;
          
          const stockIds = Array.from(selectedStocks);
          const userInfo = await getCurrentUserInfo();
          
          // Update each stock with pending status (NOT verified)
          const promises = stockIds.map(stockId => 
            secureFetch(`/api/branch-stock/${stockId}`, {
              method: 'PATCH',
            headers: { 
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ 
                sent_to_stock: true,  // ตั้งเป็น true เมื่อส่งไปฝ่ายสต็อก
                pending: true,  // ตั้งเป็น pending แทน verified
                verified: false, // ต้องรอการอนุมัติจากฝ่ายสต็อก
                sent_by: userInfo.userId,
                sent_by_name: userInfo.userName,
                sent_at: new Date().toISOString()
              })
            })
          );
          
          const results = await Promise.all(promises);
          const successCount = results.filter(r => r.ok).length;
          
          // Audit log
          createAuditLog('BULK_SEND_TO_STOCK', {
            stockCount: stockIds.length,
            successCount: successCount,
            branch: document.getElementById('branchSelect').value
          });
          
          showToast(`ส่งสินค้า ${successCount}/${stockIds.length} รายการไปยังฝ่ายสต็อกเรียบร้อย`, 'success');

          // POS Notification - Items sent to stock department
          if (posNotificationSystem) {
            posNotificationSystem.showToast('pos', {
              title: 'ส่งไปยังฝ่ายสต็อกสำเร็จ',
              message: `ส่งสินค้า ${successCount} รายการไปยังฝ่ายสต็อกแล้ว`,
              type: 'success',
              icon: '📤',
              duration: 4000
            });
            
            posNotificationSystem.addNotification('pos', {
              title: 'ส่งสินค้าไปยังฝ่ายสต็อก',
              message: `ส่งสินค้า ${successCount}/${stockIds.length} รายการเรียบร้อยแล้ว`,
              type: 'success',
              icon: '✅',
              actions: [
                {
                  label: 'ดูรายการที่ส่ง',
                  action: 'primary',
                  callback: () => {
                    // Switch to verified tab or show details
                    switchTab('verified');
                  }
                }
              ],
              metadata: {
                itemCount: successCount,
                totalCount: stockIds.length,
                sentBy: userInfo.userName,
                timestamp: new Date().toLocaleString('th-TH')
              }
            });
          }
          
          // Clear selection
          selectedStocks.clear();
          updateSelectedCount();
          
          // ส่ง socket event พร้อมข้อมูลที่ละเอียดขึ้น (ถ้า socket พร้อมใช้งาน)
          try {
            if (socket && socket.connected) {
              socket.emit('stockSentForApproval', {
                stockIds: stockIds,
                branchCode: document.getElementById('branchSelect').value,
                sentBy: userInfo.userId,
                sentByName: userInfo.userName,
                timestamp: new Date().toISOString()
              });
              Logger.debug("Socket event sent: stockSentForApproval");
            } else {
              Logger.debug("Socket not available, skipping real-time notification");
            }
          } catch (socketEmitError) {
            Logger.warn("Failed to emit socket event:", socketEmitError);
          }
          
          // Reload stock
          loadStock();
          
        } catch (err) {
          showToast('Error sending to stock: ' + err.message, 'error');
          
          // Audit log for error
          createAuditLog('ERROR_BULK_SEND_TO_STOCK', {
            error: err.message,
            stockCount: selectedStocks.size
          });
        }
      });
    }

    // Custom confirm dialog
    function customConfirm(message, onConfirm) {
      const dialog = document.createElement('div');
      dialog.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      dialog.innerHTML = `
        <div class="modal-box">
          <h3 class="text-lg font-bold mb-4">ยืนยันการดำเนินการ</h3>
          <p class="mb-4">${message}</p>
          <div class="modal-action">
            <button onclick="this.closest('.fixed').remove()" class="btn btn-ghost">ยกเลิก</button>
            <button class="btn btn-primary confirm-btn">ยืนยัน</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(dialog);
      
      dialog.querySelector('.confirm-btn').addEventListener('click', () => {
        dialog.remove();
        onConfirm();
      });
    }

    // เพิ่ม function สำหรับแสดง alert แบบละเอียด
    function customAlert(message, type = 'info') {
      const existingAlert = document.querySelector('.custom-alert-modal');
      if (existingAlert) existingAlert.remove();
      
      const alertModal = document.createElement('div');
      alertModal.className = 'custom-alert-modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      
      const iconClass = type === 'warning' ? 'bi-exclamation-triangle-fill text-yellow-500' : 
                       type === 'error' ? 'bi-x-circle-fill text-red-500' : 
                       'bi-info-circle-fill text-blue-500';
      
      alertModal.innerHTML = `
        <div class="modal-box max-w-md">
          <div class="flex items-start gap-3">
            <i class="bi ${iconClass} text-2xl flex-shrink-0 mt-1"></i>
            <div class="flex-1">
              <h3 class="text-lg font-bold mb-2">แจ้งเตือน</h3>
              <pre class="whitespace-pre-wrap text-sm text-gray-700 dark:text-gray-300">${message}</pre>
            </div>
          </div>
          <div class="modal-action mt-4">
            <button onclick="this.closest('.custom-alert-modal').remove()"
                    class="btn btn-primary">
              ตกลง
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(alertModal);
    }

    // ==================== END EVENT HANDLERS ====================

    // ==================== HELPER FUNCTIONS ====================
    
    // Toggle sidebar
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      const mainContent = document.getElementById('mainContent');
      const mainHeader = document.getElementById('mainHeader');
      const toggleIcon = document.getElementById('toggleIcon');
      
      sidebar.classList.toggle('-translate-x-full');
      mainContent.classList.toggle('ml-0');
      mainContent.classList.toggle('ml-56');
      
      if (mainHeader) {
        mainHeader.classList.toggle('ml-0');
        mainHeader.classList.toggle('ml-56');
      }
      
      // Update icon
      if (sidebar.classList.contains('-translate-x-full')) {
        toggleIcon.classList.remove('bi-x');
        toggleIcon.classList.add('bi-list');
      } else {
        toggleIcon.classList.remove('bi-list');
        toggleIcon.classList.add('bi-x');
      }
    }

    // Switch tab
    function switchTab(tabName) {
      Logger.info('Switching to tab:', tabName);
      
      // Update tab buttons
      document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('tab-active');
      });
      const targetTab = document.getElementById(`tab-${tabName}`);
      if (targetTab) {
        targetTab.classList.add('tab-active');
      }
      
      // Show/hide content
      const unverifiedContent = document.getElementById('content-unverified');
      const verifiedContent = document.getElementById('content-verified');
      
      if (unverifiedContent) {
        if (tabName === 'unverified') {
          unverifiedContent.classList.remove('hidden');
          unverifiedContent.style.display = 'block';
        } else {
          unverifiedContent.classList.add('hidden');
          unverifiedContent.style.display = 'none';
        }
      }
      
      if (verifiedContent) {
        if (tabName === 'verified') {
          verifiedContent.classList.remove('hidden');
          verifiedContent.style.display = 'block';
        } else {
          verifiedContent.classList.add('hidden');
          verifiedContent.style.display = 'none';
        }
      }
      
      // Audit log for tab switch
      createAuditLog('TAB_SWITCH', {
        tab: tabName,
        branch: document.getElementById('branchSelect').value
      });
      
      // Load appropriate data
      if (tabName === 'verified') {
        loadVerifiedHistory();
      } else {
        loadStock();
      }
    }

         // Calculate time ago in Thai
    function getTimeAgo(date) {
      const now = new Date();
      const diffInMs = now - date;
      const diffInMinutes = Math.floor(diffInMs / (1000 * 60));
      const diffInHours = Math.floor(diffInMs / (1000 * 60 * 60));
      const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));
      
      if (diffInMinutes < 1) return 'เพิ่งเพิ่ม';
      if (diffInMinutes < 60) return `${diffInMinutes} นาทีที่แล้ว`;
      if (diffInHours < 24) return `${diffInHours} ชั่วโมงที่แล้ว`;
      if (diffInDays < 7) return `${diffInDays} วันที่แล้ว`;
      return date.toLocaleDateString('th-TH');
    }

    // Enhanced notification for successful addition
    function showSuccessfulAddition(productName, brand) {
      const toast = document.createElement('div');
      toast.className = 'fixed bottom-4 right-4 bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded-lg shadow-lg z-50 animate-in';
      toast.innerHTML = `
        <div class="flex items-center gap-2">
          <i class="bi bi-check-circle-fill text-green-600"></i>
          <div>
            <div class="font-medium">${productName}</div>
            <div class="text-sm opacity-75">เพิ่มเข้า ${brand} แล้ว</div>
          </div>
        </div>
      `;
      
      document.body.appendChild(toast);
      
      // Auto remove after 3 seconds
      setTimeout(() => {
        toast.classList.add('animate-out');
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }

    // ==================== END HELPER FUNCTIONS ====================

    // ==================== INITIALIZATION ====================
    
    // Clear failed audit logs on page load
    function clearFailedAuditLogs() {
      localStorage.removeItem('failedAuditLogs');
      console.log('Cleared failed audit logs');
    }
    
    // Firebase Session Management Functions
function createAddProductSession() {
  if (!window.firebaseDatabase) {
    console.warn('Firebase not initialized yet');
    return;
  }
  
  const branchCode = getCurrentBranchCode();
  const userId = localStorage.getItem('userId');
  const userName = localStorage.getItem('userName');
  
  if (!userId || !userName) {
    console.warn('User info not available for session creation');
    return;
  }
  
  firebaseSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const sessionRef = window.firebaseRef(window.firebaseDatabase, `pos/${branchCode}/sessions/${firebaseSessionId}`);
  
  const sessionData = {
    userId: userId,
    userName: userName,
    userRole: localStorage.getItem('userRole') || 'user',
    activity: 'add_product',
    page: 'addNewProduct_pattani',
    loginTime: window.firebaseServerTimestamp(),
    lastActive: window.firebaseServerTimestamp(),
    status: 'online',
    device: navigator.userAgent,
    branchCode: branchCode
  };
  
  // Set session data
  window.firebaseSet(sessionRef, sessionData)
    .then(() => {
      console.log('Add product session created:', firebaseSessionId);
      
      // Set up disconnect handler
      window.firebaseOnDisconnect(sessionRef).update({
        status: 'offline',
        logoutTime: window.firebaseServerTimestamp()
      });
      
      // Update activity on user actions
      trackUserActivity(sessionRef);
    })
    .catch(error => {
      console.error('Error creating session:', error);
    });
}

// Track user activity
function trackUserActivity(sessionRef) {
  let activityTimer;
  
  function updateActivity() {
    if (sessionRef) {
      window.firebaseUpdate(sessionRef, {
        lastActive: window.firebaseServerTimestamp()
      }).catch(err => console.warn('Activity update failed:', err));
    }
  }
  
  // Update activity every 30 seconds if user is active
  function resetActivityTimer() {
    clearTimeout(activityTimer);
    activityTimer = setTimeout(updateActivity, 30000);
  }
  
  // Track various user activities
  document.addEventListener('click', resetActivityTimer);
  document.addEventListener('keypress', resetActivityTimer);
  document.addEventListener('scroll', resetActivityTimer);
  
  // Initial activity update
  resetActivityTimer();
}

// Monitor online users
function updateOnlineUsers() {
  if (!window.firebaseDatabase) return;
  
  const branchCode = getCurrentBranchCode();
  const onlineUsersRef = window.firebaseRef(window.firebaseDatabase, `pos/${branchCode}/onlineUsers`);
  
  window.firebaseOnValue(onlineUsersRef, (snapshot) => {
    const users = snapshot.val();
    if (users) {
      const onlineCount = Object.values(users).filter(u => u.status === 'online' && u.activity === 'add_product').length;
      console.log(`Online users in add product: ${onlineCount}`);
    }
  });
}

// Log activity to Firebase
window.logAddProductActivity = function(action, details) {
  if (!window.firebaseDatabase) return;
  
  const branchCode = getCurrentBranchCode();
  const activityRef = window.firebaseRef(window.firebaseDatabase, `pos/${branchCode}/activityHistory`);
  
  const activityData = {
    action: action,
    userId: localStorage.getItem('userId'),
    userName: localStorage.getItem('userName'),
    timestamp: window.firebaseServerTimestamp(),
    page: 'addNewProduct_pattani',
    details: details || {}
  };
  
  window.firebasePush(activityRef, activityData)
    .catch(err => console.warn('Activity log failed:', err));
};

// Send stock update to Firebase
function sendStockUpdateToFirebase(updateData) {
  if (!window.firebaseDatabase) return;
  
  const branchCode = getCurrentBranchCode();
  const stockUpdatesRef = window.firebaseRef(window.firebaseDatabase, `pos/${branchCode}/stockUpdates`);
  
  const stockUpdateData = {
    ...updateData,
    timestamp: Date.now(),
    updatedBy: localStorage.getItem('userName'),
    branchCode: branchCode,
    requiresRefresh: true
  };
  
  window.firebasePush(stockUpdatesRef, stockUpdateData)
    .then(() => {
      console.log('Stock update sent to Firebase:', stockUpdateData);
    })
    .catch(err => console.warn('Failed to send stock update to Firebase:', err));
}

// Initialize Firebase connections
function initializeFirebaseConnections() {
  // Check if Firebase is ready
  if (window.firebaseDatabase) {
    createAddProductSession();
    updateOnlineUsers();
    
    // Log page access
    window.logAddProductActivity('PAGE_ACCESS', {
      page: 'Add New Product',
      branch: getCurrentBranchCode()
    });
  } else {
    // Retry after a short delay
    setTimeout(initializeFirebaseConnections, 1000);
  }
}

// DOMContentLoaded
document.addEventListener('DOMContentLoaded', async function() {
      showLoading(true);

      try {
      Logger.info('Initializing Add New Product page...');
      
      try {
        // Clear failed audit logs to prevent infinite retry
        clearFailedAuditLogs();
        
        // Check authentication
        const token = localStorage.getItem('authToken');
        if (!token) {
          window.location.href = '../login.html';
          return;
        }
        
        // Initialize CSRF token
        if (!localStorage.getItem('csrfToken')) {
          generateCSRFToken();
        }
        
        // Initialize Modular Notification System
        if (typeof ModularNotificationSystem !== 'undefined') {
          posNotificationSystem = new ModularNotificationSystem();
          console.log('🔔 POS Notification System initialized');
          
          // Add welcome notification
          posNotificationSystem.addNotification('pos', {
            title: 'ระบบจัดการคลังสินค้าพร้อมใช้งาน',
            message: `ยินดีต้อนรับสู่ระบบจัดการคลังสินค้า - สาขา ${BRANCH_CODE}`,
            type: 'success',
            icon: '📦',
            actions: [
              {
                label: 'เริ่มสแกน',
                action: 'primary',
                callback: () => {
                  console.log('🔍 เริ่มสแกนสินค้า');
                  document.getElementById('manualBarcode')?.focus();
                }
              }
            ]
          });
        } else {
          console.warn('⚠️ ModularNotificationSystem not available');
        }
        
        // Reset session timeout
        resetSessionTimeout();
        
        // Comment out retry failed audit logs to prevent errors
        // setTimeout(() => retryFailedAuditLogs(), 5000);
        
        // Load initial data
        await Promise.all([
          loadBranchInfo(),
          loadBranches(),
          loadProductImages(),
          loadSuppliers(),
          getCurrentUserInfo()
        ]);
        
        // Setup event listeners
        
        // Barcode input
        const barcodeInput = document.getElementById('barcodeInput');
        if (barcodeInput) {
          barcodeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
              handleBarcodeScan(e.target.value);
              e.target.value = ''; // Clear after scan
            }
          });
        }
        
        // Manual barcode button with enhanced loading
        const btnAddManualCode = document.getElementById('btnAddManualCode');
        if (btnAddManualCode) {
          enhanceButtonWithLoading(btnAddManualCode, {
            spinnerType: 'default',
            successMessage: 'เพิ่มสำเร็จ',
            errorMessage: 'เพิ่มไม่สำเร็จ'
          });
          
          btnAddManualCode.onclick = async function() {
            const manualBarcode = document.getElementById('manualBarcode');
            if (!manualBarcode || !manualBarcode.value.trim()) {
              showToast('กรุณากรอกเลขบาร์โค้ด', 'warning');
              manualBarcode?.focus();
              return;
            }
            
            const barcode = manualBarcode.value.trim();
            const loadingId = safeShowLoading({
              message: 'กำลังประมวลผลบาร์โค้ด...',
              subMessage: `ตรวจสอบ: ${barcode}`,
              showProgress: true,
              spinnerType: 'default'
            });
            
            try {
              safeUpdateMessage(loadingId, 'กำลังค้นหาสินค้า...', 'เชื่อมต่อกับฐานข้อมูลสินค้า');
              safeUpdateProgress(loadingId, 25);
              
              const success = await handleBarcodeScan(barcode);
              
              if (success) {
                safeUpdateProgress(loadingId, 100);
                safeUpdateMessage(loadingId, 'เพิ่มสินค้าสำเร็จ', 'เข้ารายการรออนุมัติแล้ว');
                
                if (!isContinuousMode) {
                  manualBarcode.value = '';
                } else {
                  manualBarcode.select();
                }
                
                await new Promise(resolve => setTimeout(resolve, 800));
              } else {
                throw new Error('ไม่สามารถเพิ่มสินค้าได้');
              }
              
            } catch (error) {
              safeUpdateMessage(loadingId, 'เกิดข้อผิดพลาด', error.message || 'ไม่สามารถเพิ่มสินค้าได้');
              await new Promise(resolve => setTimeout(resolve, 1200));
              throw error;
            } finally {
              safeHideLoading(loadingId);
            }
          };
        }
        
        // Scan barcode button with enhanced feedback
        const btnScanBarcode = document.getElementById('btnScanBarcode');
        if (btnScanBarcode) {
          btnScanBarcode.addEventListener('click', () => {
            if (isBatchScanning) {
              stopBatchScanning();
              return;
            }
            
            // Add loading animation
            const originalText = btnScanBarcode.innerHTML;
            btnScanBarcode.innerHTML = '<i class="bi bi-upc-scan animate-pulse"></i> พร้อมสแกน...';
            btnScanBarcode.classList.add('btn-warning');
            btnScanBarcode.classList.remove('btn-primary');
            
            // Show scan status and focus on hidden input
            const scanStatus = document.getElementById('scanStatus');
            if (scanStatus) {
              scanStatus.classList.remove('hidden');
            }
            
            // Focus on hidden barcode input
            const barcodeInput = document.getElementById('barcodeInput');
            if (barcodeInput) {
              barcodeInput.focus();
              showToast('พร้อมสแกนบาร์โค้ด กรุณาสแกนบาร์โค้ดของสินค้า', 'info');
            }
            
            // Auto hide scan status after 30 seconds
            scanningTimeout = setTimeout(() => {
              if (scanStatus) {
                scanStatus.classList.add('hidden');
              }
              btnScanBarcode.innerHTML = originalText;
              btnScanBarcode.classList.remove('btn-warning');
              btnScanBarcode.classList.add('btn-primary');
            }, 30000);
          });
        }

        // Batch scan button with enhanced state management
        const btnBatchScan = document.getElementById('btnBatchScan');
        if (btnBatchScan) {
          btnBatchScan.addEventListener('click', () => {
            if (isBatchScanning) {
              // Stop batch scanning with loading feedback
              const originalText = btnBatchScan.innerHTML;
              btnBatchScan.innerHTML = '<i class="bi bi-hourglass-split animate-spin"></i> หยุด...';
              btnBatchScan.disabled = true;
              
              setTimeout(() => {
                stopBatchScanning();
                btnBatchScan.innerHTML = '<i class="bi bi-collection"></i> <span class="hidden sm:inline">สแกนต่อเนื่อง</span>';
                btnBatchScan.disabled = false;
                btnBatchScan.classList.remove('btn-error');
                btnBatchScan.classList.add('btn-success');
              }, 500);
            } else {
              // Start batch scanning with loading feedback
              const originalText = btnBatchScan.innerHTML;
              btnBatchScan.innerHTML = '<i class="bi bi-hourglass-split animate-spin"></i> เริ่ม...';
              btnBatchScan.disabled = true;
              
              setTimeout(() => {
                startBatchScanning();
                btnBatchScan.innerHTML = '<i class="bi bi-stop-circle"></i> <span class="hidden sm:inline">หยุดสแกน</span>';
                btnBatchScan.disabled = false;
                btnBatchScan.classList.remove('btn-success');
                btnBatchScan.classList.add('btn-error');
              }, 300);
            }
          });
        }

        // Clear recent additions with confirmation
        const btnClearRecent = document.getElementById('btnClearRecent');
        if (btnClearRecent) {
          btnClearRecent.addEventListener('click', () => {
            if (recentAdditions.length === 0) {
              showToast('ไม่มีรายการล่าสุดให้ล้าง', 'info');
              return;
            }
            
            // Add loading animation
            btnClearRecent.classList.add('loading');
            
            setTimeout(() => {
              recentAdditions = [];
              renderRecentList();
              hideRecentAdditions();
              
              btnClearRecent.classList.remove('loading');
              showToast('ล้างรายการล่าสุดแล้ว', 'info');
            }, 200);
          });
        }
        
        // Manual barcode input - handle Enter key
        const manualBarcodeInput = document.getElementById('manualBarcode');
        if (manualBarcodeInput) {
          manualBarcodeInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              if (manualBarcodeInput.value.trim()) {
                await handleBarcodeScan(manualBarcodeInput.value);
                if (!isContinuousMode) {
                  manualBarcodeInput.value = ''; // Clear input after scan
                } else {
                  manualBarcodeInput.select(); // Select all for next scan
                }
              } else {
                showToast('กรุณากรอกเลขบาร์โค้ด', 'warning');
              }
            }
          });
        }
        
        // Continuous mode toggle
        const continuousModeCheckbox = document.getElementById('continuousMode');
        if (continuousModeCheckbox) {
          continuousModeCheckbox.addEventListener('change', (e) => {
            isContinuousMode = e.target.checked;
            const manualBarcode = document.getElementById('manualBarcode');
            if (isContinuousMode) {
              showToast('เปิดโหมดต่อเนื่อง - ช่องบาร์โค้ดจะไม่ล้างหลังเพิ่มสินค้า', 'info');
              if (manualBarcode) manualBarcode.focus();
            } else {
              showToast('ปิดโหมดต่อเนื่อง', 'info');
            }
          });
        }

        // Toggle continuous button
        const btnToggleContinuous = document.getElementById('btnToggleContinuous');
        if (btnToggleContinuous) {
          btnToggleContinuous.addEventListener('click', () => {
            const checkbox = document.getElementById('continuousMode');
            if (checkbox) {
              checkbox.checked = !checkbox.checked;
              checkbox.dispatchEvent(new Event('change'));
            }
          });
        }
        
        // Date filters
        const dateFrom = document.getElementById('dateFrom');
        const dateTo = document.getElementById('dateTo');
        if (dateFrom) {
          dateFrom.addEventListener('change', () => {
            if (document.querySelector('.tab-active').id === 'tab-verified') {
              loadVerifiedHistory();
            }
          });
        }
        if (dateTo) {
          dateTo.addEventListener('change', () => {
            if (document.querySelector('.tab-active').id === 'tab-verified') {
              loadVerifiedHistory();
            }
          });
        }
        
        // Tab buttons
        document.getElementById('tab-unverified').addEventListener('click', () => switchTab('unverified'));
        document.getElementById('tab-verified').addEventListener('click', () => switchTab('verified'));
        
        // Manual reload button with enhanced loading
        const btnManualReload = document.getElementById('btnManualReload');
        if (btnManualReload) {
          enhanceButtonWithLoading(btnManualReload, {
            spinnerType: 'pulse',
            successMessage: 'รีเฟรชสำเร็จ',
            errorMessage: 'รีเฟรชไม่สำเร็จ'
          });
          
          btnManualReload.onclick = async function() {
            const loadingId = safeShowLoading({
              message: 'กำลังรีเฟรชข้อมูล...',
              subMessage: 'อัปเดตรายการสต็อกล่าสุด',
              showProgress: true,
              autoProgress: true,
              spinnerType: 'pulse'
            });
            
            try {
              safeUpdateMessage(loadingId, 'กำลังโหลดข้อมูลใหม่...', 'ตรวจสอบข้อมูลล่าสุดจากเซิร์ฟเวอร์');
              await new Promise(resolve => setTimeout(resolve, 500));
              
              safeUpdateProgress(loadingId, 30);
              safeUpdateMessage(loadingId, 'กำลังประมวลผลข้อมูล...', 'จัดเรียงและกรองข้อมูล');
              
              if (typeof window.forceReloadStock === 'function') {
                await window.forceReloadStock();
              } else {
                await refreshStockTable();
              }
              
              safeUpdateProgress(loadingId, 100);
              safeUpdateMessage(loadingId, 'รีเฟรชเสร็จสิ้น', 'ข้อมูลล่าสุดพร้อมใช้งาน');
              
              await new Promise(resolve => setTimeout(resolve, 800));
              
            } catch (error) {
              safeUpdateMessage(loadingId, 'เกิดข้อผิดพลาด', 'ไม่สามารถรีเฟรชข้อมูลได้');
              await new Promise(resolve => setTimeout(resolve, 1200));
              throw error;
            } finally {
              safeHideLoading(loadingId);
            }
          };
        }
        
        // Load verified history button with enhanced loading
        const btnLoadVerifiedHistory = document.getElementById('btnLoadVerifiedHistory');
        if (btnLoadVerifiedHistory) {
          enhanceButtonWithLoading(btnLoadVerifiedHistory, {
            spinnerType: 'default',
            successMessage: 'โหลดประวัติสำเร็จ',
            errorMessage: 'โหลดประวัติไม่สำเร็จ'
          });
          
          btnLoadVerifiedHistory.onclick = async function() {
            const dateFrom = document.getElementById('dateFrom')?.value;
            const dateTo = document.getElementById('dateTo')?.value;
            
            if (!dateFrom || !dateTo) {
              showToast('กรุณาเลือกช่วงวันที่', 'warning');
              return;
            }
            
            const loadingId = safeShowLoading({
              message: 'กำลังค้นหาประวัติ...',
              subMessage: `ค้นหาตั้งแต่ ${dateFrom} ถึง ${dateTo}`,
              showProgress: true,
              spinnerType: 'default'
            });
            
            try {
              safeUpdateMessage(loadingId, 'กำลังค้นหาข้อมูล...', 'เชื่อมต่อกับฐานข้อมูล');
              safeUpdateProgress(loadingId, 25);
              
              await new Promise(resolve => setTimeout(resolve, 300));
              
              safeUpdateMessage(loadingId, 'กำลังประมวลผลผลลัพธ์...', 'จัดเรียงข้อมูลตามวันที่');
              safeUpdateProgress(loadingId, 70);
              
              await loadVerifiedHistory();
              
              safeUpdateProgress(loadingId, 100);
              safeUpdateMessage(loadingId, 'ค้นหาเสร็จสิ้น', 'แสดงผลประวัติที่พบ');
              
              await new Promise(resolve => setTimeout(resolve, 500));
              
            } catch (error) {
              safeUpdateMessage(loadingId, 'เกิดข้อผิดพลาด', 'ไม่สามารถค้นหาประวัติได้');
              await new Promise(resolve => setTimeout(resolve, 1200));
              throw error;
            } finally {
              safeHideLoading(loadingId);
            }
          };
        }
        
        // Send to stock button with enhanced loading
        const btnSendToStock = document.getElementById('btnSendToStock');
        if (btnSendToStock) {
          enhanceButtonWithLoading(btnSendToStock, {
            spinnerType: 'dots',
            successMessage: 'ส่งสำเร็จ',
            errorMessage: 'ส่งไม่สำเร็จ'
          });
          
          btnSendToStock.onclick = async function() {
            if (selectedStocks.size === 0) {
              showToast('กรุณาเลือกสินค้าที่ต้องการส่ง', 'warning');
              return;
            }
            
            const stockCount = selectedStocks.size;
            const confirmed = await new Promise((resolve) => {
              customConfirm(`ยืนยันการส่งสินค้า ${stockCount} รายการไปยังฝ่ายสต็อก?`, () => resolve(true));
              // Add timeout to auto-resolve if user doesn't respond
              setTimeout(() => resolve(false), 10000);
            });
            
            if (!confirmed) return;
            
            const loadingId = safeShowLoading({
              message: 'กำลังส่งไปยังฝ่ายสต็อก...',
              subMessage: `ประมวลผล ${stockCount} รายการ`,
              showProgress: true,
              autoProgress: false,
              spinnerType: 'dots'
            });
            
            try {
              safeUpdateMessage(loadingId, 'กำลังตรวจสอบข้อมูล...', 'ตรวจสอบรายการที่เลือก');
              safeUpdateProgress(loadingId, 10);
              
              await new Promise(resolve => setTimeout(resolve, 200));
              
              safeUpdateMessage(loadingId, 'กำลังส่งข้อมูล...', 'อัปเดตสถานะในระบบ');
              safeUpdateProgress(loadingId, 30);
              
              // Rate limit check
              if (!RateLimiter.check('update_action')) {
                throw new Error('Rate limit exceeded');
              }
              
              const stockIds = Array.from(selectedStocks);
              const userInfo = await getCurrentUserInfo();
              
              safeUpdateProgress(loadingId, 50);
              safeUpdateMessage(loadingId, 'กำลังอัปเดตฐานข้อมูล...', 'บันทึกการเปลี่ยนแปลง');
              
              // Update each stock with pending status
              const promises = stockIds.map(stockId => 
                secureFetch(`/api/branch-stock/${stockId}`, {
                  method: 'PATCH',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ 
                    sent_to_stock: true,
                    pending: true,
                    verified: false,
                    sent_by: userInfo.userId,
                    sent_by_name: userInfo.userName,
                    sent_at: new Date().toISOString()
                  })
                })
              );
              
              const results = await Promise.all(promises);
              const successCount = results.filter(r => r.ok).length;
              
              safeUpdateProgress(loadingId, 80);
              safeUpdateMessage(loadingId, 'กำลังแจ้งเตือน...', 'ส่งการแจ้งเตือนไปยังฝ่ายสต็อก');
              
              // POS Notification
              if (posNotificationSystem) {
                posNotificationSystem.showToast('pos', {
                  title: 'ส่งไปยังฝ่ายสต็อกสำเร็จ',
                  message: `ส่งสินค้า ${successCount} รายการไปยังฝ่ายสต็อกแล้ว`,
                  type: 'success',
                  icon: '📤',
                  duration: 4000
                });
                
                posNotificationSystem.addNotification('pos', {
                  title: 'ส่งสินค้าไปยังฝ่ายสต็อก',
                  message: `ส่งสินค้า ${successCount}/${stockIds.length} รายการเรียบร้อยแล้ว`,
                  type: 'success',
                  icon: '✅',
                  actions: [
                    {
                      label: 'ดูรายการที่ส่ง',
                      action: 'primary',
                      callback: () => switchTab('verified')
                    }
                  ],
                  metadata: {
                    itemCount: successCount,
                    totalCount: stockIds.length,
                    sentBy: userInfo.userName,
                    timestamp: new Date().toLocaleString('th-TH')
                  }
                });
              }
              
              safeUpdateProgress(loadingId, 100);
              safeUpdateMessage(loadingId, 'ส่งเสร็จสิ้น', `ส่งสินค้า ${successCount} รายการสำเร็จ`);
              
              // Clear selection and reload
              selectedStocks.clear();
              updateSelectedCount();
              
              await new Promise(resolve => setTimeout(resolve, 800));
              await loadStock();
              
              showToast(`ส่งสินค้า ${successCount}/${stockIds.length} รายการไปยังฝ่ายสต็อกเรียบร้อย`, 'success');
              
            } catch (error) {
              safeUpdateMessage(loadingId, 'เกิดข้อผิดพลาด', error.message || 'ไม่สามารถส่งข้อมูลได้');
              await new Promise(resolve => setTimeout(resolve, 1200));
              showToast('Error sending to stock: ' + (error.message || 'Unknown error'), 'error');
              throw error;
            } finally {
              safeHideLoading(loadingId);
            }
          };
        }
        
        // Select all button with enhanced feedback
        const btnSelectAll = document.getElementById('btnSelectAll');
        if (btnSelectAll) {
          btnSelectAll.addEventListener('click', () => {
            // Add visual feedback
            btnSelectAll.classList.add('loading');
            
            setTimeout(() => {
              document.querySelectorAll('.stock-checkbox:not(:disabled)').forEach(cb => {
                cb.checked = true;
                selectedStocks.add(cb.dataset.stockId);
              });
              document.querySelectorAll('.pending-checkbox').forEach(cb => {
                cb.checked = true;
                selectedStocks.add(cb.dataset.stockId);
              });
              updateSelectedCount();
              
              btnSelectAll.classList.remove('loading');
              
              // Show success feedback
              const count = selectedStocks.size;
              if (count > 0) {
                showToast(`เลือกสินค้า ${count} รายการแล้ว`, 'success');
              }
            }, 300);
          });
        }
        
        // Deselect all button with enhanced feedback
        const btnDeselectAll = document.getElementById('btnDeselectAll');
        if (btnDeselectAll) {
          btnDeselectAll.addEventListener('click', () => {
            // Add visual feedback
            btnDeselectAll.classList.add('loading');
            
            setTimeout(() => {
              document.querySelectorAll('.stock-checkbox').forEach(cb => {
                cb.checked = false;
                selectedStocks.delete(cb.dataset.stockId);
              });
              document.querySelectorAll('.pending-checkbox').forEach(cb => {
                cb.checked = false;
                selectedStocks.delete(cb.dataset.stockId);
              });
              selectedStocks.clear();
              updateSelectedCount();
              
              btnDeselectAll.classList.remove('loading');
              showToast('ยกเลิกการเลือกทั้งหมดแล้ว', 'info');
            }, 200);
          });
        }

        // ... existing code ...
        
        // Initialize sidebar (if sidebar.js is loaded)
        if (typeof initializeSidebar === 'function') {
          initializeSidebar();
        }
        
        // Set default dates for verified tab
        const today = new Date();
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(today.getDate() - 30);
        
        if (dateFrom) dateFrom.value = thirtyDaysAgo.toISOString().split('T')[0];
        if (dateTo) dateTo.value = today.toISOString().split('T')[0];
        
        // Check DOM elements
        console.log('🔍 Checking DOM elements:');
        console.log('  - stockContainer:', !!document.getElementById('stockContainer'));
        console.log('  - verifiedContainer:', !!document.getElementById('verifiedContainer'));
        console.log('  - branchSelect:', !!document.getElementById('branchSelect'));
        console.log('  - branchSelect value:', document.getElementById('branchSelect')?.value);
        console.log('  - Active tab:', document.querySelector('.tab-active')?.id);
        
        Logger.info('Page initialization complete');
    
    // Initialize Firebase and Socket.IO connections
    try {
      initializeAddProductSocket();
      initializeFirebaseConnections();
      Logger.info('Firebase and Socket.IO initialization started');
    } catch (error) {
      Logger.error('Failed to initialize real-time features:', error);
    }
        
        // Comment out audit log for page access to prevent errors
                  // createAuditLog('PAGE_ACCESS', {
        //   page: 'addNewProduct_pattani',
        //   branch: BRANCH_CODE
        // });
        
        } catch (err) {
          Logger.error('Initialization error:', err);
          showToast('เกิดข้อผิดพลาดในการโหลดข้อมูล', 'error');
        } finally {
          // Hide Lottie loading
          setTimeout(() => { showLoading(false); }, 600);
        }
      } catch (err) {
        console.error('Failed to load page:', err);
        // Hide Lottie loading
        setTimeout(() => { showLoading(false); }, 600);
      }
    });

    // ==================== END INITIALIZATION ====================

    // Test function to check all stocks
    window.testLoadAllStocks = async function() {
      console.log('🧪 Testing: Loading ALL stocks without filter...');
      try {
        const branchCode = document.getElementById('branchSelect')?.value || BRANCH_CODE;
        const token = localStorage.getItem('authToken');
        
        // Load ALL stocks without any filter
        const res = await fetch(`/api/branch-stock?branch_code=${branchCode}`, {
          headers: {
            'Authorization': 'Bearer ' + token
          }
        });
        
        const result = await res.json();
        console.log('🧪 Test Result - All stocks:', result);
        
        if (result.data) {
          console.log('🧪 Total stocks found:', result.data.length);
          
          // Filter iPhone stocks
          const iPhoneStocks = result.data.filter(s => s.name && s.name.includes('iPhone'));
          console.log('🧪 iPhone stocks found:', iPhoneStocks.length);
          console.log('🧪 iPhone stocks details:', iPhoneStocks);
          
          // Check unverified stocks
          const unverifiedStocks = result.data.filter(s => 
            s.pending !== true && s.verified !== true
          );
          console.log('🧪 Unverified stocks:', unverifiedStocks.length);
          console.log('🧪 Unverified stocks details:', unverifiedStocks);
        }
      } catch (err) {
        console.error('🧪 Test error:', err);
      }
    };
    
    // Debug function to show all stocks with specific conditions
    window.debugShowAllStocks = async function() {
      console.log('🐛 Debug: Checking all stocks in the system...');
      try {
        const branchCode = document.getElementById('branchSelect')?.value || BRANCH_CODE;
        const token = localStorage.getItem('authToken');
        
        // Try multiple API calls with different parameters
        const endpoints = [
          `/api/branch-stock?branch_code=${branchCode}`,
          `/api/branch-stock?branch_code=${branchCode}&pending=false`,
          `/api/branch-stock?branch_code=${branchCode}&verified=false`,
          `/api/branch-stock?branch_code=${branchCode}&include_unverified=1`,
          `/api/branch-stock?branch_code=${branchCode}&include_all=1`
        ];
        
        for (const endpoint of endpoints) {
          console.log(`\n🔍 Testing endpoint: ${endpoint}`);
          const res = await fetch(endpoint, {
            headers: { 'Authorization': 'Bearer ' + token }
          });
          
          if (res.ok) {
            const result = await res.json();
            if (result.data && result.data.length > 0) {
              console.log(`✅ Found ${result.data.length} stocks`);
              
              // Show iPhone 13 stocks specifically
              const iPhone13Stocks = result.data.filter(s => s.name && s.name.includes('iPhone 13'));
              if (iPhone13Stocks.length > 0) {
                console.log(`📱 Found ${iPhone13Stocks.length} iPhone 13 stocks:`);
                iPhone13Stocks.forEach(stock => {
                  console.log(`  - ${stock.name}:`, {
                    id: stock._id,
                    pending: stock.pending,
                    verified: stock.verified,
                    sent_to_stock: stock.sent_to_stock,
                    created_at: stock.created_at
                  });
                });
              }
            } else {
              console.log('❌ No stocks found');
            }
          } else {
            console.error('❌ API call failed:', res.status);
          }
        }
      } catch (err) {
        console.error('🐛 Debug error:', err);
      }
    };
    
    console.log('💡 Debug functions available: debugShowAllStocks()');
    
    // Add test function to window for easy access
    console.log('💡 Test function available: testLoadAllStocks()');
    
    // Force reload stock with cache bypass
    window.forceReloadStock = async function() {
      console.log('🔄 Force reloading stock with cache bypass...');
      try {
        const branchCode = document.getElementById('branchSelect')?.value || BRANCH_CODE;
        const token = localStorage.getItem('authToken');
        
        // Clear any cached data
        sessionStorage.removeItem('stockData');
        
        // Add timestamp and random number to force cache bypass
        const timestamp = new Date().getTime();
        const random = Math.random();
        const url = `/api/branch-stock?branch_code=${branchCode}&include_unverified=1&include_all=1&_=${timestamp}&r=${random}`;
        
        console.log('🌐 Fetching from:', url);
        
        const res = await fetch(url, {
          headers: {
              'Authorization': 'Bearer ' + token,
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          },
          cache: 'no-store'
        });
        
        const result = await res.json();
        console.log('📦 Force reload result:', {
          success: result.success,
          dataCount: result.data ? result.data.length : 0,
          data: result.data
        });
        
        if (result.data && result.data.length > 0) {
          // Show all stocks
          console.log('📋 All stocks:');
          result.data.forEach((stock, i) => {
            console.log(`${i+1}. ${stock.name} - Barcode: ${stock.barcode}, IMEI: ${stock.imei}, Status: pending=${stock.pending}, verified=${stock.verified}, sent_to_stock=${stock.sent_to_stock}`);
          });
          
          // Show unverified stocks
          const unverified = result.data.filter(s => s.verified !== true);
          console.log(`\n📌 Unverified stocks (${unverified.length} items):`);
          unverified.forEach((stock, i) => {
            console.log(`${i+1}. ${stock.name} - Created: ${stock.created_at}`);
          });
        }
        
        // Reload the UI
        await loadStock();
        
      } catch (err) {
        console.error('❌ Force reload error:', err);
      }
    };
    
    // Debug function to manually add test stock
    window.addTestStock = async function(productName = 'iPhone 13') {
      console.log('🧪 Adding test stock...');
      try {
        const branchCode = document.getElementById('branchSelect')?.value || BRANCH_CODE;
        const token = localStorage.getItem('authToken');
        const userInfo = await getCurrentUserInfo();
        
        // Generate unique barcode and IMEI
        const timestamp = Date.now();
        const testBarcode = `TEST${timestamp}`;
        const testIMEI = `${timestamp}123456789012345`;
        
        const testData = {
          branch_code: branchCode,
          barcode: testBarcode,

          imei: testIMEI,
          name: productName,
          price: 29900,
          brand: 'Apple',
          model: '13',
          category: 'Smartphone',
          stockType: 'imei',
          supplier: 'Test Supplier',
          scanned_by: userInfo.userId,
          scanned_by_name: userInfo.userName,
          updated_by: userInfo.userId,
          stock_value: 0,
          created_at: new Date().toISOString()
        };
        
        console.log('📤 Sending test data:', testData);
        
        const res = await fetch('/api/branch-stock', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + token
          },
          body: JSON.stringify(testData)
        });
        
        const result = await res.json();
        console.log('📥 Create result:', result);
        
        if (result.success) {
          console.log('✅ Test stock created successfully!');
          // Force reload to see the new item
          await forceReloadStock();
        } else {
          console.error('❌ Failed to create test stock:', result.error);
        }
        
      } catch (err) {
        console.error('❌ Error adding test stock:', err);
      }
    };

    // Test function to debug quantity vs imei stock types
    window.testStockTypes = async function() {
      console.log('🧪 Testing stock types...');
      
      // Test 1: Test IMEI product
      console.log('\n🧪 Test 1: Testing IMEI product...');
      const imeiResult = await handleBarcodeScan('123456789012345');
      console.log('📊 IMEI Result:', imeiResult);
      
      // Test 2: Test Quantity product
      console.log('\n🧪 Test 2: Testing Quantity product...');
      const quantityResult = await handleBarcodeScan('QUANTITY123');
      console.log('📊 Quantity Result:', quantityResult);
      
      // Test 3: Test with actual product search
      console.log('\n🧪 Test 3: Testing product search...');
      try {
        const token = localStorage.getItem('authToken');
        const res = await fetch('/api/product/find-by-barcode?code=QUANTITY123', {
          headers: { 'Authorization': 'Bearer ' + token }
        });
        const result = await res.json();
        console.log('📊 Product search result:', result);
      } catch (err) {
        console.error('❌ Product search error:', err);
      }
    };

         // Test function to check available products
     window.checkAvailableProducts = async function() {
       console.log('🧪 Checking available products...');
       try {
         const token = localStorage.getItem('authToken');
         const res = await fetch('/api/product-image', {
           headers: { 'Authorization': 'Bearer ' + token }
         });
         const result = await res.json();
         console.log('📊 Available products:', result);
         
         if (result.data && result.data.length > 0) {
           console.log('📋 First 5 products:');
           result.data.slice(0, 5).forEach((product, i) => {
             console.log(`${i+1}. ${product.name} - stockType: ${product.stockType || 'undefined'}, barcode: ${product.barcode}`);
           });
           
           // Find quantity products
           const quantityProducts = result.data.filter(p => p.stockType === 'quantity');
           console.log(`📊 Quantity products found: ${quantityProducts.length}`);
           if (quantityProducts.length > 0) {
             console.log('📋 Quantity products:');
             quantityProducts.forEach((product, i) => {
               console.log(`${i+1}. ${product.name} - barcode: ${product.barcode}`);
             });
           }
         }
       } catch (err) {
         console.error('❌ Error checking products:', err);
       }
     };

     // Test function to check available suppliers
     window.checkAvailableSuppliers = async function() {
       console.log('🧪 Checking available suppliers...');
       try {
         const token = localStorage.getItem('authToken');
         const res = await fetch('/api/supplier', {
           headers: { 'Authorization': 'Bearer ' + token }
         });
         const result = await res.json();
         console.log('📊 Available suppliers:', result);
         
         if (result.data && result.data.length > 0) {
           console.log('📋 All suppliers:');
           result.data.forEach((supplier, i) => {
             console.log(`${i+1}. "${supplier.name}" - ID: ${supplier._id}`);
           });
         }
         
         console.log('📋 Current defaultSupplier:', defaultSupplier);
       } catch (err) {
         console.error('❌ Error checking suppliers:', err);
       }
     };

     // Helper function to get working supplier name
     window.getWorkingSupplierName = async function() {
       console.log('🔍 Finding working supplier name...');
       try {
         const token = localStorage.getItem('authToken');
         const res = await fetch('/api/supplier', {
           headers: { 'Authorization': 'Bearer ' + token }
         });
         const result = await res.json();
         
         if (result.data && result.data.length > 0) {
           const workingSupplier = result.data[0];
           console.log('✅ Working supplier found:', workingSupplier.name);
           return workingSupplier.name;
         }
         
         console.warn('⚠️ No suppliers found in system');
         return null;
       } catch (err) {
         console.error('❌ Error getting working supplier:', err);
         return null;
       }
     };

     // Test function to try adding with working supplier
     window.testWithWorkingSupplier = async function() {
       console.log('🧪 Testing with working supplier...');
       
       const workingSupplier = await getWorkingSupplierName();
       if (workingSupplier) {
         console.log('🔍 Using working supplier:', workingSupplier);
         const testBarcode = 'TEST' + Date.now();
         const result = await handleBarcodeScan(testBarcode, { forceSupplier: workingSupplier });
         console.log('📊 Test result:', result);
         return result;
       } else {
         console.error('❌ No working supplier found');
         return null;
       }
     };

     // Test function to try adding with specific supplier
     window.testWithSupplier = async function(supplierName = 'ไม่ระบุ') {
       console.log('🧪 Testing with specific supplier:', supplierName);
       
       const testBarcode = 'TEST' + Date.now();
       const result = await handleBarcodeScan(testBarcode, { testSupplier: supplierName });
       console.log('📊 Test result:', result);
       
       return result;
     };

     // Function to validate supplier exists in system
     window.validateSupplier = async function(supplierName) {
       console.log('🔍 Validating supplier:', supplierName);
       try {
         const token = localStorage.getItem('authToken');
         const res = await fetch('/api/supplier', {
           headers: { 'Authorization': 'Bearer ' + token }
         });
         const result = await res.json();
         
         if (result.data && result.data.length > 0) {
           const found = result.data.find(s => s.name === supplierName);
           console.log('📊 Supplier validation result:', found ? 'Found' : 'Not found');
           return found;
         }
         
         return null;
       } catch (err) {
         console.error('❌ Error validating supplier:', err);
         return null;
       }
     };

     // Function to get the first valid supplier from system
     window.getFirstValidSupplier = async function() {
       console.log('🔍 Getting first valid supplier...');
       try {
         const token = localStorage.getItem('authToken');
         const res = await fetch('/api/supplier', {
           headers: { 'Authorization': 'Bearer ' + token }
         });
         const result = await res.json();
         
         if (result.data && result.data.length > 0) {
           const firstSupplier = result.data[0];
           console.log('✅ First valid supplier found:', firstSupplier.name);
           return firstSupplier;
         }
         
         console.warn('⚠️ No suppliers found in system');
         return null;
       } catch (err) {
         console.error('❌ Error getting first valid supplier:', err);
         return null;
       }
     };
    
         console.log('💡 Debug functions available:');
     console.log('  - forceReloadStock() : Force reload all stock data with cache bypass');
     console.log('  - addTestStock() : Add a test iPhone 13 stock item');
     console.log('  - addTestStock("Product Name") : Add test stock with custom name');
     console.log('  - testStockTypes() : Test both IMEI and quantity stock types');
     console.log('  - checkAvailableProducts() : Check available products and their stock types');
     console.log('  - checkAvailableSuppliers() : Check available suppliers in the system');
     console.log('  - testWithSupplier("supplier name") : Test adding stock with specific supplier');
     console.log('  - getWorkingSupplierName() : Get the first working supplier name');
     console.log('  - testWithWorkingSupplier() : Test adding with working supplier');
     console.log('🔧 Latest fixes:');
     console.log('  - Enhanced supplier fallback system with all available suppliers');
     console.log('  - Using comprehensive fallback strategies (original + trimmed names)');
     console.log('  - Added support for all suppliers in the system, not just default');
     console.log('  - Added null/empty supplier fallback for systems that allow it');
     console.log('');
     console.log('🛠️ To fix supplier issue:');
     console.log('  1. Run checkAvailableSuppliers() to see actual suppliers');
     console.log('  2. Run testWithWorkingSupplier() to test with working supplier');
     console.log('  3. Check that defaultSupplier is loaded correctly');
     console.log('  4. ✅ ENHANCED: Now trying all available suppliers with multiple formats');
    
    function checkConnection() {
      // Use a more flexible check for production environment
      if (window.location.hostname === 'localhost' || window.location.hostname.endsWith('2pheenong.com')) {
        console.log('Connection check passed');
      } else {
        console.log('Connection check for other domains');
      }
    }

    // ==================== CLEANUP & MEMORY MANAGEMENT ====================
    
    // Cleanup function when leaving page
    function cleanup() {
      // Stop batch scanning
      if (isBatchScanning) {
        stopBatchScanning();
      }
      
      // Clear intervals
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
      }
      
      if (scanningTimeout) {
        clearTimeout(scanningTimeout);
        scanningTimeout = null;
      }
      
      // Clear recent additions
      recentAdditions = [];
      
      Logger.info('Page cleanup completed');
    }
    
    // Add event listeners for page cleanup
    window.addEventListener('beforeunload', cleanup);
    window.addEventListener('pagehide', cleanup);
    
    // Enhanced visibility change handler
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Pause auto-refresh when tab is hidden
        if (autoRefreshInterval && !isBatchScanning) {
          clearInterval(autoRefreshInterval);
          autoRefreshInterval = null;
        }
      } else {
        // Resume auto-refresh when tab is visible
        if (!autoRefreshInterval && !isBatchScanning) {
          autoRefreshInterval = setInterval(() => {
            if (!isBatchScanning) {
              refreshStockTable();
            }
          }, 15000);
        }
      }
    });
    
    // Multi-item addition helper functions
    window.addMultipleTestItems = async function(count = 5) {
      console.log(`🧪 Adding ${count} test items...`);
      if (!isBatchScanning) startBatchScanning();
      
      for (let i = 0; i < count; i++) {
        const timestamp = Date.now() + i;
        const testBarcode = `TEST${timestamp}`;
        await new Promise(resolve => setTimeout(resolve, 500)); // Delay between items
        document.getElementById('barcodeInput').value = testBarcode;
        document.getElementById('barcodeInput').dispatchEvent(new KeyboardEvent('keypress', { key: 'Enter' }));
      }
      
      setTimeout(() => {
        if (isBatchScanning) stopBatchScanning();
      }, 2000);
    };
    
    console.log('💡 Multi-item debug functions:');
    console.log('  - addMultipleTestItems(5) : Add 5 test items in batch mode');

    // =================== POS NOTIFICATION GLOBAL FUNCTIONS ===================
    
    // Global functions for external use
    window.showPOSToast = function(title, message, type = 'info', options = {}) {
      if (posNotificationSystem) {
        return posNotificationSystem.showToast('pos', {
          title,
          message,
          type,
          icon: options.icon || '📦',
          duration: options.duration || 4000,
          ...options
        });
      } else {
        console.warn('POS Notification System not initialized');
        showToast(`${title}: ${message}`, type);
      }
    };

    window.addPOSNotification = function(title, message, type = 'info', options = {}) {
      if (posNotificationSystem) {
        return posNotificationSystem.addNotification('pos', {
          title,
          message,
          type,
          icon: options.icon || '📦',
          actions: options.actions || [],
          metadata: {
            source: 'external',
            timestamp: new Date().toLocaleString('th-TH'),
            ...options.metadata
          },
          ...options
        });
      } else {
        console.warn('POS Notification System not initialized');
      }
    };

    // Clear all POS notifications
    window.clearPOSNotifications = function() {
      if (posNotificationSystem) {
        posNotificationSystem.clearNotifications('pos');
      }
    };

    // Mark all POS notifications as read
    window.markAllPOSAsRead = function() {
      if (posNotificationSystem) {
        posNotificationSystem.markAllAsRead('pos');
      }
    };

    // Get notification system status
    window.getPOSNotificationStatus = function() {
      if (posNotificationSystem) {
        return {
          initialized: true,
          unreadCount: posNotificationSystem.getUnreadCount('pos'),
          totalCount: posNotificationSystem.getNotificationCount('pos'),
          system: posNotificationSystem
        };
      }
      return { initialized: false };
    };

    // Test notification function (for debugging)
    window.testPOSNotifications = function() {
      console.log('🧪 Testing POS Notifications...');
      
      if (!posNotificationSystem) {
        console.error('❌ POS Notification System not initialized');
        return;
      }

      // Test toast
      showPOSToast('ทดสอบระบบ', 'ระบบแจ้งเตือน POS สำหรับคลังสินค้า ทำงานปกติ', 'success', {
        icon: '🧪',
        duration: 3000
      });

      // Test notification with actions
      addPOSNotification('ทดสอบการแจ้งเตือน', 'นี่คือการทดสอบระบบแจ้งเตือน POS สำหรับจัดการคลังสินค้า', 'info', {
        icon: '🔔',
        actions: [
          {
            label: 'เริ่มสแกน',
            action: 'primary',
            callback: () => {
              console.log('✅ ผู้ใช้คลิกเริ่มสแกน');
              document.getElementById('manualBarcode')?.focus();
            }
          },
          {
            label: 'ดูรายการ',
            action: 'secondary', 
            callback: () => {
              console.log('📋 ผู้ใช้คลิกดูรายการ');
              switchTab('unverified');
            }
          }
        ],
        metadata: {
          testId: Date.now(),
          testType: 'manual',
          module: 'inventory'
        }
      });

      // Display status
      const status = getPOSNotificationStatus();
      console.log('📊 POS Notification Status:', status);
    };

    // Auto-test on development environment
    if (window.location.hostname === 'localhost' || window.location.hostname.includes('dev')) {
      // Add test button
      setTimeout(() => {
        if (!document.getElementById('testPOSNotificationBtn')) {
          const testBtn = document.createElement('button');
          testBtn.id = 'testPOSNotificationBtn';
          testBtn.textContent = '🔔 Test POS Notifications';
          testBtn.className = 'fixed bottom-2 left-2 z-50 bg-cyan-500 text-white px-3 py-1 rounded text-sm';
          testBtn.onclick = () => testPOSNotifications();
          document.body.appendChild(testBtn);
        }
      }, 2000);
    }

    console.log('🔔 POS Notification Global Functions initialized');
    
    // ==================== FIREBASE & SOCKET.IO INITIALIZATION ====================
    
    // Initialize Socket.IO and Firebase connections after DOM is ready
    setTimeout(() => {
      try {
        // Initialize Socket.IO connection
        initializeAddProductSocket();
        
        // Initialize Firebase connections
        initializeFirebaseConnections();
        
        console.log('🔥 Firebase and Socket.IO initialization started');
      } catch (error) {
        console.error('❌ Failed to initialize real-time features:', error);
      }
    }, 1000);
    
    // Clean up Firebase session and Socket.IO on page unload
    window.addEventListener('beforeunload', function() {
      if (firebaseSessionId && window.firebaseDatabase) {
        const branchCode = getCurrentBranchCode();
        const sessionRef = window.firebaseRef(window.firebaseDatabase, `pos/${branchCode}/sessions/${firebaseSessionId}`);
        window.firebaseUpdate(sessionRef, {
          status: 'offline',
          logoutTime: window.firebaseServerTimestamp()
        }).catch(() => {}); // Ignore errors on unload
      }
      
      if (addProductSocket) {
        addProductSocket.disconnect();
      }

      // Clean up Lottie animation
      if (lottieAnimation) {
        lottieAnimation.destroy();
        lottieAnimation = null;
      }
    });
    
    // Enhanced activity tracking for product additions
    function enhanceProductAdditionTracking() {
      // Override existing addProduct function to include Firebase logging
      const originalAddToUnverified = window.addToUnverifiedStock;
      if (originalAddToUnverified) {
        window.addToUnverifiedStock = function(data) {
          // Log to Firebase
          if (window.logAddProductActivity) {
            window.logAddProductActivity('PRODUCT_ADDED', {
              barcode: data.barcode,
              productName: data.name,
              imei: data.imei,
              stockType: data.stockType,
              method: 'manual_entry'
            });
          }
          
          // Send stock update to Firebase
          sendStockUpdateToFirebase({
            action: 'PRODUCT_ADDED',
            productName: data.name,
            barcode: data.barcode,
            message: `เพิ่มสินค้าใหม่: ${data.name}`
          });
          
          // Emit Socket.IO event
          if (addProductSocket && addProductSocket.connected) {
            addProductSocket.emit('product-added', {
              productName: data.name,
              barcode: data.barcode,
              userId: localStorage.getItem('userId'),
              userName: localStorage.getItem('userName'),
              branchCode: getCurrentBranchCode(),
              timestamp: Date.now()
            });
          }
          
          // Call original function
          return originalAddToUnverified.call(this, data);
        };
      }
      
      // Override send for approval function
      const originalSendForApproval = window.sendForApproval;
      if (originalSendForApproval) {
        window.sendForApproval = function() {
          // Log to Firebase
          if (window.logAddProductActivity) {
            window.logAddProductActivity('STOCK_SENT_FOR_APPROVAL', {
              itemCount: Object.keys(unverifiedStock).length,
              sentBy: localStorage.getItem('userName')
            });
          }
          
          // Send stock update to Firebase
          sendStockUpdateToFirebase({
            action: 'STOCK_SENT_FOR_APPROVAL',
            message: `ส่งสินค้าเข้าระบบอนุมัติ จำนวน ${Object.keys(unverifiedStock).length} รายการ`
          });
          
          // Emit Socket.IO event
          if (addProductSocket && addProductSocket.connected) {
            addProductSocket.emit('stock-sent-for-approval', {
              itemCount: Object.keys(unverifiedStock).length,
              userId: localStorage.getItem('userId'),
              userName: localStorage.getItem('userName'),
              branchCode: getCurrentBranchCode(),
              timestamp: Date.now()
            });
          }
          
          // Call original function
          return originalSendForApproval.call(this);
        };
      }
    }
    
    // Hide Lottie loading animation
    setTimeout(() => showLoading(false), 800);

    // Apply enhanced tracking after a delay to ensure functions are loaded
    setTimeout(enhanceProductAdditionTracking, 2000);
    
    // ==================== END CLEANUP & MEMORY MANAGEMENT ====================

    // Test the enhanced supplier fallback system
    window.testEnhancedSupplierFallback = async function() {
      console.log('🧪 Testing enhanced supplier fallback system...');
      
      // Test with the barcode that failed in console
      const testBarcode = '1478523691012365';
      console.log('🔍 Testing with barcode from user console:', testBarcode);
      
      try {
        const result = await handleBarcodeScan(testBarcode);
        console.log('📊 Enhanced fallback test result:', result);
        
        if (result.success) {
          console.log('✅ Enhanced supplier fallback system working correctly!');
          return true;
        } else {
          console.log('❌ Enhanced fallback system still has issues:', result.error);
          return false;
        }
      } catch (error) {
        console.error('❌ Error during enhanced fallback test:', error);
        return false;
      }
    };

    // Function to show current supplier configuration
    window.showSupplierConfiguration = async function() {
      console.log('🔍 Current supplier configuration:');
      console.log('📋 Default supplier:', defaultSupplier);
      console.log('📋 Available suppliers:', window.availableSuppliers);
      
      if (window.availableSuppliers) {
        console.log('�� Supplier breakdown:');
        window.availableSuppliers.forEach((supplier, index) => {
          console.log(`${index + 1}. "${supplier.name}" (ID: ${supplier._id})`);
        });
      }
    };
  </script>
</body>
</html>