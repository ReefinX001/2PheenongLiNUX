// routes/attendanceRoutes.js
const express    = require('express');
const router     = express.Router();
const authJWT    = require('../middlewares/authJWT');
const hasPermission = require('../middlewares/hasPermission');       // üëà ‡πÄ‡∏û‡∏¥‡πà‡∏°
const Attendance = require('../models/HR/Attendance');
const { body, validationResult } = require('express-validator');

// --- validation middleware for checkin ---
const validateCheckin = [
  body('branch').notEmpty().withMessage('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏™‡∏≤‡∏Ç‡∏≤'),
  body('checkInType').optional().isIn(['normal', 'outside_area', 'other_branch']).withMessage('‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Å‡∏≠‡∏¥‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á'),
  body('isOT').optional().isBoolean().withMessage('‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ OT ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô true ‡∏´‡∏£‡∏∑‡∏≠ false'),
  body('location').optional().isObject()
    .custom(value => {
      // Accept both lat/lng and latitude/longitude formats
      if ((value.lat != null && value.lng != null) ||
          (value.latitude != null && value.longitude != null)) {
        return true;
      }
      throw new Error('Location ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ latitude ‡πÅ‡∏•‡∏∞ longitude');
    }),
  body('note').optional().isString().trim(),
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ success:false, errors: errors.array() });
    }
    next();
  }
];

// Test endpoint (no auth required)
router.get('/test', (req, res) => {
  console.log('üß™ Test endpoint called');
  res.json({ success: true, message: 'Attendance routes working!' });
});

// ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô public routes ‡∏ï‡πâ‡∏≠‡∏á‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏Å‡πà‡∏≠‡∏ô
router.use(authJWT);

/**
 * GET /api/attendance/session/today
 * ‚Äî ‡∏Ñ‡∏∑‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô/‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏≠‡∏≤‡∏ó‡πå ‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏™‡∏≤‡∏Ç‡∏≤‡∏°‡∏≤‡πÉ‡∏ô query string
 */
router.get('/session/today', async (req, res, next) => {
  try {
    console.log('üìç GET /api/attendance/session/today called');
    console.log('üìç User:', req.user?._id);
    console.log('üìç Branch:', req.query.branch);

    const userId = req.user._id;
    const { branch } = req.query;
    if (!branch) {
      console.log('‚ùå No branch provided');
      return res.status(400).json({ success: false, error: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏™‡∏≤‡∏Ç‡∏≤ (branch) ‡πÉ‡∏ô query' });
    }

    const startOfDay = new Date();
    startOfDay.setHours(0, 0, 0, 0);
    const endOfDay = new Date();
    endOfDay.setHours(23, 59, 59, 999);

    const session = await Attendance.findOne({
      user:    userId,
      branch,
      checkIn: { $gte: startOfDay, $lte: endOfDay }
    }).sort({ checkIn: -1 });

    if (!session) {
      return res.status(404).json({
        success: false,
        error: '‡πÑ‡∏°‡πà‡∏û‡∏ö session ‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏≤‡∏Ç‡∏≤‡∏ô‡∏µ‡πâ‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ'
      });
    }

    return res.json({
      success: true,
      inTime:  session.checkIn,
      outTime: session.checkOut || null
    });
  } catch (err) {
    console.error('Error in GET /session/today:', err);
    next(err);
  }
});

/**
 * GET /api/attendance/branches/my-accessible
 * ‚Äî ‡∏Ñ‡∏∑‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏≤‡∏Ç‡∏≤‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô‡πÑ‡∏î‡πâ
 */
router.get('/branches/my-accessible', async (req, res, next) => {
  try {
    const userId = req.user._id;

    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ä‡πá‡∏Ñ accessibleBranches
    const User = require('../models/User/User');
    const user = await User.findById(userId).populate('accessibleBranches');

    if (!user) {
      return res.status(404).json({ success: false, error: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ' });
    }

    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ accessibleBranches ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏≤‡∏£‡πå‡πÄ‡∏£‡∏¢‡πå‡∏ß‡πà‡∏≤‡∏á ‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏™‡∏≤‡∏Ç‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà active
    let branches;
    if (!user.accessibleBranches || user.accessibleBranches.length === 0) {
      const Zone = require('../models/HR/zoneModel');
      branches = await Zone.find({ isActive: true }).sort({ name: 1 });
    } else {
      branches = user.accessibleBranches.filter(branch => branch.isActive);
    }

    return res.json({
      success: true,
      data: branches
    });
  } catch (err) {
    console.error('Error in GET /branches/my-accessible:', err);
    next(err);
  }
});

/**
 * POST /api/attendance
 * ‚Äî Generic ‡∏™‡∏£‡πâ‡∏≤‡∏á record ‡πÉ‡∏´‡∏°‡πà (‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏∏ branch ‡πÉ‡∏ô query string)
 */
router.post('/', async (req, res, next) => {
  try {
    const userId = req.user._id;
    const { branch } = req.query;
    if (!branch) {
      return res.status(400).json({ success: false, error: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏™‡∏≤‡∏Ç‡∏≤ (branch) ‡πÉ‡∏ô query' });
    }

    const { checkIn, checkOut, location, note } = req.body;
    const att = new Attendance({
      user:     userId,
      branch,
      checkIn:  checkIn  ? new Date(checkIn)  : new Date(),
      checkOut: checkOut ? new Date(checkOut) : undefined,
      location: location || {},
      note:     note     || ''
    });

    await att.save();
    return res.status(201).json({ success: true, attendance: att });
  } catch (err) {
    console.error('Error in POST /api/attendance:', err);
    next(err);
  }
});

/**
 * POST /api/attendance/action
 * ‚Äî ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å action ‡∏ï‡πà‡∏≤‡∏á‡πÜ (checkin, break_out, break_in, checkout)
 */
router.post('/action', validateCheckin, async (req, res, next) => {
  try {
    const userId = req.user._id;
    const { branch, location, note, checkInType = 'normal', isOT = false, actionType } = req.body;

    if (!actionType) {
      return res.status(400).json({
        success: false,
        error: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏ actionType (checkin, break_out, break_in, checkout)'
      });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏™‡∏≤‡∏Ç‡∏≤‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const User = require('../models/User/User');
    const user = await User.findById(userId).populate('checkinBranches');

    if (user && user.checkinBranches && user.checkinBranches.length > 0) {
      const hasAccess = user.checkinBranches.some(b => b._id.toString() === branch);
      if (!hasAccess && checkInType === 'normal') {
        return res.status(403).json({
          success: false,
          error: '‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏Ç‡∏≤‡∏ô‡∏µ‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô‡∏ï‡πà‡∏≤‡∏á‡∏™‡∏≤‡∏Ç‡∏≤'
        });
      }
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö action flow ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const todayActions = await Attendance.find({
      user: userId,
      branch,
      checkIn: { $gte: today, $lt: tomorrow }
    }).sort({ checkIn: 1 });

    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î expected action ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
    let expectedAction = 'checkin'; // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏á‡∏≤‡∏ô‡∏Å‡πà‡∏≠‡∏ô
    if (todayActions.length > 0) {
      const lastAction = todayActions[todayActions.length - 1].actionType;
      const actionFlow = {
        'checkin': 'break_out',    // ‡πÄ‡∏Ç‡πâ‡∏≤‡∏á‡∏≤‡∏ô -> ‡∏≠‡∏≠‡∏Å‡∏û‡∏±‡∏Å
        'break_out': 'break_in',   // ‡∏≠‡∏≠‡∏Å‡∏û‡∏±‡∏Å -> ‡πÄ‡∏Ç‡πâ‡∏≤‡∏á‡∏≤‡∏ô
        'break_in': 'checkout',    // ‡πÄ‡∏Ç‡πâ‡∏≤‡∏á‡∏≤‡∏ô -> ‡πÄ‡∏•‡∏¥‡∏Å‡∏á‡∏≤‡∏ô
        'checkout': null           // ‡πÄ‡∏•‡∏¥‡∏Å‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ
      };
      expectedAction = actionFlow[lastAction];
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ action ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö flow ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (expectedAction === null) {
      return res.status(400).json({
        success: false,
        error: '‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¥‡∏Å‡∏á‡∏≤‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß'
      });
    }

    if (actionType !== expectedAction) {
      const actionLabels = {
        'checkin': '‡πÄ‡∏Ç‡πâ‡∏≤‡∏á‡∏≤‡∏ô',
        'break_out': '‡∏≠‡∏≠‡∏Å‡∏û‡∏±‡∏Å',
        'break_in': '‡πÄ‡∏Ç‡πâ‡∏≤‡∏á‡∏≤‡∏ô (‡∏´‡∏•‡∏±‡∏á‡∏û‡∏±‡∏Å)',
        'checkout': '‡πÄ‡∏•‡∏¥‡∏Å‡∏á‡∏≤‡∏ô'
      };
      return res.status(400).json({
        success: false,
        error: `‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡πá‡∏ô "${actionLabels[expectedAction]}" ‡πÅ‡∏ï‡πà‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏•‡∏∑‡∏≠‡∏Å "${actionLabels[actionType]}"`,
        expectedAction,
        currentAction: actionType
      });
    }

    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥
    let approvalStatus = 'not_required';
    if (checkInType === 'outside_area' || checkInType === 'other_branch') {
      approvalStatus = 'pending';
    }

    // Normalize location format
    const normalizedLocation = location ? {
      latitude: location.latitude || location.lat,
      longitude: location.longitude || location.lng
    } : undefined;

    const att = new Attendance({
      user: userId,
      branch,
      checkIn: new Date(),
      actionType,
      checkInType,
      isOT,
      approvalStatus,
      location: normalizedLocation,
      note: note || ''
    });

    await att.save();

    const io = req.app.get('io');
    if (io) {
      io.emit('attendanceAction', att);
      if (approvalStatus === 'pending') {
        io.emit('attendanceApprovalRequired', {
          userId,
          attendanceId: att._id,
          checkInType,
          message: `${user.username} ‡∏Ç‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô${checkInType === 'outside_area' ? '‡∏ô‡∏≠‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà' : '‡∏ï‡πà‡∏≤‡∏á‡∏™‡∏≤‡∏Ç‡∏≤'}`
        });
      }
    }

    return res.status(201).json({
      success: true,
      attendance: att,
      requiresApproval: approvalStatus === 'pending',
      nextAction: actionType === 'checkout' ? null : {
        'checkin': 'break_out',
        'break_out': 'break_in',
        'break_in': 'checkout'
      }[actionType]
    });
  } catch (err) {
    console.error('Error in POST /action:', err);
    next(err);
  }
});

/**
 * POST /api/attendance/checkin (backward compatibility)
 */
router.post('/checkin', validateCheckin, async (req, res, next) => {
  req.body.actionType = 'checkin';
  return router.handle(Object.assign(req, { url: '/action', method: 'POST' }), res, next);
});

/**
 * POST /api/attendance/checkout (backward compatibility)
 */
router.post('/checkout', async (req, res, next) => {
  req.body.actionType = 'checkout';
  return router.handle(Object.assign(req, { url: '/action', method: 'POST' }), res, next);
});

/**
 * GET /api/attendance/pending-approvals
 * ‚Äî ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥ (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö HR)
 */
router.get('/pending-approvals', async (req, res, next) => {
  try {
    // Allow admin, superadmin, HR role, and users with attendance permissions
    const userRole = req.user.role;
    const userPermissions = req.user.permissions || [];
    const canApprove = ['admin', 'superadmin', 'Super Admin', 'HR', 'hr'].includes(userRole) ||
                       userPermissions.includes('attendance:approve') ||
                       userPermissions.includes('attendance:read') ||
                       userPermissions.includes('hr:read');

    if (!canApprove) {
      return res.status(403).json({
        success: false,
        error: '‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏£‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥',
        userRole,
        userPermissions,
        required: ['attendance:approve', 'attendance:read', 'hr:read', 'HR role']
      });
    }

    const pendingAttendances = await Attendance.find({
      approvalStatus: 'pending'
    })
    .populate('user', 'username employee')
    .populate('branch', 'name branch_code')
    .sort({ checkIn: -1 });

    return res.json({
      success: true,
      data: pendingAttendances
    });
  } catch (err) {
    console.error('Error in GET /pending-approvals:', err);
    next(err);
  }
});

/**
 * POST /api/attendance/:id/approve
 * ‚Äî ‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö HR)
 */
router.post('/:id/approve', async (req, res, next) => {
  try {
    // Allow admin, superadmin, HR role, and users with attendance permissions
    const userRole = req.user.role;
    const userPermissions = req.user.permissions || [];
    const canApprove = ['admin', 'superadmin', 'Super Admin', 'HR', 'hr'].includes(userRole) ||
                       userPermissions.includes('attendance:approve') ||
                       userPermissions.includes('hr:approve');

    if (!canApprove) {
      return res.status(403).json({
        success: false,
        error: '‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô',
        userRole,
        userPermissions,
        required: ['attendance:approve', 'hr:approve', 'HR role']
      });
    }

    const { id } = req.params;
    const { approvalNote } = req.body;
    const approverId = req.user._id;

    const attendance = await Attendance.findById(id);
    if (!attendance) {
      return res.status(404).json({
        success: false,
        error: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô'
      });
    }

    if (attendance.approvalStatus !== 'pending') {
      return res.status(400).json({
        success: false,
        error: '‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß'
      });
    }

    attendance.approvalStatus = 'approved';
    attendance.approvedBy = approverId;
    attendance.approvedAt = new Date();
    attendance.approvalNote = approvalNote || '';

    await attendance.save();

    const io = req.app.get('io');
    if (io) {
      io.emit('attendanceApproved', {
        attendanceId: id,
        userId: attendance.user,
        approvedBy: approverId
      });
    }

    return res.json({
      success: true,
      attendance
    });
  } catch (err) {
    console.error('Error in POST /:id/approve:', err);
    next(err);
  }
});

/**
 * POST /api/attendance/:id/reject
 * ‚Äî ‡∏õ‡∏è‡∏¥‡πÄ‡∏™‡∏ò‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö HR)
 */
router.post('/:id/reject', async (req, res, next) => {
  try {
    // Allow admin, superadmin, HR role, and users with attendance permissions
    const userRole = req.user.role;
    const userPermissions = req.user.permissions || [];
    const canApprove = ['admin', 'superadmin', 'Super Admin', 'HR', 'hr'].includes(userRole) ||
                       userPermissions.includes('attendance:approve') ||
                       userPermissions.includes('hr:approve');

    if (!canApprove) {
      return res.status(403).json({
        success: false,
        error: '‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏è‡∏¥‡πÄ‡∏™‡∏ò‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô',
        userRole,
        userPermissions,
        required: ['attendance:approve', 'hr:approve', 'HR role']
      });
    }

    const { id } = req.params;
    const { approvalNote } = req.body;
    const approverId = req.user._id;

    const attendance = await Attendance.findById(id);
    if (!attendance) {
      return res.status(404).json({
        success: false,
        error: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô'
      });
    }

    if (attendance.approvalStatus !== 'pending') {
      return res.status(400).json({
        success: false,
        error: '‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß'
      });
    }

    attendance.approvalStatus = 'rejected';
    attendance.approvedBy = approverId;
    attendance.approvedAt = new Date();
    attendance.approvalNote = approvalNote || '';

    await attendance.save();

    const io = req.app.get('io');
    if (io) {
      io.emit('attendanceRejected', {
        attendanceId: id,
        userId: attendance.user,
        rejectedBy: approverId
      });
    }

    return res.json({
      success: true,
      attendance
    });
  } catch (err) {
    console.error('Error in POST /:id/reject:', err);
    next(err);
  }
});

/**
 * GET /api/attendance/my-history
 * ‚Äî ‡∏î‡∏π‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô‡∏Ç‡∏≠‡∏á‡∏ï‡∏ô‡πÄ‡∏≠‡∏á
 */
router.get('/my-history', async (req, res, next) => {
  try {
    const userId = req.user._id;
    const { page = 1, limit = 20, branch, status } = req.query;

    const query = { user: userId };
    if (branch) query.branch = branch;
    if (status) query.approvalStatus = status;

    const attendances = await Attendance.find(query)
      .populate('branch', 'name branch_code')
      .populate('approvedBy', 'username')
      .sort({ checkIn: -1 })
      .limit(limit * 1)
      .skip((page - 1) * limit);

    const total = await Attendance.countDocuments(query);

    return res.json({
      success: true,
      data: attendances,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (err) {
    console.error('Error in GET /my-history:', err);
    next(err);
  }
});

/**
 * GET /api/attendance
 * ‚Äî ‡∏î‡∏π‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (Admin, HR ‡∏´‡∏£‡∏∑‡∏≠‡∏ú‡∏π‡πâ‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå)
 */
router.get('/',
  async (req, res, next) => {
    try {
      // Allow admin, superadmin, HR role, and users with attendance permissions
      const userRole = req.user.role;
      const userPermissions = req.user.permissions || [];
      const canRead = ['admin', 'superadmin', 'Super Admin', 'HR', 'hr'].includes(userRole) ||
                      userPermissions.includes('attendance:read') ||
                      userPermissions.includes('attendance:approve') ||
                      userPermissions.includes('hr:read');

      if (!canRead) {
        return res.status(403).json({
          success: false,
          error: '‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô',
          userRole,
          userPermissions,
          required: ['attendance:read', 'attendance:approve', 'hr:read', 'HR role']
        });
      }

      const list = await Attendance.find()
        .populate('user', 'username employee')
        .populate('branch', 'name branch_code')
        .sort({ checkIn: -1 });
      return res.json({ success: true, attendance: list });
    } catch (err) {
      console.error('Error in GET /api/attendance:', err);
      next(err);
    }
  }
);

/**
 * GET /api/attendance/summary/:period
 */
router.get('/summary/:period', hasPermission('attendance:read'), async (req, res, next) => {
  try {
    // ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö admin ‡∏î‡∏π‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏ô‡∏≠‡∏∑‡πà‡∏ô
    const targetUserId = req.query.userId || req.user._id;
    if (targetUserId !== req.user._id) {
      if (!req.user.permissions?.includes('attendance:read-all')) {
        return res.status(403).json({
          success: false,
          error: '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡∏≠‡∏∑‡πà‡∏ô'
        });
      }
    }
    const { period } = req.params;
    const { date } = req.query;
    const { start, end } = calculateDateRange(period, date);
    const sessions = await Attendance.find({
      user: targetUserId,
      checkIn: { $gte: start, $lte: end }
    });
    const summary = {
      totalSessions: sessions.length,
      totalHours: calculateTotalHours(sessions),
      avgCheckInTime: calculateAvgTime(sessions, 'checkIn'),
      avgCheckOutTime: calculateAvgTime(sessions, 'checkOut')
    };
    return res.json({ success: true, summary });
  } catch (err) {
    next(err);
  }
});

// --- helper functions for summary route ---
function calculateDateRange(period, date) {
  const ref = date ? new Date(date) : new Date();
  let start, end;

  if (period === 'daily') {
    const base = new Date(ref);            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏≥‡πÄ‡∏ô‡∏≤
    start = new Date(base);
    start.setHours(0, 0, 0, 0);
    end = new Date(base);
    end.setHours(23, 59, 59, 999);
  } else if (period === 'weekly') {
    const day = ref.getDay();
    start = new Date(ref);
    start.setDate(ref.getDate() - day);
    start.setHours(0,0,0,0);
    end = new Date(start);
    end.setDate(start.getDate() + 6);
    end.setHours(23,59,59,999);
  } else if (period === 'monthly') {
    start = new Date(ref.getFullYear(), ref.getMonth(), 1);
    end   = new Date(ref.getFullYear(), ref.getMonth()+1, 0, 23,59,59,999);
  } else {
    start = new Date(0);
    end = new Date();
  }
  return { start, end };
}

function calculateTotalHours(sessions) {
  return sessions.reduce((sum, s) => {
    const out = s.checkOut || new Date();
    return sum + ((out - s.checkIn) / 36e5);
  }, 0);
}

function calculateAvgTime(sessions, field) {
  // ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞ sessions ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤ field
  const valid = sessions.filter(s => s[field]);
  if (valid.length === 0) return null;
  const total = valid.reduce((sum, s) => sum + new Date(s[field]).getTime(), 0);
  return new Date(total / valid.length).toISOString();
}

/**
 * GET /api/attendance/my-history
 * ‚Äî ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô/‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏≠‡∏≤‡∏ó‡πå ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
 */
router.get('/my-history', async (req, res, next) => {
  try {
    const userId = req.user._id;
    const { startDate, endDate, branch, limit = 50 } = req.query;
    const q = { user: userId };
    if (branch) q.branch = branch;
    if (startDate || endDate) {
      q.checkIn = {};
      if (startDate) q.checkIn.$gte = new Date(startDate);
      if (endDate)   q.checkIn.$lte = new Date(endDate);
    }
    const history = await Attendance.find(q)
      .populate('branch', 'name')
      .sort({ checkIn: -1 })
      .limit(parseInt(limit));
    return res.json({ success: true, data: history });
  } catch (err) {
    next(err);
  }
});

/**
 * GET /api/attendance/statistics
 * ‚Äî ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
 */
router.get('/statistics', async (req, res, next) => {
  try {
    const userId = req.user._id;
    const { period = 'monthly' } = req.query;

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤
    const now = new Date();
    let startDate, endDate;

    if (period === 'weekly') {
      startDate = new Date(now);
      startDate.setDate(now.getDate() - 7);
      endDate = now;
    } else if (period === 'monthly') {
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
    } else if (period === 'yearly') {
      startDate = new Date(now.getFullYear(), 0, 1);
      endDate = new Date(now.getFullYear() + 1, 0, 0);
    } else {
      // Default to last 30 days
      startDate = new Date(now);
      startDate.setDate(now.getDate() - 30);
      endDate = now;
    }

    const sessions = await Attendance.find({
      user: userId,
      checkIn: { $gte: startDate, $lte: endDate }
    }).populate('branch', 'name');

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
    const totalSessions = sessions.length;
    const completedSessions = sessions.filter(s => s.checkOut).length;
    const totalHours = sessions.reduce((sum, session) => {
      if (session.checkOut) {
        const hours = (new Date(session.checkOut) - new Date(session.checkIn)) / (1000 * 60 * 60);
        return sum + hours;
      }
      return sum;
    }, 0);

    const avgHoursPerDay = totalHours / Math.max(1, completedSessions);
    const branches = [...new Set(sessions.map(s => s.branch?.name).filter(Boolean))];

    const statistics = {
      period,
      startDate,
      endDate,
      totalSessions,
      completedSessions,
      ongoingSessions: totalSessions - completedSessions,
      totalHours: Math.round(totalHours * 100) / 100,
      avgHoursPerDay: Math.round(avgHoursPerDay * 100) / 100,
      activeBranches: branches,
      sessionsData: sessions.map(s => ({
        date: s.checkIn,
        branch: s.branch?.name,
        checkIn: s.checkIn,
        checkOut: s.checkOut,
        hours: s.checkOut ? Math.round(((new Date(s.checkOut) - new Date(s.checkIn)) / (1000 * 60 * 60)) * 100) / 100 : null,
        note: s.note
      }))
    };

    return res.json({ success: true, data: statistics });
  } catch (err) {
    console.error('Error in GET /statistics:', err);
    next(err);
  }
});

/**
 * PUT /api/attendance/:id
 * ‚Äî ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï record ‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á
 */
router.put('/:id', async (req, res, next) => {
  try {
    const userId = req.user._id;
    const { id } = req.params;

    const updates = {};
    if (req.body.checkIn)  updates.checkIn  = new Date(req.body.checkIn);
    if (req.body.checkOut) updates.checkOut = new Date(req.body.checkOut);
    if (req.body.location) updates.location = req.body.location;
    if (req.body.note)     updates.note     = req.body.note;

    const updated = await Attendance.findOneAndUpdate(
      { _id: id, user: userId },
      updates,
      { new: true }
    );

    if (!updated) {
      return res.status(404).json({
        success: false,
        error: '‡πÑ‡∏°‡πà‡∏û‡∏ö record ‡∏ô‡∏µ‡πâ ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏à‡πâ‡∏≤‡∏Ç‡∏≠‡∏á'
      });
    }

    return res.json({ success: true, attendance: updated });
  } catch (err) {
    console.error('Error in PUT /:id:', err);
    next(err);
  }
});

/**
 * DELETE /api/attendance/:id
 * ‚Äî ‡∏•‡∏ö record ‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á
 */
router.delete('/:id', async (req, res, next) => {
  try {
    const userId = req.user._id;
    const { id } = req.params;

    const deleted = await Attendance.findOneAndDelete({ _id: id, user: userId });
    if (!deleted) {
      return res.status(404).json({
        success: false,
        error: '‡πÑ‡∏°‡πà‡∏û‡∏ö record ‡∏ô‡∏µ‡πâ ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏à‡πâ‡∏≤‡∏Ç‡∏≠‡∏á'
      });
    }

    return res.json({ success: true, message: '‡∏•‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à' });
  } catch (err) {
    console.error('Error in DELETE /:id:', err);
    next(err);
  }
});

module.exports = router;
